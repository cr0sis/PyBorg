<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout by cr0sis</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #3b82f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-tertiary: #f3f4f6;
            --border-light: #e5e7eb;
            --border-medium: #d1d5db;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
        }

        [data-theme="dark"] {
            --primary-color: #3b82f6;
            --primary-dark: #2563eb;
            --primary-light: #60a5fa;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --bg-primary: #1f2937;
            --bg-secondary: #374151;
            --bg-tertiary: #4b5563;
            --border-light: #4b5563;
            --border-medium: #6b7280;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }
        
        .game-layout {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin: 20px 0;
        }
        
        .side-panel {
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Press Start 2P', monospace;
            color: #fff;
            font-size: 10px;
            line-height: 1.6;
        }
        
        .left-panel {
            text-align: left;
        }
        
        .right-panel {
            text-align: right;
        }
        
        .canvas-container {
            position: relative;
        }
        
        .ui-stat {
            margin: 8px 0;
            padding: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .ui-stat.level { color: #00FFFF; }
        .ui-stat.lives { color: #FF6B6B; }
        .ui-stat.score { color: #FFD700; }
        .ui-stat.banking { color: #32CD32; }
        .ui-stat.powerup { color: #FF69B4; }

        .network-header {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-light);
        }

        .network-header h2 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            font-size: 1.75rem;
        }

        .network-description {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .retro-ui-element {
            font-family: 'Press Start 2P', monospace !important;
            font-size: 0.9rem !important;
            font-weight: 700 !important;
            background: rgba(0,0,0,0.7) !important;
            border-radius: 5px !important;
            padding: 0.4rem !important;
        }

        .ui {
            margin: 1.5rem 0;
        }

        .ui button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 0.5rem;
        }

        .ui button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        #hallOfFameBtn {
            background: #FFD700;
            color: #000;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }
        
        #hallOfFameBtn:hover {
            background: #FFA500;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
        }
        
        #completionistBtn {
            background: #C0392B;
            color: #FFF;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(192, 57, 43, 0.3);
        }
        
        #completionistBtn:hover {
            background: #A93226;
            box-shadow: 0 6px 20px rgba(192, 57, 43, 0.5);
        }
        
        @keyframes pulse-gold {
            0% { box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(255, 215, 0, 0.6); }
            100% { box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3); }
        }
        
        .game-not-started #hallOfFameBtn {
            animation: pulse-gold 2s infinite;
        }

        .ui button:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .controls {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-top: 1.5rem;
        }

        .controls p {
            margin: 0.5rem 0;
        }

        #gameCanvas {
            border: 2px solid var(--border-medium);
            border-radius: var(--radius-lg);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            max-width: 100%;
            height: auto;
        }
        
        /* Error message styles */
        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #dc2626;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
            border: 2px solid #b91c1c;
            max-width: 90%;
            text-align: center;
            animation: errorFadeIn 0.3s ease-out;
        }
        
        @keyframes errorFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        /* Fullscreen styles */
        #gameCanvas:fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            border: none !important;
            border-radius: 0 !important;
            background: black;
        }
        
        .game-layout:fullscreen .side-panel,
        .game-layout:has(#gameCanvas:fullscreen) .side-panel {
            position: fixed !important;
            top: 20px !important;
            z-index: 999999 !important;
            width: 180px !important;
            background: rgba(0, 0, 0, 0.9) !important;
            border: 1px solid #444 !important;
            font-size: 9px !important;
            padding: 10px !important;
        }
        
        .game-layout:fullscreen .left-panel,
        .game-layout:has(#gameCanvas:fullscreen) .left-panel {
            left: 20px !important;
        }
        
        .game-layout:fullscreen .right-panel,
        .game-layout:has(#gameCanvas:fullscreen) .right-panel {
            right: 20px !important;
        }
        
        #gameCanvas:-webkit-full-screen {
            width: 100vw !important;
            height: 100vh !important;
            border: none !important;
            border-radius: 0 !important;
            background: black;
        }
        
        #gameCanvas:-moz-full-screen {
            width: 100vw !important;
            height: 100vh !important;
            border: none !important;
            border-radius: 0 !important;
            background: black;
        }
        
        #gameCanvas:-ms-fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            border: none !important;
            border-radius: 0 !important;
            background: black;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .ui {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
                text-align: center;
            }
            
            .retro-ui-element {
                font-size: 0.7rem !important;
                padding: 0.3rem !important;
            }
            
            .controls {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="navigation-header" style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-secondary); border-radius: var(--radius-md); border: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center;">
            <div>
                <a href="/" style="color: var(--primary-color); text-decoration: none; font-weight: 600;">
                    <i class="fas fa-arrow-left"></i> Back to Main Site
                </a>
            </div>
            <div style="display: flex; gap: 1rem; align-items: center;">
                <button onclick="toggleTheme()" style="background: var(--bg-tertiary); border: 1px solid var(--border-light); color: var(--text-primary); padding: 0.5rem; border-radius: var(--radius-md); cursor: pointer;">
                    <i class="fas fa-moon" id="theme-icon"></i>
                </button>
                <span style="font-size: 0.875rem; color: var(--text-muted);">Standalone Mode</span>
            </div>
        </div>
        
        
        <div class="ui" style="margin-bottom: 1.5rem; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1rem; text-align: center;">
            <div class="retro-ui-element" style="color: #00FFFF; text-shadow: 0 0 10px #00FFFF, 0 0 20px #00FFFF; border: 2px solid #00FFFF;">SCORE: <span id="score">0</span></div>
            <div class="retro-ui-element" style="color: #FF00FF; text-shadow: 0 0 10px #FF00FF, 0 0 20px #FF00FF; border: 2px solid #FF00FF;">LIVES: <span id="lives">3</span></div>
            <div class="retro-ui-element" style="color: #FFD700; text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700; border: 2px solid #FFD700;">LEVEL: <span id="level">1</span></div>
            <div class="retro-ui-element" style="color: #00FF7F; text-shadow: 0 0 10px #00FF7F, 0 0 20px #00FF7F; border: 2px solid #00FF7F;">BEST: <span id="personalBest">0</span></div>
        </div>
        
        <div style="text-align: center; margin-bottom: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.8); border-radius: 10px; border: 3px solid #FFD700; box-shadow: 0 0 20px #FFD700;">
            <div style="color: #FFD700; font-weight: 700; font-size: 0.8rem; font-family: 'Press Start 2P', monospace; text-shadow: 0 0 15px #FFD700;">🏆 CHAMPION 🏆</div>
            <div style="color: #FFFFFF; font-weight: 700; font-size: 0.9rem; margin-top: 0.25rem; font-family: 'Press Start 2P', monospace; text-shadow: 0 0 10px #FFFFFF;">
                <span id="allTimeScore">0</span> - <span id="allTimePlayer">Nobody</span>
            </div>
        </div>
        
        <div class="game-layout">
            <div class="side-panel left-panel" id="leftPanel">
                <div class="ui-stat level" id="levelDisplay">Level: 1/100</div>
                <div class="ui-stat level" id="levelNameDisplay">Starting Level</div>
                <div class="ui-stat lives" id="livesDisplay">♥ Lives: 3</div>
                <div class="ui-stat banking" id="bankingDisplay" style="display: none;">
                    <div id="bankedAmount">💰 Banked: 0</div>
                    <div id="interestAmount">📈 Interest: +0</div>
                    <div id="bankingControls">B=Bank V=Withdraw</div>
                </div>
                <div class="ui-stat" id="eventDisplay" style="display: none;"></div>
                <div class="ui-stat" id="mysticalDisplay" style="display: none;">
                    <div id="mysticalEnergyBar" style="background: #4B0082; height: 12px; border: 1px solid #9932CC; margin: 2px 0; position: relative;">
                        <div id="mysticalEnergyFill" style="background: #9932CC; height: 100%; width: 100%; transition: width 0.3s;"></div>
                    </div>
                    <div id="mysticalEnergyText" style="font-size: 8px;">Energy: 100/100</div>
                    <div id="mysticalElementText" style="font-size: 8px;"></div>
                </div>
                <div class="ui-stat" id="worldDisplay" style="display: none;">
                    <div id="worldName" style="font-size: 9px; font-weight: bold;"></div>
                    <div id="worldZone" style="font-size: 8px;"></div>
                    <div id="worldProgress" style="font-size: 8px;"></div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="gameCanvas" width="800" height="600" style="background-color: #000;" tabindex="0"></canvas>
            </div>
            
            <div class="side-panel right-panel" id="rightPanel">
                <div class="ui-stat score" id="scoreDisplay">Score: 0</div>
                <div class="ui-stat powerup" id="comboDisplay" style="display: none;"></div>
                <div class="ui-stat powerup" id="powerupDisplay" style="display: none;"></div>
                <div class="ui-stat" id="bossDisplay" style="display: none;"></div>
            </div>
        </div>
        
        <!-- cr0soft Splash Screen -->
        <div id="splashScreen" style="
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        ">
            <!-- Animated Crow SVG -->
            <svg width="200" height="200" viewBox="0 0 120 120" style="margin-bottom: 30px;">
                <defs>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                    <filter id="brightGlow">
                        <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                
                <!-- Crow Body with better contrast -->
                <ellipse cx="60" cy="70" rx="25" ry="15" fill="#2a2a2a" stroke="#555555" stroke-width="1" filter="url(#glow)">
                    <animateTransform 
                        attributeName="transform" 
                        type="rotate" 
                        values="0 60 70;-2 60 70;0 60 70;2 60 70;0 60 70" 
                        dur="2s" 
                        repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Crow Head with better contrast -->
                <circle cx="60" cy="45" r="18" fill="#2a2a2a" stroke="#555555" stroke-width="1" filter="url(#glow)">
                    <animateTransform 
                        attributeName="transform" 
                        type="rotate" 
                        values="0 60 45;-1 60 45;0 60 45;1 60 45;0 60 45" 
                        dur="2s" 
                        repeatCount="indefinite"/>
                </circle>
                
                <!-- Crow Beak - brighter and larger -->
                <path d="M42 42 L32 40 L42 38 Z" fill="#ffaa00" stroke="#ffcc33" stroke-width="0.5" filter="url(#brightGlow)">
                    <animateTransform 
                        attributeName="transform" 
                        type="rotate" 
                        values="0 38 40;-1 38 40;0 38 40;1 38 40;0 38 40" 
                        dur="2s" 
                        repeatCount="indefinite"/>
                </path>
                
                <!-- Crow Eyes - brighter and larger -->
                <circle cx="55" cy="40" r="4" fill="#ff3333" stroke="#ff6666" stroke-width="0.5" filter="url(#brightGlow)">
                    <animate attributeName="opacity" values="1;0.3;1;0.3;1" dur="1.5s" repeatCount="indefinite"/>
                </circle>
                <circle cx="65" cy="40" r="4" fill="#ff3333" stroke="#ff6666" stroke-width="0.5" filter="url(#brightGlow)">
                    <animate attributeName="opacity" values="1;0.3;1;0.3;1" dur="1.5s" repeatCount="indefinite"/>
                </circle>
                
                <!-- Wings with better visibility -->
                <ellipse cx="45" cy="65" rx="12" ry="8" fill="#333333" stroke="#666666" stroke-width="1" filter="url(#glow)" transform="rotate(-20 45 65)">
                    <animateTransform 
                        attributeName="transform" 
                        type="rotate" 
                        values="-20 45 65;-30 45 65;-20 45 65;-10 45 65;-20 45 65" 
                        dur="1s" 
                        repeatCount="indefinite"/>
                </ellipse>
                <ellipse cx="75" cy="65" rx="12" ry="8" fill="#333333" stroke="#666666" stroke-width="1" filter="url(#glow)" transform="rotate(20 75 65)">
                    <animateTransform 
                        attributeName="transform" 
                        type="rotate" 
                        values="20 75 65;30 75 65;20 75 65;10 75 65;20 75 65" 
                        dur="1s" 
                        repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Tail with better visibility -->
                <ellipse cx="60" cy="90" rx="8" ry="12" fill="#333333" stroke="#666666" stroke-width="1" filter="url(#glow)">
                    <animateTransform 
                        attributeName="transform" 
                        type="rotate" 
                        values="0 60 90;-3 60 90;0 60 90;3 60 90;0 60 90" 
                        dur="2.5s" 
                        repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Subtle floating animation for entire crow -->
                <g>
                    <animateTransform 
                        attributeName="transform" 
                        type="translate" 
                        values="0 0;0 -3;0 0;0 3;0 0" 
                        dur="3s" 
                        repeatCount="indefinite"/>
                </g>
            </svg>
            
            <!-- cr0soft Branding -->
            <div style="
                font-family: 'Press Start 2P', monospace;
                font-size: 36px;
                color: #ffffff;
                text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
                letter-spacing: 4px;
                margin-bottom: 10px;
                animation: cr0softGlow 2s ease-in-out infinite alternate;
            ">cr0soft</div>
            
            <!-- Subtitle -->
            <div style="
                font-family: 'Press Start 2P', monospace;
                font-size: 12px;
                color: #888888;
                letter-spacing: 2px;
                animation: subtitleFade 1s ease-in 1.5s both;
            ">game development</div>
            
            <!-- Loading dots -->
            <div style="
                margin-top: 40px;
                font-family: 'Press Start 2P', monospace;
                font-size: 16px;
                color: #00ffff;
                animation: loadingDots 1.5s infinite;
            ">loading</div>
        </div>
        
        <style>
            @keyframes cr0softGlow {
                0% { 
                    text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
                    transform: scale(1);
                }
                100% { 
                    text-shadow: 0 0 30px #0099ff, 0 0 60px #0099ff, 0 0 90px #0099ff;
                    transform: scale(1.02);
                }
            }
            
            @keyframes subtitleFade {
                0% { opacity: 0; transform: translateY(10px); }
                100% { opacity: 1; transform: translateY(0); }
            }
            
            @keyframes loadingDots {
                0%, 20% { content: "loading"; }
                40% { content: "loading."; }
                60% { content: "loading.."; }
                80%, 100% { content: "loading..."; }
            }
            
            @keyframes loadingDots::after {
                0%, 20% { content: ""; }
                40% { content: "."; }
                60% { content: ".."; }
                80%, 100% { content: "..."; }
            }
        </style>
        
        <div class="ui">
            <button id="pauseBtn" onclick="togglePause()" disabled>Pause</button>
            <button id="resetBtn" onclick="resetGame()">Reset</button>
            <button id="hallOfFameBtn" onclick="console.log('Hall of Fame button clicked'); showRegularHallOfFame()">🏆 Hall of Fame</button>
            <button id="completionistBtn" onclick="showCompletionistHallOfFame()">🏅 Completionists</button>
            <button id="fullscreenBtn">📺 Fullscreen</button>
        </div>
        
        <div class="controls">
            <p>🎮 <strong>Controls:</strong> Arrow Keys, WASD, Mouse, or Touch to move paddle</p>
            <p>⚡ <strong>Actions:</strong> SPACE or LEFT CLICK to launch ball / fire laser • S to toggle sound</p>
            <p>⏸️ <strong>Pause:</strong> Press P or ESC to pause during game</p>
            <p>🔥 <strong>Power-ups:</strong> Catch falling power-ups for special abilities!</p>
            <p>🌟 <strong>Mystical Powers:</strong> Press M to open mystical menu • Earn energy by destroying blocks • Unlock elemental balls and enchantments</p>
            <p>💰 <strong>Banking (Level 3+):</strong> Press B to bank your score safely • Press V to withdraw banked score + interest</p>
            <p>⚠️ <strong>Risk/Reward:</strong> Unbanked scores are lost on death! Banking earns 5% interest per level but has 25% death penalty</p>
            <p>🎯 <strong>Events:</strong> Random temporary events start at Level 5+ with powerful effects and rewards</p>
            <p>🛒 <strong>Upgrades:</strong> Press U to open upgrade shop • Earn points from achievements and performance</p>
            <p>🏆 <strong>Achievements:</strong> Press J to view achievement gallery • Track your progress across all 30 achievements</p>
        </div>
    </div>

    <!-- Include secure game API -->
    <script src="js/secure-game.min.js"></script>
    
    <!-- Include Level Manager for modular level loading -->
    <script src="js/modules/levels/LevelManager.js"></script>
    
    <script>
        // Basic security variables for legitimate gameplay
        let score = 0;
        let lives = 3;
        let level = 1;
        const totalLevels = 100;

        // Load breakout scores and initialization
        let hallOfFameLoaded = false;

        function loadBreakoutScores() {
            if (hallOfFameLoaded) return;
            
            fetch('scores_api.php?limit=10')
                .then(response => response.json())
                .then(data => {
                    if (data && Array.isArray(data) && data.length > 0) {
                        const topScore = data[0];
                        if (topScore.score && topScore.player_name) {
                            document.getElementById('allTimeScore').textContent = topScore.score.toLocaleString();
                            document.getElementById('allTimePlayer').textContent = topScore.player_name;
                            hallOfFameLoaded = true;
                        }
                    }
                })
                .catch(error => {
                    console.log('Could not load breakout scores:', error);
                });
        }

        // Load scores on page load
        loadBreakoutScores();
        
        // Breakout by cr0sis - Game Logic
        let canvas, ctx, scoreElement, livesElement, pauseBtn, resetBtn, levelElement, personalBestElement, allTimeScoreElement, allTimePlayerElement;
        
        function updateScore(increment) {
            // Apply temporary event score multiplier
            const eventMultiplier = getActiveEventMultiplier();
            const finalIncrement = Math.floor(increment * eventMultiplier);
            
            score += finalIncrement;
            // Cap score at 999 trillion
            if (score > 999999999999999) {
                score = 999999999999999; // 999 trillion max score
            }
            
            // Show event bonus feedback if multiplier is active
            if (eventMultiplier > 1.0 && temporaryEvents.active && temporaryEvents.active.data) {
                gameState.feedbackMessages.push({
                    text: `${temporaryEvents.active.data.icon || '⭐'} +${finalIncrement} (${eventMultiplier}x)`,
                    x: canvas.width / 2,
                    y: 150,
                    life: 60,
                    color: temporaryEvents.active.data.color || '#FFFFFF',
                    fontSize: 14,
                    outline: true
                });
                
                // Track golden hour scoring for achievements
                trackGoldenHourScore(finalIncrement);
            }
            
            // Phase 3: Check score-based achievements
            checkAchievements();
            
            return score;
        }
        
        async function startGameSession(playerName = 'Anonymous') {
            try {
                console.log('Attempting to start game session for:', playerName);
                const response = await fetch('game_session.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'start_session',
                        player_name: playerName
                    })
                });
                
                // Session response processed
                
                if (response.ok) {
                    const data = await response.json();
                    // Session data validated
                    
                    if (data.session_id && data.token) {
                        gameSessionId = data.session_id;
                        gameSessionToken = data.token;
                        console.log('Game session started with cryptographic protection');
                        return { success: true, session_id: gameSessionId, token: gameSessionToken };
                    } else {
                        console.error('Invalid session data received:', data);
                        return { success: false, error: 'Invalid session data received' };
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Failed to start game session:', response.status, errorText);
                    
                    // Check for IP blocking
                    if (response.status === 403 && errorText.includes('IP blocked')) {
                        return { 
                            success: false, 
                            error: 'IP_BLOCKED',
                            message: 'Your IP address is temporarily blocked. Please contact support.'
                        };
                    }
                    
                    return { success: false, error: `HTTP ${response.status}: ${errorText}` };
                }
            } catch (error) {
                console.error('Error starting game session:', error);
                return { success: false, error: error.message };
            }
        }
        
        async function updateGameSession() {
            if (!gameSessionId) return;
            
            try {
                await fetch('game_session.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'update_session',
                        session_id: gameSessionId,
                        level: level,
                        blocks_destroyed: sessionStats.blocksDestroyed,
                        lives_lost: sessionStats.livesLost,
                        powerups_collected: sessionStats.powerupsCollected
                    })
                });
            } catch (error) {
                console.error('Error updating game session:', error);
            }
        }
        let gameRunning = false;
        let gamePaused = false;
        let gameStarted = false;
        let pointerLocked = false;
        let gameOverlay = { active: false }; // Tracks current overlay state
        // Game score variable
        let gameSessionId = null;
        let gameSessionToken = null;
        let sessionStats = {
            blocksDestroyed: 0,
            livesLost: 0,  
            powerupsCollected: 0
        };

        // Phase 3: Temporary Event System
        let temporaryEvents = {
            active: null,
            timeRemaining: 0,
            lastEventTime: 0,
            eventCooldown: 60000, // 1 minute cooldown between events
            
            types: {
                golden_hour: {
                    name: "Golden Hour",
                    duration: 60000, // 60 seconds
                    description: "2x Score Multiplier",
                    color: "#FFD700",
                    icon: "⭐",
                    scoreMultiplier: 2.0,
                    rarity: 0.15 // 15% chance
                },
                speed_demon: {
                    name: "Speed Demon", 
                    duration: 45000, // 45 seconds
                    description: "50% Faster Ball Speed, 3x Score",
                    color: "#FF4500",
                    icon: "⚡",
                    speedMultiplier: 1.5,
                    scoreMultiplier: 3.0,
                    rarity: 0.12 // 12% chance
                },
                brick_storm: {
                    name: "Brick Storm",
                    duration: 30000, // 30 seconds
                    description: "Random Brick Spawning",
                    color: "#8B4513",
                    icon: "🌪",
                    spawnRate: 0.02, // 2% chance per frame to spawn brick
                    rarity: 0.10 // 10% chance
                },
                mega_combo: {
                    name: "Mega Combo",
                    duration: 20000, // 20 seconds
                    description: "All Combo Pickups = 10x",
                    color: "#FF1493",
                    icon: "💥",
                    comboOverride: 10.0,
                    rarity: 0.08 // 8% chance
                },
                shield_overcharge: {
                    name: "Shield Overcharge",
                    duration: 15000, // 15 seconds
                    description: "All Shields Invulnerable",
                    color: "#00CED1",
                    icon: "🛡",
                    shieldInvulnerable: true,
                    rarity: 0.06 // 6% chance
                },
                magnetic_chaos: {
                    name: "Magnetic Chaos",
                    duration: 25000, // 25 seconds
                    description: "Magnetic Fields Reverse Every 10s",
                    color: "#9400D3",
                    icon: "🌀",
                    reverseInterval: 10000, // 10 seconds
                    nextReverse: 0,
                    rarity: 0.05 // 5% chance
                }
            }
        };

        // Score banking system
        let scoreBanking = {
            bankedScore: 0,
            currentSessionScore: 0,
            bankingEnabled: false,
            interestRate: 0.05, // 5% per level
            lastBankLevel: 0
        };

        // Difficulty adjustment system
        let difficultyAdjustment = {
            enabled: true,
            baseSpeed: 4,
            currentModifier: 1.0,
            playerAccuracy: 0.0,
            totalHits: 0,
            successfulHits: 0,
            survivalTime: 0,
            lastAdjustment: 0
        };
        
        // Login detection - Get user from parent window if in iframe
        let currentUser = null;
        
        // Function to generate consistent color for a username
        function getUserColor(username) {
            if (!username || username === 'Anonymous') {
                return '#FFFFFF'; // White for anonymous users
            }
            
            // Check if this is a registered user (you can enhance this check)
            const isRegistered = currentUser && currentUser.username === username;
            if (!isRegistered && username !== 'Anonymous') {
                return '#FFFFFF'; // White for unregistered users who typed a name
            }
            
            // For registered users, check if they have a chosen color in currentUser
            if (isRegistered && currentUser.color) {
                return currentUser.color; // Use the color from database/user preferences
            }
            
            // Fallback: Generate random but consistent color for registered users without a stored color
            let hash = 0;
            for (let i = 0; i < username.length; i++) {
                hash = username.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Generate HSL color with good saturation and lightness
            const hue = Math.abs(hash) % 360;
            const saturation = 70 + (Math.abs(hash >> 8) % 30); // 70-100%
            const lightness = 50 + (Math.abs(hash >> 16) % 20); // 50-70%
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        // Function to fetch user's color from the API for registered users
        async function fetchUserColor(username) {
            if (!username || !currentUser || currentUser.username !== username) {
                return null;
            }
            
            try {
                const response = await fetch('user_color_api.php?action=get_current');
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.color) {
                        // Update currentUser object with the fetched color
                        currentUser.color = data.color;
                        return data.color;
                    }
                }
            } catch (error) {
                console.warn('Failed to fetch user color:', error);
            }
            
            return null;
        }
        
        async function updateCurrentUser(forceDirectCheck = false) {
            try {
                if (window.parent && window.parent !== window && !forceDirectCheck) {
                    currentUser = window.parent.currentUser;
                    console.log('Updated currentUser from parent:', currentUser);
                    
                    // If user is logged in, fetch their color preference
                    if (currentUser && currentUser.username) {
                        const userColor = await fetchUserColor(currentUser.username);
                        if (userColor) {
                            currentUser.color = userColor;
                            console.log('Updated currentUser from parent with color:', userColor);
                        }
                    }
                    
                    // If parent still undefined, try direct API as fallback
                    if (!currentUser) {
                        console.log('Parent currentUser undefined, falling back to direct API');
                        forceDirectCheck = true;
                    }
                }
                
                if (forceDirectCheck || window.parent === window) {
                    // Direct access or forced check - use auth API
                    console.log('Direct access detected - checking auth API');
                    try {
                        const response = await fetch('auth.php', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'check_auth' })
                        });
                        const data = await response.json();
                        console.log('Direct access - full API response:', data);
                        currentUser = data.logged_in ? data.user : null;
                        console.log('Direct access - auth API result:', currentUser);
                        
                        // If user is logged in, fetch their color preference
                        if (currentUser && currentUser.username) {
                            const userColor = await fetchUserColor(currentUser.username);
                            if (userColor) {
                                currentUser.color = userColor;
                                console.log('Updated currentUser with color:', userColor);
                            }
                        }
                    } catch (authError) {
                        console.log('Auth API check failed:', authError.message);
                        currentUser = null;
                    }
                }
            } catch (error) {
                console.log('Could not access parent user data (cross-origin or no parent):', error.message);
            }
        }
        
        // Debug function to understand context
        function debugContext() {
            console.log('=== BREAKOUT CONTEXT DEBUG ===');
            console.log('URL:', window.location.href);
            console.log('Is iframe:', window.parent !== window);
            console.log('Parent URL:', window.parent !== window ? 'hidden (cross-origin)' : 'same window');
            console.log('Referrer:', document.referrer);
            
            if (window.parent !== window) {
                try {
                    console.log('Parent currentUser:', window.parent.currentUser);
                    console.log('Parent has checkAuthStatus:', typeof window.parent.checkAuthStatus);
                    console.log('Parent document title:', window.parent.document.title);
                } catch (e) {
                    console.log('Cannot access parent data:', e.message);
                }
            }
            console.log('===============================');
        }
        
        // Initial user detection
        (async () => {
            debugContext();
            await updateCurrentUser();
        })();
        
        // Enhanced parent user detection with multiple strategies
        if (window.parent && window.parent !== window) {
            let checkCount = 0;
            const userCheckInterval = setInterval(async () => {
                checkCount++;
                try {
                    // Strategy 1: Check parent.currentUser
                    let newUser = window.parent.currentUser;
                    
                    // Strategy 2: If undefined, try calling parent's checkAuthStatus if available
                    if (!newUser && typeof window.parent.checkAuthStatus === 'function') {
                        console.log('Parent currentUser undefined, triggering parent auth check');
                        await window.parent.checkAuthStatus();
                        // Wait a moment for the parent to update currentUser
                        await new Promise(resolve => setTimeout(resolve, 500));
                        newUser = window.parent.currentUser;
                        console.log('After parent auth check, currentUser:', newUser);
                    }
                    
                    // Strategy 3: Look for authentication data in parent DOM
                    if (!newUser) {
                        try {
                            const authData = window.parent.document.querySelector('[data-user-info]');
                            if (authData) {
                                newUser = JSON.parse(authData.getAttribute('data-user-info'));
                                console.log('Found user data in parent DOM:', newUser);
                            }
                        } catch (domError) {
                            // Parent DOM not accessible
                        }
                    }
                    
                    // Strategy 4: Direct auth check if still no user and we haven't tried recently
                    if (!newUser && checkCount <= 3) { // Reduced attempts to avoid spam
                        console.log('No user from parent, trying direct auth check (attempt ' + checkCount + ')');
                        // Force direct auth API call, bypassing parent check
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout
                            
                            const response = await fetch('auth.php', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ action: 'check_auth' }),
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            if (response.ok) {
                                const data = await response.json();
                                newUser = data.logged_in ? data.user : null;
                                console.log('Direct auth API result:', newUser);
                                
                                // Cache successful result to avoid repeated calls
                                if (newUser) {
                                    currentUser = newUser;
                                    console.log('Cached successful auth result:', currentUser);
                                }
                            }
                        } catch (authError) {
                            if (authError.name === 'AbortError') {
                                console.log('Direct auth API timed out after 3 seconds');
                            } else {
                                console.log('Direct auth API failed:', authError.message);
                            }
                        }
                    }
                    
                    if (JSON.stringify(newUser) !== JSON.stringify(currentUser)) {
                        currentUser = newUser;
                        console.log('User status changed (check #' + checkCount + '):', currentUser);
                    }
                    
                    // If we found a user, we can check less frequently
                    if (currentUser && currentUser.username) {
                        console.log('Authentication successful, reducing poll frequency for user:', currentUser.username);
                        clearInterval(userCheckInterval);
                        // Set up less frequent checks
                        setInterval(() => {
                            const latestUser = window.parent.currentUser;
                            // Only update if parent has a valid user (don't overwrite with undefined)
                            if (latestUser && JSON.stringify(latestUser) !== JSON.stringify(currentUser)) {
                                currentUser = latestUser;
                                console.log('User status updated from parent:', currentUser);
                            }
                        }, 10000);
                    }
                } catch (error) {
                    // Cross-origin or parent not accessible - try direct auth check
                    if (checkCount % 3 === 0) { // Only every 3rd check to avoid spam
                        await updateCurrentUser();
                    }
                }
            }, 2000); // Check every 2 seconds to reduce load
            
            // Stop checking after 30 seconds
            setTimeout(() => clearInterval(userCheckInterval), 30000);
        }
        
        // Legacy compatibility variables (non-functional)
        let __debugMode = false;
        let __unlimitedLives = false;
        let __scoreMultiplier = 1;
        let __adminAccess = false;
        let cheatModeEnabled = false;
        let godMode = false;
        
        // Decoy functions that appear to work but are disabled
        window.enableCheatMode = function() {
            console.log("Feature disabled in secure mode");
            return "Access denied";
        };
        
        window.setScore = function(newScore) {
            console.log("Direct score modification blocked");
            return "Operation not permitted";
        };
        
        window.unlimitedLives = function() {
            console.log("Lives modification disabled");
            return "Feature unavailable";
        };
        let originalScore = 0;
        setInterval(() => {
            if (__debugMode || __unlimitedLives || __scoreMultiplier !== 1 || __adminAccess || cheatModeEnabled || godMode) {
                fetch('/report_tampering.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'client_tampering',
                        session_id: gameSessionId,
                        variables: {
                            debugMode: __debugMode,
                            unlimitedLives: __unlimitedLives,
                            scoreMultiplier: __scoreMultiplier,
                            adminAccess: __adminAccess,
                            cheatMode: cheatModeEnabled,
                            godMode: godMode
                        }
                    })
                }).catch(() => {}); // Silent fail
            }
            
            // Check for rapid score changes
            if (Math.abs(score - originalScore) > 100000) { // Allow for high combo scores
                fetch('/report_tampering.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'rapid_score_change',
                        session_id: gameSessionId,
                        old_score: originalScore,
                        new_score: score,
                        difference: score - originalScore
                    })
                }).catch(() => {});
            }
            originalScore = score;
        }, 1000);
        // Game lives and level variables
        let animationId;
        let soundEnabled = true;
        
        // Frame rate independent timing
        let lastFrameTime = 0;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS; // 16.67ms for 60 FPS
        let SPEED_MULTIPLIER = 144 / 60; // 2.4x speed to match 144 FPS feel - can be modified by config
        let playerName = '';
        let scoreSubmitted = false;
        
        // Game configuration from admin panel
        let gameConfig = {
            ball_speed: 1,
            paddle_speed: 19.2,
            mouse_sensitivity: 2.5,
            gravity_effect: 0,
            bounce_elasticity: 1,
            difficulty_curve: 1,
            starting_lives: 3,
            extra_life_frequency: 0.06,
            blocks_per_level: 1,
            powerup_frequency: 0.15,
            powerup_duration: 10,
            laser_power: 1,
            multiball_count: 3,
            sticky_strength: 1,
            paddle_size_min: 0.5,
            paddle_size_max: 2,
            paddle_size_steps: 4,
            turret_position: 0.25,
            score_multiplier: 1,
            combo_bonus: 1,
            level_bonus: 1000,
            particle_effects: 1,
            screen_shake: 10,
            trail_length: 10,
            sound_volume: 0.7,
            enable_boss_levels: true,
            enable_mystical_powers: true,
            enable_world_progression: true,
            enable_achievements: true,
            config_loaded: false
        };
        
        // Load game configuration if requested
        async function loadGameConfig() {
            const urlParams = new URLSearchParams(window.location.search);
            const configType = urlParams.get('config');
            
            if (configType === 'live' || configType === 'realistic') {
                try {
                    // Use appropriate API endpoint based on config type
                    const apiEndpoint = configType === 'realistic' ? 'game_settings_api_realistic.php' : 'game_settings_api.php';
                    const response = await fetch(apiEndpoint + '?t=' + Date.now()); // Cache bust
                    const config = await response.json();
                    if (config.config_loaded) {
                        gameConfig = { ...gameConfig, ...config };
                        console.log(`Game configuration loaded from ${configType} admin panel:`, gameConfig);
                        applyGameConfig();
                    }
                } catch (error) {
                    console.error('Failed to load game configuration:', error);
                }
            }
        }
        
        // Listen for config updates from admin panel
        function setupConfigReloadListener() {
            const urlParams = new URLSearchParams(window.location.search);
            const configType = urlParams.get('config');
            
            if (configType === 'live' || configType === 'realistic') {
                // Listen for messages from admin panel
                window.addEventListener('message', async (event) => {
                    if (event.data && event.data.type === 'reloadConfig') {
                        console.log('Reloading configuration from admin panel...');
                        await loadGameConfig();
                        showConfigReloadNotification();
                    }
                });
                
                // Store the last saved timestamp to avoid constant updates
                let lastKnownConfigTimestamp = null;
                
                // Poll for changes every 30 seconds as backup (less frequent)
                setInterval(async () => {
                    try {
                        const apiEndpoint = configType === 'realistic' ? 'game_settings_api_realistic.php' : 'game_settings_api.php';
                        const response = await fetch(apiEndpoint + '?t=' + Date.now());
                        const config = await response.json();
                        
                        // Only update if we have a real change (not just timestamp differences)
                        if (config.config_loaded) {
                            // Create a comparison object without timestamp
                            const currentConfigNoTimestamp = { ...gameConfig };
                            delete currentConfigNoTimestamp.timestamp;
                            const newConfigNoTimestamp = { ...config };
                            delete newConfigNoTimestamp.timestamp;
                            
                            // Compare actual config values, not timestamps
                            const configChanged = JSON.stringify(currentConfigNoTimestamp) !== JSON.stringify(newConfigNoTimestamp);
                            
                            if (configChanged) {
                                console.log('Configuration actually changed, reloading...');
                                gameConfig = { ...gameConfig, ...config };
                                applyGameConfig();
                                showConfigReloadNotification();
                            }
                        }
                    } catch (error) {
                        console.error('Failed to check for config updates:', error);
                    }
                }, 30000); // Increased from 10 to 30 seconds
            }
        }
        
        // Show notification when config is reloaded
        function showConfigReloadNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                font-family: Arial, sans-serif;
            `;
            notification.textContent = '⚙️ Game settings updated!';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Apply configuration to game variables
        function applyGameConfig() {
            console.log('Applying game configuration:', gameConfig);
            
            // Apply speed settings
            SPEED_MULTIPLIER = (144 / 60) * (gameConfig.ball_speed || 1);
            
            // Apply to existing game objects if initialized
            if (typeof paddle !== 'undefined') {
                paddle.speed = gameConfig.paddle_speed || 19.2;
            }
            
            if (typeof ballTemplate !== 'undefined') {
                // Reset to base speed first, then apply multiplier
                ballTemplate.speed = 5 * (gameConfig.ball_speed || 1);
            }
            
            // Update lives (only if not in active game)
            if (!gameRunning || !gameStarted) {
                lives = gameConfig.starting_lives || 3;
            }
            
            // Update powerup chances
            if (typeof powerUpTypes !== 'undefined') {
                // Reset to base chances first
                const baseChances = {
                    'multiball': 0.10,
                    'bigpaddle': 0.14,
                    'laser': 0.10,
                    'sticky': 0.10,
                    'extralife': 0.06,
                    'slowball': 0.10,
                    'megaball': 0.07,
                    'rocket': 0.09,
                    'smallpaddle': 0.07,
                    'speedball': 0.08
                };
                
                powerUpTypes.forEach(powerUp => {
                    const baseChance = baseChances[powerUp.type] || 0.05;
                    if (powerUp.type === 'extralife') {
                        powerUp.chance = (gameConfig.extra_life_chance || 3) / 10 * 0.2; // Map to realistic chance
                    } else {
                        powerUp.chance = baseChance * ((gameConfig.powerup_drop_chance || 8) / 10);
                    }
                });
            }
            
            // Apply sound volume
            if (gameConfig.sound_volume !== undefined) {
                // This would need to be applied to audio elements when they play
                console.log('Sound volume set to:', gameConfig.sound_volume);
            }
            
            // Apply visual settings
            if (gameConfig.particle_density !== undefined) {
                console.log('Particle density set to:', gameConfig.particle_density);
            }
            
            // Apply other settings as needed
            console.log('Configuration applied successfully');
        }
        let scoreSubmissionInProgress = false; // Prevent simultaneous submissions
        let completionistRecorded = false; // Prevent duplicate completionist records
        let gameOverData = null; // Stores game data for name override screen
        let legitGameCompleted = false; // Tracks if player completed a legitimate game

        // Utility function for text wrapping
        function wrapText(ctx, text, maxWidth) {
            if (!text) return [];
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (let word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            return lines;
        }

        // Game state
        const gameState = {
            balls: [],
            powerUps: [],
            particles: [],
            screenShake: 0,
            multiplier: 1,
            combo: 0,
            feedbackMessages: [],
            scorePopups: [],
            // New combo multiplier system
            tempComboMultiplier: 1,
            tempComboTimer: 0,
            tempComboDuration: 0,
            tempComboStartTime: 0
        };

        // Phase 3: Event Management Functions
        function checkAndTriggerEvent() {
            const now = Date.now();
            
            // Don't trigger events if one is already active or still in cooldown
            if (temporaryEvents.active || 
                (now - temporaryEvents.lastEventTime) < temporaryEvents.eventCooldown) {
                return;
            }
            
            // Only trigger events after level 5 and during active gameplay
            if (level < 5 || !gameRunning || gamePaused) {
                return;
            }
            
            // Random chance to trigger event (5% per check, roughly every 3-4 seconds)
            if (Math.random() < 0.05) {
                triggerRandomEvent();
            }
        }
        
        function triggerRandomEvent() {
            const eventTypes = Object.keys(temporaryEvents.types);
            const weightedEvents = [];
            
            // Create weighted array based on rarity
            eventTypes.forEach(eventType => {
                const event = temporaryEvents.types[eventType];
                const weight = Math.floor(event.rarity * 100);
                for (let i = 0; i < weight; i++) {
                    weightedEvents.push(eventType);
                }
            });
            
            if (weightedEvents.length === 0) return;
            
            if (weightedEvents.length === 0) return;
            const selectedEventType = weightedEvents[Math.floor(Math.random() * weightedEvents.length)];
            startTemporaryEvent(selectedEventType);
        }
        
        function startTemporaryEvent(eventType) {
            if (!temporaryEvents.types[eventType]) return;
            
            const event = temporaryEvents.types[eventType];
            temporaryEvents.active = {
                type: eventType,
                data: { ...event },
                startTime: Date.now(),
                timeRemaining: event.duration
            };
            
            // Special initialization for specific events
            if (eventType === 'magnetic_chaos') {
                temporaryEvents.active.data.nextReverse = Date.now() + event.reverseInterval;
            }
            
            // Visual feedback
            createEventNotification(`${event.icon} ${event.name} activated! ${event.description}`);
            
            // Log event start
            console.log(`Event activated: ${event.name} for ${event.duration}ms`);
        }
        
        function updateTemporaryEvents(deltaTime) {
            if (!temporaryEvents.active || !temporaryEvents.active.data) return;
            
            const now = Date.now();
            temporaryEvents.active.timeRemaining -= deltaTime;
            
            // Handle magnetic chaos field reversal
            if (temporaryEvents.active.type === 'magnetic_chaos' && 
                temporaryEvents.active.data.nextReverse && 
                now >= temporaryEvents.active.data.nextReverse) {
                reverseMagneticFields();
                temporaryEvents.active.data.nextReverse = now + (temporaryEvents.active.data.reverseInterval || 10000);
            }
            
            // Handle brick storm spawning
            if (temporaryEvents.active.type === 'brick_storm' && 
                temporaryEvents.active.data.spawnRate &&
                Math.random() < temporaryEvents.active.data.spawnRate) {
                spawnRandomBrick();
            }
            
            // End event when time expires
            if (temporaryEvents.active.timeRemaining <= 0) {
                endTemporaryEvent();
            }
        }
        
        function endTemporaryEvent() {
            if (!temporaryEvents.active || !temporaryEvents.active.data) return;
            
            const eventType = temporaryEvents.active.type;
            const eventName = temporaryEvents.active.data.name || 'Unknown Event';
            
            // Phase 3: Track event survival for achievements
            trackEventSurvived(eventType);
            
            temporaryEvents.lastEventTime = Date.now();
            temporaryEvents.active = null;
            
            // Visual feedback
            createEventNotification(`${eventName} ended`);
            console.log(`Event ended: ${eventName}`);
        }
        
        function createEventNotification(message) {
            gameState.feedbackMessages.push({
                text: message,
                x: canvas.width / 2,
                y: 100,
                life: 180, // 3 seconds at 60fps
                color: (temporaryEvents.active && temporaryEvents.active.data) ? temporaryEvents.active.data.color : '#FFFFFF',
                fontSize: 16,
                outline: true
            });
        }
        
        function reverseMagneticFields() {
            blocks.forEach(block => {
                if (block.type === 'magnetic_attract' || block.type === 'magnetic_repel') {
                    // Swap polarity
                    if (block.magneticPolarity === 'attract') {
                        block.magneticPolarity = 'repel';
                        block.type = 'magnetic_repel';
                    } else {
                        block.magneticPolarity = 'attract';
                        block.type = 'magnetic_attract';
                    }
                }
            });
            
            // Visual feedback
            gameState.feedbackMessages.push({
                text: "🌀 MAGNETIC REVERSAL! 🌀",
                x: canvas.width / 2,
                y: canvas.height / 2,
                life: 120,
                color: '#9400D3',
                fontSize: 20,
                outline: true
            });
        }
        
        function spawnRandomBrick() {
            if (blocks.length >= 100) return; // Prevent too many blocks
            
            const blockWidth = 75;
            const blockHeight = 20;
            const cols = Math.floor(canvas.width / blockWidth);
            const rows = 8;
            
            // Find valid spawn location
            let attempts = 0;
            while (attempts < 10) {
                const col = Math.floor(Math.random() * cols);
                const row = Math.floor(Math.random() * rows);
                const x = col * blockWidth;
                const y = 50 + row * blockHeight;
                
                // Check if location is free
                const occupied = blocks.some(block => 
                    Math.abs(block.x - x) < blockWidth && Math.abs(block.y - y) < blockHeight
                );
                
                if (!occupied) {
                    // Create random brick type
                    const brickTypes = ['normal', 'lava', 'treasure', 'shield', 'magnetic_attract', 'magnetic_repel'];
                    const randomType = brickTypes.length > 0 ? brickTypes[Math.floor(Math.random() * brickTypes.length)] : 'normal';
                    const randomHits = Math.floor(Math.random() * 3) + 1; // 1-3 hits
                    
                    const newBlock = createBlock(col, row, randomHits, randomType);
                    blocks.push(newBlock);
                    
                    // Visual spawn effect
                    gameState.particles.push({
                        x: x + blockWidth/2,
                        y: y + blockHeight/2,
                        vx: 0,
                        vy: 0,
                        life: 30,
                        color: '#8B4513',
                        size: 3,
                        type: 'spawn'
                    });
                    break;
                }
                attempts++;
            }
        }
        
        function getActiveEventMultiplier() {
            if (!temporaryEvents.active || !temporaryEvents.active.data) return 1.0;
            
            const event = temporaryEvents.active.data;
            if (event && event.scoreMultiplier) {
                return event.scoreMultiplier;
            }
            return 1.0;
        }
        
        function getActiveSpeedMultiplier() {
            if (!temporaryEvents.active || !temporaryEvents.active.data) return 1.0;
            
            const event = temporaryEvents.active.data;
            if (event && event.speedMultiplier) {
                return event.speedMultiplier;
            }
            return 1.0;
        }
        
        function isShieldOvercharged() {
            return temporaryEvents.active && 
                   temporaryEvents.active.type === 'shield_overcharge' &&
                   temporaryEvents.active.data &&
                   temporaryEvents.active.data.shieldInvulnerable;
        }
        
        function getComboOverride() {
            if (temporaryEvents.active && 
                temporaryEvents.active.type === 'mega_combo' &&
                temporaryEvents.active.data &&
                temporaryEvents.active.data.comboOverride) {
                return temporaryEvents.active.data.comboOverride;
            }
            return null;
        }

        // Phase 3: Score Banking System Functions
        function bankCurrentScore() {
            if (level < 3) {
                gameState.feedbackMessages.push({
                    text: "Banking available from Level 3+",
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    life: 120,
                    color: '#FF6B6B',
                    fontSize: 14,
                    outline: true
                });
                return;
            }
            
            if (score <= 0) {
                gameState.feedbackMessages.push({
                    text: "No score to bank!",
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    life: 120,
                    color: '#FF6B6B',
                    fontSize: 14,
                    outline: true
                });
                return;
            }
            
            // Bank current score
            const bankAmount = score;
            scoreBanking.bankedScore += bankAmount;
            scoreBanking.lastBankLevel = level;
            score = 0; // Reset current score
            
            // Update UI elements
            if (scoreElement) scoreElement.textContent = score.toLocaleString();
            
            // Visual feedback
            gameState.feedbackMessages.push({
                text: `💰 BANKED ${bankAmount.toLocaleString()} POINTS!`,
                x: canvas.width / 2,
                y: canvas.height / 2,
                life: 180,
                color: '#32CD32',
                fontSize: 16,
                outline: true
            });
            
            // Particle effect
            createParticles(canvas.width / 2, canvas.height / 2, '#32CD32', 15);
            
            console.log(`Banked ${bankAmount} points at level ${level}. Total banked: ${scoreBanking.bankedScore}`);
        }
        
        function withdrawBankedScore() {
            if (scoreBanking.bankedScore <= 0) {
                gameState.feedbackMessages.push({
                    text: "No banked score to withdraw!",
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    life: 120,
                    color: '#FF6B6B',
                    fontSize: 14,
                    outline: true
                });
                return;
            }
            
            // Calculate interest based on levels progressed since banking
            const levelsProgressed = Math.max(0, level - scoreBanking.lastBankLevel);
            const interestRate = scoreBanking.interestRate * levelsProgressed;
            const interestEarned = Math.floor(scoreBanking.bankedScore * interestRate);
            const totalWithdrawal = scoreBanking.bankedScore + interestEarned;
            
            // Add to current score
            score += totalWithdrawal;
            
            // Update UI elements
            if (scoreElement) scoreElement.textContent = score.toLocaleString();
            
            // Visual feedback
            gameState.feedbackMessages.push({
                text: `💸 WITHDREW ${totalWithdrawal.toLocaleString()} POINTS!`,
                x: canvas.width / 2,
                y: canvas.height / 2 - 20,
                life: 180,
                color: '#FFD700',
                fontSize: 16,
                outline: true
            });
            
            if (interestEarned > 0) {
                gameState.feedbackMessages.push({
                    text: `📈 Interest: +${interestEarned.toLocaleString()}`,
                    x: canvas.width / 2,
                    y: canvas.height / 2 + 10,
                    life: 180,
                    color: '#90EE90',
                    fontSize: 12,
                    outline: true
                });
            }
            
            // Reset banked score
            scoreBanking.bankedScore = 0;
            scoreBanking.lastBankLevel = 0;
            
            // Phase 3: Track interest earned for achievements
            if (interestEarned > 0) {
                trackInterestEarned(interestEarned);
            }
            
            // Particle effect
            createParticles(canvas.width / 2, canvas.height / 2, '#FFD700', 20);
            
            console.log(`Withdrew ${totalWithdrawal} points (${interestEarned} interest) at level ${level}`);
        }

        // Phase 3: Difficulty Adjustment System Functions
        function updateDifficultyMetrics(ballHit = false) {
            if (!difficultyAdjustment.enabled) return;
            
            difficultyAdjustment.totalHits++;
            if (ballHit) {
                difficultyAdjustment.successfulHits++;
            }
            
            // Calculate accuracy
            difficultyAdjustment.playerAccuracy = difficultyAdjustment.totalHits > 0 ? 
                difficultyAdjustment.successfulHits / difficultyAdjustment.totalHits : 0;
            
            // Update survival time
            if (gameRunning) {
                difficultyAdjustment.survivalTime = Date.now() - (difficultyAdjustment.sessionStartTime || Date.now());
            }
            
            // Adjust difficulty every 30 seconds
            const now = Date.now();
            if (now - difficultyAdjustment.lastAdjustment > 30000) {
                adjustGameDifficulty();
                difficultyAdjustment.lastAdjustment = now;
            }
        }
        
        function adjustGameDifficulty() {
            if (!difficultyAdjustment.enabled || difficultyAdjustment.totalHits < 10) return;
            
            const accuracy = difficultyAdjustment.playerAccuracy;
            const survivalMinutes = Math.max(0, difficultyAdjustment.survivalTime) / 60000;
            
            let newModifier = difficultyAdjustment.currentModifier;
            
            // Increase difficulty if player is performing well
            if (accuracy > 0.8 && survivalMinutes > 2) {
                newModifier = Math.min(1.5, newModifier + 0.1); // Cap at 1.5x difficulty
                
                gameState.feedbackMessages.push({
                    text: "🔥 DIFFICULTY INCREASED!",
                    x: canvas.width / 2,
                    y: 200,
                    life: 180,
                    color: '#FF4500',
                    fontSize: 14,
                    outline: true
                });
            }
            // Decrease difficulty if player is struggling
            else if (accuracy < 0.4 || lives <= 1) {
                newModifier = Math.max(0.7, newModifier - 0.1); // Floor at 0.7x difficulty
                
                gameState.feedbackMessages.push({
                    text: "💪 DIFFICULTY DECREASED!",
                    x: canvas.width / 2,
                    y: 200,
                    life: 180,
                    color: '#32CD32',
                    fontSize: 14,
                    outline: true
                });
            }
            
            if (newModifier !== difficultyAdjustment.currentModifier) {
                difficultyAdjustment.currentModifier = newModifier;
                console.log(`Difficulty adjusted to ${newModifier.toFixed(2)}x (Accuracy: ${(accuracy * 100).toFixed(1)}%, Survival: ${survivalMinutes.toFixed(1)}m)`);
            }
        }
        
        function getDifficultyAdjustedSpeed() {
            return difficultyAdjustment.baseSpeed * difficultyAdjustment.currentModifier;
        }
        
        function getDifficultyAdjustedSpawnRate() {
            // Adjust powerup spawn rate based on difficulty
            const baseRate = 0.15; // 15% base chance
            return baseRate / difficultyAdjustment.currentModifier; // Harder = fewer powerups
        }
        
        function initializeDifficultyTracking() {
            difficultyAdjustment.sessionStartTime = Date.now();
            difficultyAdjustment.lastAdjustment = Date.now();
            difficultyAdjustment.totalHits = 0;
            difficultyAdjustment.successfulHits = 0;
            difficultyAdjustment.survivalTime = 0;
            difficultyAdjustment.currentModifier = 1.0;
        }

        // Phase 3: Achievement System
        let achievements = {
            definitions: {
                // Score Achievements
                first_thousand: { id: 'first_thousand', name: 'First Thousand', description: 'Score 1,000 points', category: 'Score', target: 1000, icon: '🎯' },
                ten_thousand: { id: 'ten_thousand', name: 'Ten Thousand Club', description: 'Score 10,000 points', category: 'Score', target: 10000, icon: '💰' },
                hundred_thousand: { id: 'hundred_thousand', name: 'High Roller', description: 'Score 100,000 points', category: 'Score', target: 100000, icon: '💎' },
                million_club: { id: 'million_club', name: 'Million Club', description: 'Score 1,000,000 points', category: 'Score', target: 1000000, icon: '👑' },
                
                // Survival Achievements  
                level_10: { id: 'level_10', name: 'Getting Started', description: 'Reach Level 10', category: 'Survival', target: 10, icon: '🚀' },
                level_25: { id: 'level_25', name: 'Quarter Century', description: 'Reach Level 25', category: 'Survival', target: 25, icon: '🏆' },
                level_50: { id: 'level_50', name: 'Halfway Hero', description: 'Reach Level 50', category: 'Survival', target: 50, icon: '⭐' },
                level_75: { id: 'level_75', name: 'Three Quarters', description: 'Reach Level 75', category: 'Survival', target: 75, icon: '🌟' },
                completionist: { id: 'completionist', name: 'Completionist', description: 'Complete all 100 levels', category: 'Survival', target: 100, icon: '🏅' },
                
                // Skill Achievements
                combo_master: { id: 'combo_master', name: 'Combo Master', description: 'Achieve 50+ hit combo', category: 'Skill', target: 50, icon: '🔥' },
                precision_player: { id: 'precision_player', name: 'Precision Player', description: 'Maintain 90% paddle accuracy', category: 'Skill', target: 0.9, icon: '🎯' },
                speed_demon_survivor: { id: 'speed_demon_survivor', name: 'Speed Demon', description: 'Survive Speed Demon event', category: 'Skill', target: 1, icon: '⚡' },
                banking_baron: { id: 'banking_baron', name: 'Banking Baron', description: 'Earn 50,000+ points interest', category: 'Skill', target: 50000, icon: '🏦' },
                
                // Discovery Achievements
                treasure_hunter: { id: 'treasure_hunter', name: 'Treasure Hunter', description: 'Open 10 treasure chests', category: 'Discovery', target: 10, icon: '💰' },
                shield_breaker: { id: 'shield_breaker', name: 'Shield Breaker', description: 'Destroy 25 shield blocks', category: 'Discovery', target: 25, icon: '🛡' },
                magnetic_master: { id: 'magnetic_master', name: 'Magnetic Master', description: 'Hit 50 magnetic blocks', category: 'Discovery', target: 50, icon: '🧲' },
                chain_reaction: { id: 'chain_reaction', name: 'Chain Reaction', description: 'Trigger 5+ chain explosion', category: 'Discovery', target: 5, icon: '💥' },
                
                // Special Events
                event_survivor: { id: 'event_survivor', name: 'Event Survivor', description: 'Survive all 6 event types', category: 'Special', target: 6, icon: '🌟' },
                golden_hour_master: { id: 'golden_hour_master', name: 'Golden Hour Master', description: 'Score 100k+ during Golden Hour', category: 'Special', target: 100000, icon: '⭐' },
                difficulty_master: { id: 'difficulty_master', name: 'Difficulty Master', description: 'Reach maximum difficulty (1.5x)', category: 'Special', target: 1.5, icon: '🔥' },
                
                // Boss Battle Achievements
                fortress_destroyer: { id: 'fortress_destroyer', name: 'Fortress Destroyer', description: 'Defeat The Fortress (Level 25)', category: 'Boss', target: 25, icon: '🏰' },
                swarm_conqueror: { id: 'swarm_conqueror', name: 'Swarm Conqueror', description: 'Defeat The Swarm (Level 50)', category: 'Boss', target: 50, icon: '🌀' },
                void_slayer: { id: 'void_slayer', name: 'Void Slayer', description: 'Defeat The Void Titan (Level 75)', category: 'Boss', target: 75, icon: '🕳️' },
                master_champion: { id: 'master_champion', name: 'Master Champion', description: 'Defeat The Master Core (Level 100)', category: 'Boss', target: 100, icon: '👑' },
                boss_hunter: { id: 'boss_hunter', name: 'Boss Hunter', description: 'Defeat all 4 bosses', category: 'Boss', target: 4, icon: '⚔️' }
            },
            unlocked: new Set(),
            progress: {},
            session: {
                treasuresOpened: 0,
                shieldsDestroyed: 0,
                magneticHits: 0,
                maxChainReaction: 0,
                eventsSurvived: new Set(),
                maxCombo: 0,
                interestEarned: 0,
                goldenHourScore: 0
            }
        };
        
        function checkAchievements() {
            const defs = achievements.definitions;
            
            // Score achievements
            checkAchievement('first_thousand', score >= defs.first_thousand.target);
            checkAchievement('ten_thousand', score >= defs.ten_thousand.target);
            checkAchievement('hundred_thousand', score >= defs.hundred_thousand.target);
            checkAchievement('million_club', score >= defs.million_club.target);
            
            // Survival achievements
            checkAchievement('level_10', level >= defs.level_10.target);
            checkAchievement('level_25', level >= defs.level_25.target);
            checkAchievement('level_50', level >= defs.level_50.target);
            checkAchievement('level_75', level >= defs.level_75.target);
            checkAchievement('completionist', level >= defs.completionist.target);
            
            // Skill achievements
            checkAchievement('combo_master', gameState.combo >= defs.combo_master.target);
            checkAchievement('precision_player', difficultyAdjustment.playerAccuracy >= defs.precision_player.target);
            checkAchievement('banking_baron', achievements.session.interestEarned >= defs.banking_baron.target);
            checkAchievement('difficulty_master', difficultyAdjustment.currentModifier >= defs.difficulty_master.target);
            
            // Discovery achievements
            checkAchievement('treasure_hunter', achievements.session.treasuresOpened >= defs.treasure_hunter.target);
            checkAchievement('shield_breaker', achievements.session.shieldsDestroyed >= defs.shield_breaker.target);
            checkAchievement('magnetic_master', achievements.session.magneticHits >= defs.magnetic_master.target);
            checkAchievement('chain_reaction', achievements.session.maxChainReaction >= defs.chain_reaction.target);
            
            // Special achievements
            checkAchievement('event_survivor', achievements.session.eventsSurvived.size >= defs.event_survivor.target);
            checkAchievement('golden_hour_master', achievements.session.goldenHourScore >= defs.golden_hour_master.target);
            
            // Boss achievements
            if (achievements.session.bossesDefeated) {
                checkAchievement('fortress_destroyer', achievements.session.bossesDefeated.has(25));
                checkAchievement('swarm_conqueror', achievements.session.bossesDefeated.has(50));
                checkAchievement('void_slayer', achievements.session.bossesDefeated.has(75));
                checkAchievement('master_champion', achievements.session.bossesDefeated.has(100));
                checkAchievement('boss_hunter', achievements.session.bossesDefeated.size >= defs.boss_hunter.target);
            }
            
            // Update max combo tracking
            achievements.session.maxCombo = Math.max(achievements.session.maxCombo, gameState.combo);
        }
        
        function checkAchievement(id, condition) {
            if (condition && !achievements.unlocked.has(id)) {
                unlockAchievement(id);
            }
        }
        
        function unlockAchievement(id) {
            const achievement = achievements.definitions[id];
            if (!achievement) return;
            
            achievements.unlocked.add(id);
            
            // Track achievement unlock for analytics
            trackAchievementUnlocked(id, achievement.name);
            
            // Visual notification
            gameState.feedbackMessages.push({
                text: `🏆 ACHIEVEMENT UNLOCKED!`,
                x: canvas.width / 2,
                y: canvas.height / 2 - 40,
                life: 300,
                color: '#FFD700',
                fontSize: 18,
                outline: true
            });
            
            gameState.feedbackMessages.push({
                text: `${achievement.icon} ${achievement.name}`,
                x: canvas.width / 2,
                y: canvas.height / 2 - 10,
                life: 300,
                color: '#FFA500',
                fontSize: 14,
                outline: true
            });
            
            gameState.feedbackMessages.push({
                text: achievement.description,
                x: canvas.width / 2,
                y: canvas.height / 2 + 15,
                life: 300,
                color: '#FFFFFF',
                fontSize: 10,
                outline: true
            });
            
            // Particle celebration
            createParticles(canvas.width / 2, canvas.height / 2, '#FFD700', 25);
            
            console.log(`Achievement unlocked: ${achievement.name} - ${achievement.description}`);
        }
        
        function trackTreasureOpened() {
            achievements.session.treasuresOpened++;
            checkAchievements();
        }
        
        function trackShieldDestroyed() {
            achievements.session.shieldsDestroyed++;
            checkAchievements();
        }
        
        function trackMagneticHit() {
            achievements.session.magneticHits++;
            checkAchievements();
        }
        
        function trackChainReaction(depth) {
            achievements.session.maxChainReaction = Math.max(achievements.session.maxChainReaction, depth);
            checkAchievements();
        }
        
        function trackEventSurvived(eventType) {
            achievements.session.eventsSurvived.add(eventType);
            checkAchievements();
        }
        
        function trackInterestEarned(amount) {
            achievements.session.interestEarned += amount;
            checkAchievements();
        }
        
        function trackGoldenHourScore(scoreGained) {
            if (temporaryEvents.active && temporaryEvents.active.type === 'golden_hour') {
                achievements.session.goldenHourScore += scoreGained;
                checkAchievements();
            }
        }

        // ===== BOSS BATTLE SYSTEM =====
        // Multi-layer boss battles at milestone levels (25, 50, 75, 100)
        
        // ============================
        // PHASE 4: ADVANCED CHALLENGE MODES SYSTEM
        // ============================
        
        let challengeModes = {
            modeSelectionOpen: false,
            selectedMode: 'classic',
            currentMode: 'classic',
            modes: {
                classic: {
                    name: '🎮 Classic Mode',
                    description: 'Standard Breakout gameplay',
                    active: false,
                    modifiers: {}
                },
                daily: {
                    name: '📅 Daily Challenge',
                    description: 'Limited time with special rewards',
                    active: false,
                    timeLimit: 300000, // 5 minutes in milliseconds
                    timeRemaining: 300000,
                    todaysSeed: 0,
                    completed: false,
                    scoreMultiplier: 2.0,
                    modifiers: {
                        ballSpeed: 1.2,
                        paddleSize: 0.9,
                        powerupFrequency: 1.5
                    }
                },
                survival: {
                    name: '⚡ Survival Mode',
                    description: 'Endless waves, increasing difficulty',
                    active: false,
                    wave: 1,
                    ballsPerWave: 1,
                    maxBalls: 10,
                    waveTimer: 0,
                    nextWaveDelay: 15000, // 15 seconds between waves
                    scoreMultiplier: 1.5,
                    modifiers: {
                        ballSpeedIncrease: 0.05, // 5% per wave
                        paddleSizeDecrease: 0.02, // 2% per wave
                        blockHealthIncrease: 0.1 // 10% per wave
                    }
                },
                speedrun: {
                    name: '🏃 Speed Run',
                    description: 'Race against the clock for best time',
                    active: false,
                    startTime: 0,
                    currentTime: 0,
                    bestTime: Infinity,
                    targetLevel: 25,
                    scoreMultiplier: 1.0,
                    modifiers: {
                        ballSpeed: 1.5,
                        paddleSpeed: 1.3,
                        powerupDuration: 0.5
                    }
                },
                precision: {
                    name: '🎯 Precision Mode',
                    description: 'Limited balls, perfect accuracy required',
                    active: false,
                    ballsAllowed: 10,
                    ballsUsed: 0,
                    accuracyRequired: 90, // 90% accuracy needed
                    scoreMultiplier: 3.0,
                    modifiers: {
                        noPowerups: true,
                        noExtraLives: true,
                        ballSpeed: 0.8
                    }
                },
                chaos: {
                    name: '🌀 Chaos Mode',
                    description: 'All events active, pure madness',
                    active: false,
                    activeEvents: [],
                    eventCooldown: 5000, // 5 seconds between events
                    maxSimultaneousEvents: 3,
                    scoreMultiplier: 2.5,
                    modifiers: {
                        forceEvents: true,
                        eventDuration: 1.5,
                        ballSpeed: 1.1
                    }
                }
            }
        };
        
        function initializeChallengeMode(mode) {
            const modeData = challengeModes.modes[mode];
            if (!modeData) return false;
            
            challengeModes.currentMode = mode;
            modeData.active = true;
            
            // Track challenge mode start for analytics
            if (mode !== 'classic') {
                trackChallengeStarted(mode);
            }
            
            // Mode-specific initialization
            switch (mode) {
                case 'daily':
                    // Generate today's seed based on current date
                    const today = new Date();
                    modeData.todaysSeed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
                    modeData.timeRemaining = modeData.timeLimit;
                    
                    // Check if already completed today
                    const dailyKey = `daily_challenge_${modeData.todaysSeed}`;
                    modeData.completed = localStorage.getItem(dailyKey) === 'completed';
                    break;
                    
                case 'survival':
                    modeData.wave = 1;
                    modeData.ballsPerWave = 1;
                    modeData.waveTimer = 0;
                    break;
                    
                case 'speedrun':
                    modeData.startTime = Date.now();
                    modeData.currentTime = 0;
                    
                    // Load best time from localStorage
                    const bestTimeKey = `speedrun_best_time`;
                    const savedBestTime = localStorage.getItem(bestTimeKey);
                    if (savedBestTime) {
                        modeData.bestTime = parseInt(savedBestTime);
                    }
                    break;
                    
                case 'precision':
                    modeData.ballsUsed = 0;
                    break;
                    
                case 'chaos':
                    modeData.activeEvents = [];
                    // Start with one random event
                    const eventTypes = Object.keys(temporaryEvents.types);
                    if (eventTypes.length > 0) {
                        const randomEventType = eventTypes.length > 0 ? eventTypes[Math.floor(Math.random() * eventTypes.length)] : null;
                        if (!randomEventType) break;
                        startTemporaryEvent(randomEventType);
                        modeData.activeEvents.push(randomEventType);
                    }
                    break;
            }
            
            return true;
        }
        
        function updateChallengeMode(deltaTime) {
            const currentModeData = challengeModes.modes[challengeModes.currentMode];
            if (!currentModeData || !currentModeData.active) return;
            
            switch (challengeModes.currentMode) {
                case 'daily':
                    currentModeData.timeRemaining -= deltaTime;
                    if (currentModeData.timeRemaining <= 0) {
                        // Time's up!
                        endGame('Time limit reached in Daily Challenge!');
                    }
                    break;
                    
                case 'survival':
                    currentModeData.waveTimer += deltaTime;
                    
                    // Check if all blocks are destroyed and it's time for next wave
                    if (blocks.length === 0 && currentModeData.waveTimer >= currentModeData.nextWaveDelay) {
                        startNextSurvivalWave();
                    }
                    
                    // Apply wave-based difficulty scaling
                    const waveMultiplier = 1 + (currentModeData.wave - 1) * 0.1;
                    break;
                    
                case 'speedrun':
                    currentModeData.currentTime = Date.now() - currentModeData.startTime;
                    
                    // Check if target level reached
                    if (level >= currentModeData.targetLevel) {
                        completedSpeedRun();
                    }
                    break;
                    
                case 'precision':
                    // Check if out of balls
                    if (currentModeData.ballsUsed >= currentModeData.ballsAllowed && gameState.balls.length === 0) {
                        endGame('Out of balls in Precision Mode!');
                    }
                    break;
                    
                case 'chaos':
                    // Manage multiple simultaneous events
                    if (currentModeData.activeEvents.length < currentModeData.maxSimultaneousEvents) {
                        // Random chance to start new event
                        if (Math.random() < 0.001) { // 0.1% chance per frame
                            addRandomChaosEvent();
                        }
                    }
                    
                    // Remove expired events
                    currentModeData.activeEvents = currentModeData.activeEvents.filter(eventType => {
                        return temporaryEvents.active && temporaryEvents.active.type === eventType;
                    });
                    break;
            }
        }
        
        function startNextSurvivalWave() {
            const modeData = challengeModes.modes.survival;
            modeData.wave++;
            modeData.waveTimer = 0;
            
            // Generate new wave of blocks
            generateSurvivalWave(modeData.wave);
            
            // Add more balls gradually
            if (modeData.wave % 3 === 0 && gameState.balls.length < modeData.maxBalls) {
                const newBall = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    dx: (Math.random() - 0.5) * 6,
                    dy: -Math.abs(Math.random() * 3 + 2),
                    speed: ballSpeed,
                    trail: []
                };
                gameState.balls.push(newBall);
            }
            
            // Show wave announcement
            showWaveAnnouncement(modeData.wave);
        }
        
        function generateSurvivalWave(wave) {
            blocks = [];
            const baseRows = 6;
            const baseCols = 10;
            const extraRows = Math.min(4, Math.floor(wave / 5)); // Add rows every 5 waves
            const extraCols = Math.min(4, Math.floor(wave / 10)); // Add columns every 10 waves
            
            const rows = baseRows + extraRows;
            const cols = baseCols + extraCols;
            
            const blockWidth = cols > 0 ? canvas.width / cols : 75; // fallback to default width
            const blockHeight = 25;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const baseHealth = Math.ceil(wave / 5) + 1; // Increase health every 5 waves
                    const health = Math.random() < 0.2 ? baseHealth * 2 : baseHealth; // 20% chance for double health
                    
                    blocks.push({
                        x: col * blockWidth,
                        y: row * blockHeight + 50,
                        width: blockWidth - 2,
                        height: blockHeight - 2,
                        health: health,
                        maxHealth: health,
                        points: health * 100 * wave,
                        type: wave % 4 === 0 ? 'special' : 'normal'
                    });
                }
            }
        }
        
        function showWaveAnnouncement(wave) {
            // Show wave overlay
            gameOverlay = {
                active: true,
                type: 'waveAnnouncement',
                wave: wave,
                timer: 3000 // Show for 3 seconds
            };
        }
        
        function completedSpeedRun() {
            const modeData = challengeModes.modes.speedrun;
            const finalTime = Date.now() - modeData.startTime;
            
            // Check if new record
            if (finalTime < modeData.bestTime) {
                modeData.bestTime = finalTime;
                localStorage.setItem('speedrun_best_time', finalTime.toString());
                
                // Show victory overlay with new record
                gameOverlay = {
                    active: true,
                    type: 'speedrunComplete',
                    time: finalTime,
                    newRecord: true,
                    previousBest: modeData.bestTime
                };
            } else {
                // Show completion overlay
                gameOverlay = {
                    active: true,
                    type: 'speedrunComplete',
                    time: finalTime,
                    newRecord: false,
                    bestTime: modeData.bestTime
                };
            }
        }
        
        function addRandomChaosEvent() {
            const modeData = challengeModes.modes.chaos;
            const eventTypes = Object.keys(temporaryEvents.types);
            const availableEventTypes = eventTypes.filter(eventType => 
                !temporaryEvents.active || temporaryEvents.active.type !== eventType && 
                !modeData.activeEvents.includes(eventType)
            );
            
            if (availableEventTypes.length > 0) {
                const randomEventType = availableEventTypes.length > 0 ? availableEventTypes[Math.floor(Math.random() * availableEventTypes.length)] : null;
                if (!randomEventType) return;
                startTemporaryEvent(randomEventType);
                modeData.activeEvents.push(randomEventType);
            }
        }
        
        function drawChallengeModeSelection() {
            if (!challengeModes.modeSelectionOpen) return;
            if (!ctx) return;
            
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.save();
            ctx.shadowColor = '#FF00FF';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#FF00FF';
            ctx.font = 'bold 20px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('🎯 CHALLENGE MODES 🎯', canvas.width / 2, 80);
            ctx.restore();
            
            // Instructions
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 10px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Use 1-6 keys to select mode • SPACE to start • ESC to cancel', canvas.width / 2, 110);
            
            // Mode list
            const modes = Object.keys(challengeModes.modes);
            const startY = 140;
            const spacing = 65;
            
            modes.forEach((modeKey, index) => {
                const mode = challengeModes.modes[modeKey];
                const y = startY + index * spacing;
                const isSelected = challengeModes.selectedMode === modeKey;
                
                // Selection highlight
                if (isSelected) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.fillRect(50, y - 25, canvas.width - 100, 50);
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(50, y - 25, canvas.width - 100, 50);
                }
                
                // Mode number and name
                ctx.fillStyle = isSelected ? '#FFFF00' : '#00FFFF';
                ctx.font = 'bold 12px "Press Start 2P", monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`${index + 1}. ${mode.name}`, 70, y - 5);
                
                // Mode description
                ctx.fillStyle = isSelected ? '#FFFFFF' : '#CCCCCC';
                ctx.font = 'bold 8px "Press Start 2P", monospace';
                ctx.fillText(mode.description, 90, y + 10);
                
                // Mode-specific info
                let extraInfo = '';
                switch (modeKey) {
                    case 'daily':
                        const remaining = Math.ceil(mode.timeRemaining / 60000);
                        extraInfo = mode.completed ? '✅ Completed Today' : `⏰ ${remaining}min limit`;
                        break;
                    case 'survival':
                        extraInfo = '♾️ Endless waves';
                        break;
                    case 'speedrun':
                        const bestMins = Math.floor(mode.bestTime / 60000);
                        const bestSecs = Math.floor((mode.bestTime % 60000) / 1000);
                        extraInfo = mode.bestTime === Infinity ? '🏁 No record yet' : `🏆 Best: ${bestMins}:${bestSecs.toString().padStart(2, '0')}`;
                        break;
                    case 'precision':
                        extraInfo = `🎯 ${mode.ballsAllowed} balls only`;
                        break;
                    case 'chaos':
                        extraInfo = '🌪️ All events active';
                        break;
                }
                
                if (extraInfo) {
                    ctx.fillStyle = isSelected ? '#00FF00' : '#888888';
                    ctx.font = 'bold 7px "Press Start 2P", monospace';
                    ctx.fillText(extraInfo, 90, y + 22);
                }
            });
        }
        
        function drawChallengeModeHUD() {
            const currentModeData = challengeModes.modes[challengeModes.currentMode];
            if (!currentModeData || !currentModeData.active || challengeModes.currentMode === 'classic') return;
            if (!ctx) return;
            
            // Mode indicator in top-right
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width - 200, 10, 190, 60);
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(canvas.width - 200, 10, 190, 60);
            
            ctx.fillStyle = '#00FFFF';
            ctx.font = 'bold 8px "Press Start 2P", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(currentModeData.name, canvas.width - 195, 25);
            
            // Mode-specific HUD elements
            switch (challengeModes.currentMode) {
                case 'daily':
                    const minutes = Math.floor(currentModeData.timeRemaining / 60000);
                    const seconds = Math.floor((currentModeData.timeRemaining % 60000) / 1000);
                    ctx.fillStyle = currentModeData.timeRemaining < 60000 ? '#FF0000' : '#FFFFFF';
                    ctx.fillText(`Time: ${minutes}:${seconds.toString().padStart(2, '0')}`, canvas.width - 195, 40);
                    ctx.fillText(`Multiplier: x${currentModeData.scoreMultiplier}`, canvas.width - 195, 55);
                    break;
                    
                case 'survival':
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(`Wave: ${currentModeData.wave}`, canvas.width - 195, 40);
                    ctx.fillText(`Balls: ${gameState.balls.length}/${currentModeData.maxBalls}`, canvas.width - 195, 55);
                    break;
                    
                case 'speedrun':
                    const currentMins = Math.floor(currentModeData.currentTime / 60000);
                    const currentSecs = Math.floor((currentModeData.currentTime % 60000) / 1000);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(`Time: ${currentMins}:${currentSecs.toString().padStart(2, '0')}`, canvas.width - 195, 40);
                    ctx.fillText(`Target: Level ${currentModeData.targetLevel}`, canvas.width - 195, 55);
                    break;
                    
                case 'precision':
                    const ballsLeft = currentModeData.ballsAllowed - currentModeData.ballsUsed;
                    ctx.fillStyle = ballsLeft <= 3 ? '#FF0000' : '#FFFFFF';
                    ctx.fillText(`Balls Left: ${ballsLeft}`, canvas.width - 195, 40);
                    
                    const accuracy = currentModeData.ballsUsed > 0 ? 
                        Math.round((sessionStats.blocksDestroyed / currentModeData.ballsUsed) * 100) : 100;
                    ctx.fillStyle = accuracy >= currentModeData.accuracyRequired ? '#00FF00' : '#FF0000';
                    ctx.fillText(`Accuracy: ${accuracy}%`, canvas.width - 195, 55);
                    break;
                    
                case 'chaos':
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(`Events: ${currentModeData.activeEvents.length}/${currentModeData.maxSimultaneousEvents}`, canvas.width - 195, 40);
                    ctx.fillText(`Multiplier: x${currentModeData.scoreMultiplier}`, canvas.width - 195, 55);
                    break;
            }
            ctx.restore();
        }
        
        function handleChallengeModeInput(key) {
            if (!challengeModes.modeSelectionOpen) return false;
            
            const modes = Object.keys(challengeModes.modes);
            
            if (key >= '1' && key <= '6') {
                const modeIndex = parseInt(key) - 1;
                if (modeIndex < modes.length) {
                    challengeModes.selectedMode = modes[modeIndex];
                }
                return true;
            } else if (key === ' ') {
                // Start selected mode
                challengeModes.modeSelectionOpen = false;
                if (initializeChallengeMode(challengeModes.selectedMode)) {
                    startGame();
                }
                return true;
            } else if (key === 'Escape') {
                challengeModes.modeSelectionOpen = false;
                return true;
            }
            
            return false;
        }
        
        // Enhanced ball loss tracking for challenge modes
        function onBallLost() {
            const currentModeData = challengeModes.modes[challengeModes.currentMode];
            if (currentModeData && currentModeData.active) {
                switch (challengeModes.currentMode) {
                    case 'precision':
                        currentModeData.ballsUsed++;
                        break;
                }
            }
        }
        
        // Apply challenge mode modifiers to game variables
        function applyChallengeModeModifiers() {
            const currentModeData = challengeModes.modes[challengeModes.currentMode];
            if (!currentModeData || !currentModeData.active) return;
            
            const modifiers = currentModeData.modifiers;
            if (!modifiers) return;
            
            // Apply modifiers
            if (modifiers.ballSpeed) {
                ballSpeed *= modifiers.ballSpeed;
            }
            if (modifiers.paddleSpeed) {
                paddleSpeed *= modifiers.paddleSpeed;
            }
            if (modifiers.paddleSize) {
                paddleWidth *= modifiers.paddleSize;
            }
        }
        
        // Enhanced endGame function for challenge modes
        function endGame(message) {
            if (gameRunning) {
                gameRunning = false;
                gamePaused = false;
                
                // Challenge mode specific end game logic
                const currentModeData = challengeModes.modes[challengeModes.currentMode];
                if (currentModeData && currentModeData.active) {
                    switch (challengeModes.currentMode) {
                        case 'daily':
                            // Mark daily challenge as completed
                            const dailyKey = `daily_challenge_${currentModeData.todaysSeed}`;
                            localStorage.setItem(dailyKey, 'completed');
                            break;
                    }
                    
                    // Deactivate challenge mode
                    currentModeData.active = false;
                }
                
                // Show game over overlay with custom message
                gameOverlay = {
                    active: true,
                    type: 'gameOver',
                    title: '🎮 GAME OVER 🎮',
                    message: message || 'Game Over!',
                    finalScore: score,
                    levelReached: level,
                    playerName: playerName || 'Anonymous'
                };
            }
        }

        // ============================
        // PHASE 4: MYSTICAL POWER SYSTEM
        // ============================
        
        let mysticalPowers = {
            active: false,
            unlockedElements: ['normal'], // Start with normal, unlock others through gameplay
            currentEnchantment: null,
            elementalBalls: {
                fire: {
                    name: '🔥 Fire Ball',
                    color: '#FF4500',
                    trailColor: '#FF6600',
                    description: 'Burns through blocks, spreads fire damage',
                    effects: {
                        burnDamage: 2,
                        spreadChance: 0.3,
                        igniteRadius: 30,
                        damageOverTime: 1000 // 1 second burn
                    },
                    unlockCondition: 'Destroy 500 blocks',
                    unlocked: false
                },
                ice: {
                    name: '❄️ Ice Ball',
                    color: '#00BFFF',
                    trailColor: '#87CEEB',
                    description: 'Slows down time, freezes blocks',
                    effects: {
                        slowFactor: 0.5,
                        freezeDuration: 3000, // 3 seconds
                        shatterMultiplier: 2,
                        freezeRadius: 40
                    },
                    unlockCondition: 'Reach level 15',
                    unlocked: false
                },
                lightning: {
                    name: '⚡ Lightning Ball',
                    color: '#FFD700',
                    trailColor: '#FFFF00',
                    description: 'Chains lightning between blocks',
                    effects: {
                        chainRange: 80,
                        maxChains: 5,
                        chainDamage: 3,
                        stunDuration: 1500 // 1.5 seconds
                    },
                    unlockCondition: 'Achieve 50x combo',
                    unlocked: false
                },
                void: {
                    name: '🌌 Void Ball',
                    color: '#4B0082',
                    trailColor: '#8A2BE2',
                    description: 'Absorbs enemy attacks, phases through blocks',
                    effects: {
                        phaseChance: 0.4,
                        absorbRadius: 25,
                        voidDamage: 4,
                        realityTear: true
                    },
                    unlockCondition: 'Defeat a boss battle',
                    unlocked: false
                }
            },
            enchantments: {
                phoenix: {
                    name: '🔥 Phoenix Rebirth',
                    description: 'Ball respawns from ashes when lost',
                    duration: 30000, // 30 seconds
                    cost: 50,
                    effects: { rebirthChance: 0.8, damageBonus: 1.5 }
                },
                frostGuard: {
                    name: '❄️ Frost Guard',
                    description: 'Paddle creates ice barriers that block balls',
                    duration: 45000, // 45 seconds
                    cost: 40,
                    effects: { barrierCount: 3, barrierStrength: 2 }
                },
                stormLord: {
                    name: '⚡ Storm Lord',
                    description: 'All balls become lightning balls temporarily',
                    duration: 20000, // 20 seconds
                    cost: 60,
                    effects: { elementOverride: 'lightning', powerMultiplier: 2 }
                },
                voidMaster: {
                    name: '🌌 Void Master',
                    description: 'Balls can phase through paddle and blocks',
                    duration: 25000, // 25 seconds
                    cost: 80,
                    effects: { phaseMode: true, damageReduction: 0.3 }
                },
                elementalFusion: {
                    name: '🌟 Elemental Fusion',
                    description: 'Combine all elemental effects',
                    duration: 15000, // 15 seconds
                    cost: 100,
                    effects: { fusionMode: true, allElements: true }
                }
            },
            elementalEffects: {
                burningBlocks: new Map(), // blockId -> { endTime, damage }
                frozenBlocks: new Map(),  // blockId -> { endTime, originalColor }
                chainTargets: [],         // Array of blocks for lightning chains
                voidTears: []            // Array of void tear effects
            },
            mysticalEnergy: 0,    // Currency for enchantments
            maxEnergy: 100,
            energyRegenRate: 0.5, // Per second
            activeEnchantments: [],
            selectedElement: 'normal',
            menuOpen: false,      // Track if mystical powers menu is open
            wasGameRunning: false // Track if game was running when menu opened
        };
        
        function initializeMysticalPowers() {
            mysticalPowers.active = true;
            
            // Track mystical powers activation for analytics
            trackMysticalPowersActivated();
            
            // Check unlock conditions
            checkElementalUnlocks();
            
            // Load saved mystical progress
            const savedProgress = localStorage.getItem('mystical_progress');
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                mysticalPowers.unlockedElements = progress.unlockedElements || ['normal'];
                mysticalPowers.mysticalEnergy = progress.mysticalEnergy || 0;
                
                // Update unlock status
                Object.keys(mysticalPowers.elementalBalls).forEach(element => {
                    if (mysticalPowers.unlockedElements.includes(element)) {
                        mysticalPowers.elementalBalls[element].unlocked = true;
                    }
                });
            }
        }
        
        function checkElementalUnlocks() {
            const elements = mysticalPowers.elementalBalls;
            
            // Fire: Destroy 500 blocks
            if (!elements.fire.unlocked && sessionStats.blocksDestroyed >= 500) {
                unlockElement('fire');
            }
            
            // Ice: Reach level 15
            if (!elements.ice.unlocked && level >= 15) {
                unlockElement('ice');
            }
            
            // Lightning: Achieve 50x combo
            const comboMultiplier = Math.min(gameState.combo, 500);
            if (!elements.lightning.unlocked && comboMultiplier >= 50) {
                unlockElement('lightning');
            }
            
            // Void: Defeat a boss battle
            if (!elements.void.unlocked && bossSystem.defeated) {
                unlockElement('void');
            }
        }
        
        function unlockElement(elementType) {
            if (!mysticalPowers.elementalBalls[elementType].unlocked) {
                mysticalPowers.elementalBalls[elementType].unlocked = true;
                mysticalPowers.unlockedElements.push(elementType);
                
                // Show unlock notification
                gameState.feedbackMessages.push({
                    text: `🌟 UNLOCKED: ${mysticalPowers.elementalBalls[elementType].name}!`,
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    duration: 4000,
                    fontSize: 16,
                    color: mysticalPowers.elementalBalls[elementType].color,
                    glow: true
                });
                
                // Award mystical energy
                gainMysticalEnergy(20);
                
                // Save progress
                saveMysticalProgress();
            }
        }
        
        function gainMysticalEnergy(amount) {
            mysticalPowers.mysticalEnergy = Math.min(
                mysticalPowers.maxEnergy, 
                mysticalPowers.mysticalEnergy + amount
            );
        }
        
        function spendMysticalEnergy(amount) {
            if (mysticalPowers.mysticalEnergy >= amount) {
                mysticalPowers.mysticalEnergy -= amount;
                return true;
            }
            return false;
        }
        
        function saveMysticalProgress() {
            const progress = {
                unlockedElements: mysticalPowers.unlockedElements,
                mysticalEnergy: mysticalPowers.mysticalEnergy
            };
            localStorage.setItem('mystical_progress', JSON.stringify(progress));
        }
        
        function getActiveElementOverride() {
            // Check if any active enchantments override the ball element
            for (let enchant of mysticalPowers.activeEnchantments) {
                if (enchant.effects && enchant.effects.elementOverride) {
                    return enchant.effects.elementOverride;
                }
            }
            return null;
        }
        
        function createElementalBall(element = 'normal') {
            // Check for active enchantments that override element
            const elementOverride = getActiveElementOverride();
            if (elementOverride) {
                element = elementOverride;
                console.log(`Element overridden by enchantment: ${element}`);
            }
            
            // Allow selected elements from mystical powers menu even if not unlocked
            if (!mysticalPowers.elementalBalls[element]) {
                element = 'normal';
            } else if (!mysticalPowers.elementalBalls[element].unlocked && element !== mysticalPowers.selectedElement && !elementOverride) {
                // Only fallback to normal if it's not the currently selected element or overridden by enchantment
                element = 'normal';
            }
            
            const ball = {
                x: canvas.width / 2,
                y: canvas.height - paddleHeight - 25,
                dx: (Math.random() - 0.5) * 6,
                dy: -Math.abs(Math.random() * 3 + 2),
                speed: ballSpeed,
                trail: [],
                element: element,
                elementalEffects: {},
                id: Date.now() + Math.random() // Unique ID for tracking
            };
            
            // Apply elemental properties
            if (element !== 'normal') {
                const elementData = mysticalPowers.elementalBalls[element];
                ball.color = elementData.color;
                ball.trailColor = elementData.trailColor;
                
                // Initialize element-specific effects
                switch (element) {
                    case 'fire':
                        ball.elementalEffects.burnRadius = elementData.effects.igniteRadius;
                        ball.elementalEffects.burnDamage = elementData.effects.burnDamage;
                        break;
                    case 'ice':
                        ball.elementalEffects.freezeRadius = elementData.effects.freezeRadius;
                        ball.elementalEffects.slowFactor = elementData.effects.slowFactor;
                        break;
                    case 'lightning':
                        ball.elementalEffects.chainRange = elementData.effects.chainRange;
                        ball.elementalEffects.maxChains = elementData.effects.maxChains;
                        break;
                    case 'void':
                        ball.elementalEffects.phaseChance = elementData.effects.phaseChance;
                        ball.elementalEffects.voidDamage = elementData.effects.voidDamage;
                        break;
                }
            }
            
            return ball;
        }
        
        function updateMysticalPowers(deltaTime) {
            if (!mysticalPowers.active) return;
            
            // Regenerate mystical energy
            if (mysticalPowers.mysticalEnergy < mysticalPowers.maxEnergy) {
                mysticalPowers.mysticalEnergy += mysticalPowers.energyRegenRate * (deltaTime / 1000);
                mysticalPowers.mysticalEnergy = Math.min(mysticalPowers.maxEnergy, mysticalPowers.mysticalEnergy);
            }
            
            // Update elemental effects
            updateElementalEffects(deltaTime);
            
            // Update active enchantments
            updateActiveEnchantments(deltaTime);
            
            // Check for new unlocks
            checkElementalUnlocks();
        }
        
        function updateElementalEffects(deltaTime) {
            const now = Date.now();
            
            // Update burning blocks
            for (let [blockId, burnData] of mysticalPowers.elementalEffects.burningBlocks) {
                if (now > burnData.endTime) {
                    mysticalPowers.elementalEffects.burningBlocks.delete(blockId);
                } else {
                    // Apply burn damage over time
                    const block = blocks.find(b => b.id === blockId);
                    if (block && !block.destroyed) {
                        if (now - burnData.lastDamage >= 500) { // Damage every 0.5 seconds
                            damageBlock(block, burnData.damage);
                            burnData.lastDamage = now;
                            
                            // Spread fire to nearby blocks
                            if (Math.random() < 0.2) { // 20% chance to spread
                                spreadFireToNearbyBlocks(block);
                            }
                        }
                    }
                }
            }
            
            // Update frozen blocks
            for (let [blockId, freezeData] of mysticalPowers.elementalEffects.frozenBlocks) {
                if (now > freezeData.endTime) {
                    // Restore original block properties
                    const block = blocks.find(b => b.id === blockId);
                    if (block) {
                        delete block.frozen;
                        delete block.frozenColor;
                    }
                    mysticalPowers.elementalEffects.frozenBlocks.delete(blockId);
                }
            }
            
            // Update void tears
            mysticalPowers.elementalEffects.voidTears = mysticalPowers.elementalEffects.voidTears.filter(tear => {
                tear.life -= deltaTime;
                tear.radius += tear.growthRate * (deltaTime / 1000);
                return tear.life > 0;
            });
        }
        
        function updateActiveEnchantments(deltaTime) {
            mysticalPowers.activeEnchantments = mysticalPowers.activeEnchantments.filter(enchant => {
                enchant.timeRemaining -= deltaTime;
                
                if (enchant.timeRemaining <= 0) {
                    // Enchantment expired
                    deactivateEnchantment(enchant);
                    return false;
                }
                
                return true;
            });
        }
        
        function applyElementalBallEffect(ball, block) {
            if (!ball.element || ball.element === 'normal') return;
            
            const elementData = mysticalPowers.elementalBalls[ball.element];
            if (!elementData) return;
            
            switch (ball.element) {
                case 'fire':
                    applyFireEffect(ball, block);
                    break;
                case 'ice':
                    applyIceEffect(ball, block);
                    break;
                case 'lightning':
                    applyLightningEffect(ball, block);
                    break;
                case 'void':
                    applyVoidEffect(ball, block);
                    break;
            }
        }
        
        function applyFireEffect(ball, block) {
            // Ignite the block
            const now = Date.now();
            const effects = mysticalPowers.elementalBalls.fire.effects;
            
            if (!mysticalPowers.elementalEffects.burningBlocks.has(block.id)) {
                mysticalPowers.elementalEffects.burningBlocks.set(block.id, {
                    endTime: now + effects.damageOverTime,
                    damage: effects.burnDamage,
                    lastDamage: now
                });
                
                // Visual effect for ignition
                createFireParticles(block.x + block.width/2, block.y + block.height/2);
            }
            
            // Spread fire to nearby blocks
            if (Math.random() < effects.spreadChance) {
                spreadFireToNearbyBlocks(block);
            }
        }
        
        function applyIceEffect(ball, block) {
            const now = Date.now();
            const effects = mysticalPowers.elementalBalls.ice.effects;
            
            // Freeze the block
            if (!mysticalPowers.elementalEffects.frozenBlocks.has(block.id)) {
                mysticalPowers.elementalEffects.frozenBlocks.set(block.id, {
                    endTime: now + effects.freezeDuration,
                    originalColor: block.color
                });
                
                block.frozen = true;
                block.frozenColor = '#87CEEB';
                
                // Create ice particles
                createIceParticles(block.x + block.width/2, block.y + block.height/2);
            }
            
            // Temporary time slowdown effect
            if (!gameState.timeSlowed) {
                gameState.timeSlowed = true;
                gameState.timeSlowEndTime = now + 2000; // 2 seconds
                gameState.timeSlowFactor = effects.slowFactor;
            }
        }
        
        function applyLightningEffect(ball, block) {
            const effects = mysticalPowers.elementalBalls.lightning.effects;
            
            // Enhanced effects when combined with powerups
            let chainRange = effects.chainRange;
            let maxChains = effects.maxChains;
            let chainDamage = effects.chainDamage;
            
            // Rocket ball enhancement - doubles chain range and damage
            if (ball.rocket) {
                chainRange *= 2; // 160 pixel range
                chainDamage *= 2; // 6 damage per chain
            }
            
            // Mega ball enhancement - more chains and explosive damage
            if (ball.mega) {
                maxChains *= 2; // 10 chains
                chainDamage = Math.ceil(chainDamage * 1.5); // +50% damage
            }
            
            // ULTIMATE COMBO: Lightning + Rocket + Mega = STORM OF DESTRUCTION
            if (ball.rocket && ball.mega) {
                chainRange = effects.chainRange * 3; // 240 pixel range - massive reach
                maxChains = effects.maxChains * 3; // 15 chains - devastating spread
                chainDamage = effects.chainDamage * 4; // 12 damage - instant destruction for most blocks
                
                // Create epic visual feedback
                gameState.screenShake = 15; // Massive screen shake
                createLightningStorm(ball.x, ball.y); // Special storm effect
            }
            
            // Create lightning chain with enhanced parameters
            const chainTargets = findLightningChainTargets(block, chainRange, maxChains);
            
            chainTargets.forEach((target, index) => {
                setTimeout(() => {
                    if (!target.destroyed) {
                        // Apply enhanced damage
                        damageBlock(target, chainDamage);
                        
                        // Create visual effect
                        createLightningEffect(block, target);
                        
                        // Mega ball causes mini-explosions at each chain point
                        if (ball.mega) {
                            createParticles(target.x + target.width/2, target.y + target.height/2, '#FFD700', 20);
                            gameState.screenShake = Math.max(gameState.screenShake, 5);
                        }
                        
                        // Rocket ball creates penetrating lightning that damages blocks behind
                        if (ball.rocket) {
                            const behindTargets = findLightningChainTargets(target, 50, 2);
                            behindTargets.forEach(behind => {
                                if (!behind.destroyed) {
                                    damageBlock(behind, Math.ceil(chainDamage / 2));
                                    createLightningStrike(target.x + target.width/2, target.y + target.height/2, 
                                                        behind.x + behind.width/2, behind.y + behind.height/2);
                                }
                            });
                        }
                    }
                }, index * 100); // Stagger the chain
            });
            
            // Create initial lightning strike
            createLightningStrike(ball.x, ball.y, block.x + block.width/2, block.y + block.height/2);
        }
        
        function applyVoidEffect(ball, block) {
            const effects = mysticalPowers.elementalBalls.void.effects;
            
            // Create void tear at impact point
            mysticalPowers.elementalEffects.voidTears.push({
                x: block.x + block.width/2,
                y: block.y + block.height/2,
                radius: 5,
                maxRadius: effects.absorbRadius,
                growthRate: 20,
                life: 3000, // 3 seconds
                damage: effects.voidDamage
            });
            
            // Phase effect - ball might pass through
            if (Math.random() < effects.phaseChance) {
                ball.phasing = true;
                setTimeout(() => {
                    ball.phasing = false;
                }, 500);
            }
        }
        
        // Helper functions for elemental effects
        function damageBlock(block, damage) {
            if (!block || block.destroyed) return;
            
            // Blocks use 'hits' not 'health'
            block.hits -= damage;
            if (block.hits <= 0) {
                block.destroyed = true;
                
                // Add score for chain damage
                const basePoints = 10;
                const points = Math.floor(basePoints * gameState.multiplier * gameState.combo);
                score += points;
                
                // Create destruction effects
                createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color);
                
                // Chance to spawn powerup
                trySpawnPowerUpOnHit(block.x + block.width / 2, block.y + block.height / 2);
            }
        }
        
        function spreadFireToNearbyBlocks(sourceBlock) {
            const spreadRadius = 50;
            const now = Date.now();
            
            blocks.forEach(block => {
                if (block.destroyed || block.id === sourceBlock.id) return;
                
                const distance = Math.sqrt(
                    Math.pow(block.x - sourceBlock.x, 2) + 
                    Math.pow(block.y - sourceBlock.y, 2)
                );
                
                if (distance <= spreadRadius && !mysticalPowers.elementalEffects.burningBlocks.has(block.id)) {
                    mysticalPowers.elementalEffects.burningBlocks.set(block.id, {
                        endTime: now + 1000, // Shorter burn for spread
                        damage: 1,
                        lastDamage: now
                    });
                    createFireParticles(block.x + block.width/2, block.y + block.height/2);
                }
            });
        }
        
        function findLightningChainTargets(sourceBlock, chainRange, maxChains) {
            const targets = [];
            const used = new Set([sourceBlock.id]);
            let currentBlock = sourceBlock;
            
            for (let i = 0; i < maxChains; i++) {
                let nearestBlock = null;
                let nearestDistance = Infinity;
                
                blocks.forEach(block => {
                    if (block.destroyed || used.has(block.id)) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(block.x - currentBlock.x, 2) + 
                        Math.pow(block.y - currentBlock.y, 2)
                    );
                    
                    if (distance <= chainRange && distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestBlock = block;
                    }
                });
                
                if (nearestBlock) {
                    targets.push(nearestBlock);
                    used.add(nearestBlock.id);
                    currentBlock = nearestBlock;
                } else {
                    break;
                }
            }
            
            return targets;
        }
        
        // Visual effect creators
        function createFireParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 4,
                    dy: (Math.random() - 0.5) * 4,
                    life: 1000,
                    maxLife: 1000,
                    color: '#FF4500',
                    size: Math.random() * 4 + 2,
                    type: 'fire'
                });
            }
        }
        
        function createIceParticles(x, y) {
            for (let i = 0; i < 6; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 3,
                    dy: (Math.random() - 0.5) * 3,
                    life: 1500,
                    maxLife: 1500,
                    color: '#87CEEB',
                    size: Math.random() * 3 + 1,
                    type: 'ice'
                });
            }
        }
        
        function createLightningEffect(from, to) {
            // Create lightning bolt visual effect
            gameState.particles.push({
                x: from.x + from.width/2,
                y: from.y + from.height/2,
                targetX: to.x + to.width/2,
                targetY: to.y + to.height/2,
                life: 300,
                maxLife: 300,
                color: '#FFD700',
                type: 'lightning'
            });
        }
        
        function createLightningStrike(fromX, fromY, toX, toY) {
            gameState.particles.push({
                x: fromX,
                y: fromY,
                targetX: toX,
                targetY: toY,
                life: 500,
                maxLife: 500,
                color: '#FFFF00',
                type: 'lightning'
            });
        }
        
        function createLightningStorm(centerX, centerY) {
            // Create multiple lightning bolts radiating from center
            const stormBolts = 8;
            const stormRadius = 200;
            
            for (let i = 0; i < stormBolts; i++) {
                const angle = (i / stormBolts) * Math.PI * 2;
                const targetX = centerX + Math.cos(angle) * stormRadius;
                const targetY = centerY + Math.sin(angle) * stormRadius;
                
                // Create main storm bolt
                gameState.particles.push({
                    x: centerX,
                    y: centerY,
                    targetX: targetX,
                    targetY: targetY,
                    life: 800,
                    maxLife: 800,
                    color: '#00FFFF', // Cyan for storm bolts
                    type: 'lightning'
                });
                
                // Create secondary branching bolts
                const branchCount = 2;
                for (let j = 0; j < branchCount; j++) {
                    const branchAngle = angle + (Math.random() - 0.5) * 0.5;
                    const branchDist = stormRadius * (0.5 + Math.random() * 0.5);
                    const branchX = centerX + Math.cos(branchAngle) * branchDist;
                    const branchY = centerY + Math.sin(branchAngle) * branchDist;
                    
                    gameState.particles.push({
                        x: targetX,
                        y: targetY,
                        targetX: branchX,
                        targetY: branchY,
                        life: 600,
                        maxLife: 600,
                        color: '#FFD700', // Gold for branch bolts
                        type: 'lightning'
                    });
                }
            }
            
            // Add epic storm message
            gameState.feedbackMessages.push({
                text: '⚡ LIGHTNING STORM UNLEASHED! ⚡',
                x: canvas.width / 2,
                y: canvas.height / 2 - 100,
                duration: 2000,
                fontSize: 16,
                color: '#00FFFF',
                glow: true
            });
        }
        
        // Mystical Powers UI
        function drawMysticalPowersHUD() {
            if (!mysticalPowers.active) {
                const mysticalDisplay = document.getElementById('mysticalDisplay');
                if (mysticalDisplay) mysticalDisplay.style.display = 'none';
                const fsMysticalDisplay = document.getElementById('fs-mystical-display');
                if (fsMysticalDisplay) fsMysticalDisplay.style.display = 'none';
                return;
            }
            
            // Update windowed mystical powers display
            const mysticalDisplay = document.getElementById('mysticalDisplay');
            if (mysticalDisplay) mysticalDisplay.style.display = 'block';
            
            // Update energy bar
            const energyPercent = mysticalPowers.mysticalEnergy / mysticalPowers.maxEnergy;
            const energyFill = document.getElementById('mysticalEnergyFill');
            if (energyFill) {
                energyFill.style.width = `${energyPercent * 100}%`;
            }
            
            // Update energy text
            const energyText = document.getElementById('mysticalEnergyText');
            if (energyText) {
                energyText.textContent = `Energy: ${Math.floor(mysticalPowers.mysticalEnergy)}/${mysticalPowers.maxEnergy}`;
            }
            
            // Update element text
            const elementText = document.getElementById('mysticalElementText');
            if (elementText) {
                if (mysticalPowers.selectedElement !== 'normal') {
                    const element = mysticalPowers.elementalBalls[mysticalPowers.selectedElement];
                    if (element) {
                        const elementName = element.unlocked ? element.name : `${element.name} (Preview)`;
                        elementText.textContent = `Element: ${elementName}`;
                        elementText.style.color = element.color;
                        elementText.style.display = 'block';
                    }
                } else {
                    elementText.style.display = 'none';
                }
            }
            
            // Update fullscreen mystical powers display
            if (isFullscreen) {
                const fsMysticalDisplay = document.getElementById('fs-mystical-display');
                if (fsMysticalDisplay) {
                    fsMysticalDisplay.style.display = 'block';
                    
                    // Update fullscreen energy text
                    const fsEnergyText = document.getElementById('fs-mystical-energy-text');
                    if (fsEnergyText) {
                        fsEnergyText.textContent = `Energy: ${Math.floor(mysticalPowers.mysticalEnergy)}/${mysticalPowers.maxEnergy}`;
                    }
                    
                    // Update fullscreen energy bar
                    const fsEnergyFill = document.getElementById('fs-mystical-energy-fill');
                    if (fsEnergyFill) {
                        fsEnergyFill.style.width = `${energyPercent * 100}%`;
                    }
                    
                    // Update fullscreen element text
                    const fsElementText = document.getElementById('fs-mystical-element-text');
                    if (fsElementText) {
                        if (mysticalPowers.selectedElement !== 'normal') {
                            const element = mysticalPowers.elementalBalls[mysticalPowers.selectedElement];
                            if (element) {
                                const elementName = element.unlocked ? element.name : `${element.name} (Preview)`;
                                fsElementText.textContent = `Element: ${elementName}`;
                                fsElementText.style.color = element.color;
                                fsElementText.style.display = 'block';
                            }
                        } else {
                            fsElementText.style.display = 'none';
                        }
                    }
                }
            }
        }
        
        function drawMysticalSelectionMenu() {
            if (!mysticalPowers.menuOpen) return;
            
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.textAlign = 'center';
            
            // Title
            ctx.shadowColor = '#9932CC';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#9932CC';
            ctx.font = 'bold 20px "Press Start 2P", monospace';
            ctx.fillText('🌟 MYSTICAL POWERS 🌟', canvas.width / 2, 80);
            
            // Instructions
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 10px "Press Start 2P", monospace';
            ctx.fillText('1-4: Select Element • Q-R: Enchantments • SPACE: Confirm • ESC: Cancel', canvas.width / 2, 105);
            
            // Show current energy
            ctx.fillStyle = '#9932CC';
            ctx.font = 'bold 12px "Press Start 2P", monospace';
            ctx.fillText(`Energy: ${Math.floor(mysticalPowers.mysticalEnergy)}/${mysticalPowers.maxEnergy}`, canvas.width / 2, 125);
            
            // Elements section
            ctx.fillStyle = '#00FFFF';
            ctx.font = 'bold 14px "Press Start 2P", monospace';
            ctx.fillText('ELEMENTAL BALLS', canvas.width / 2, 155);
            
            const elements = Object.keys(mysticalPowers.elementalBalls);
            const startY = 180;
            
            elements.forEach((elementKey, index) => {
                const element = mysticalPowers.elementalBalls[elementKey];
                const y = startY + index * 40;
                const isSelected = mysticalPowers.selectedElement === elementKey;
                const isUnlocked = element.unlocked;
                
                // Selection highlight
                if (isSelected) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.fillRect(canvas.width / 2 - 300, y - 20, 600, 35);
                }
                
                // Element info
                if (isUnlocked) {
                    ctx.fillStyle = isSelected ? '#FFFF00' : element.color;
                    ctx.font = 'bold 12px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${index + 1}. ${element.name}`, canvas.width / 2, y - 5);
                    ctx.font = 'bold 10px "Press Start 2P", monospace';
                    ctx.fillStyle = '#CCCCCC';
                    ctx.fillText(element.description, canvas.width / 2, y + 12);
                } else {
                    ctx.fillStyle = '#666666';
                    ctx.font = 'bold 12px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${index + 1}. 🔒 LOCKED`, canvas.width / 2, y - 5);
                    ctx.font = 'bold 10px "Press Start 2P", monospace';
                    ctx.fillText(`Unlock: ${element.unlockCondition}`, canvas.width / 2, y + 12);
                }
            });
            
            // Enchantments section
            ctx.fillStyle = '#FF69B4';
            ctx.font = 'bold 14px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('ENCHANTMENTS', canvas.width / 2, startY + elements.length * 40 + 50);
            
            // Show available enchantments
            const enchantKeys = Object.keys(mysticalPowers.enchantments);
            enchantKeys.forEach((enchantKey, index) => {
                const enchant = mysticalPowers.enchantments[enchantKey];
                const y = startY + elements.length * 40 + 80 + index * 28;
                const canAfford = mysticalPowers.mysticalEnergy >= enchant.cost;
                
                ctx.fillStyle = canAfford ? '#00FF00' : '#666666';
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
            
                const keyLabel = String.fromCharCode(81 + index); // Q, R, S, T, U
                ctx.fillText(`${keyLabel}. ${enchant.name} (${enchant.cost} energy)`, canvas.width / 2, y);
            });
            
            ctx.restore();
        }
        
        function handleMysticalPowersInput(key) {
            if (!mysticalPowers.menuOpen) return false;
            
            if (key >= '1' && key <= '4') {
                const elementIndex = parseInt(key) - 1;
                const elements = Object.keys(mysticalPowers.elementalBalls);
                if (elementIndex < elements.length) {
                    const elementKey = elements[elementIndex];
                    // Allow selection of any element for preview, even if not unlocked
                    mysticalPowers.selectedElement = elementKey;
                    
                    // Apply the selected element to all existing balls immediately
                    gameState.balls.forEach(ball => {
                        ball.element = elementKey;
                        
                        // Update visual properties and elemental effects
                        if (elementKey !== 'normal' && mysticalPowers.elementalBalls[elementKey]) {
                            const elementData = mysticalPowers.elementalBalls[elementKey];
                            ball.color = elementData.color;
                            ball.trailColor = elementData.trailColor;
                            
                            // Set up elemental effects
                            ball.elementalEffects = {};
                            if (elementKey === 'fire') {
                                ball.elementalEffects.burnRadius = elementData.effects.igniteRadius;
                                ball.elementalEffects.burnDamage = elementData.effects.burnDamage;
                            } else if (elementKey === 'ice') {
                                ball.elementalEffects.freezeRadius = elementData.effects.freezeRadius;
                                ball.elementalEffects.slowFactor = elementData.effects.slowFactor;
                            } else if (elementKey === 'lightning') {
                                ball.elementalEffects.chainRange = elementData.effects.chainRange;
                                ball.elementalEffects.maxChains = elementData.effects.maxChains;
                            } else if (elementKey === 'void') {
                                ball.elementalEffects.phaseChance = elementData.effects.phaseChance;
                                ball.elementalEffects.voidDamage = elementData.effects.voidDamage;
                            }
                        } else {
                            // Reset to normal
                            ball.color = undefined;
                            ball.trailColor = undefined;
                            ball.elementalEffects = {};
                        }
                        console.log(`Applied ${elementKey} element to ball with effects:`, ball.elementalEffects);
                    });
                    
                    // Show feedback
                    const elementData = mysticalPowers.elementalBalls[elementKey];
                    if (elementData) {
                        gameState.feedbackMessages.push({
                            text: `✨ ${elementData.name} Selected!`,
                            x: canvas.width / 2,
                            y: canvas.height / 2 - 50,
                            duration: 1500,
                            fontSize: 12,
                            color: elementData.color || '#FFFFFF',
                            glow: true
                        });
                    }
                }
                return true;
            } else if ((key >= 'Q' && key <= 'U') || (key >= 'q' && key <= 'u')) {
                // Handle enchantment selection (both upper and lower case)
                const upperKey = key.toUpperCase();
                const enchantIndex = upperKey.charCodeAt(0) - 81; // Q=0, R=1, etc.
                const enchantKeys = Object.keys(mysticalPowers.enchantments);
                if (enchantIndex < enchantKeys.length) {
                    const enchantKey = enchantKeys[enchantIndex];
                    console.log(`Attempting to activate enchantment: ${enchantKey}, energy: ${mysticalPowers.mysticalEnergy}`);
                    const success = activateEnchantment(enchantKey);
                    if (!success) {
                        console.log('Enchantment activation failed - insufficient energy');
                    }
                }
                return true;
            } else if (key === 'm' || key === 'M') {
                // Allow M key to close menu (toggle functionality)
                closeMysticalPowersMenu();
                return true;
            } else if (key === ' ') {
                // Confirm selection and close menu
                closeMysticalPowersMenu();
                return true;
            } else if (key === 'Escape') {
                closeMysticalPowersMenu();
                return true;
            }
            
            return false;
        }
        
        function closeMysticalPowersMenu() {
            console.log('Closing mystical powers menu...');
            mysticalPowers.menuOpen = false;
            // Resume game if it was running when menu opened
            if (mysticalPowers.wasGameRunning && gamePaused) {
                gamePaused = false;
                console.log('Mystical powers menu closed - resuming game');
            } else {
                console.log('Game was not running when menu opened, not resuming');
            }
            mysticalPowers.wasGameRunning = false; // Reset flag
        }
        
        function activateEnchantment(enchantKey) {
            const enchant = mysticalPowers.enchantments[enchantKey];
            if (!enchant) {
                console.log(`Enchantment ${enchantKey} not found`);
                return false;
            }
            if (!spendMysticalEnergy(enchant.cost)) {
                console.log(`Not enough energy for ${enchant.name}. Need: ${enchant.cost}, Have: ${mysticalPowers.mysticalEnergy}`);
                return false;
            }
            
            // Add to active enchantments
            mysticalPowers.activeEnchantments.push({
                key: enchantKey,
                name: enchant.name,
                effects: { ...enchant.effects },
                timeRemaining: enchant.duration
            });
            
            // Apply element override to existing balls immediately
            if (enchant.effects && enchant.effects.elementOverride) {
                gameState.balls.forEach(ball => {
                    const newElement = enchant.effects.elementOverride;
                    ball.element = newElement;
                    
                    // Update visual properties AND elemental effects
                    if (newElement !== 'normal' && mysticalPowers.elementalBalls[newElement]) {
                        const elementData = mysticalPowers.elementalBalls[newElement];
                        ball.color = elementData.color;
                        ball.trailColor = elementData.trailColor;
                        
                        // Set up elemental effects for existing balls
                        ball.elementalEffects = {};
                        if (newElement === 'fire') {
                            ball.elementalEffects.burnRadius = elementData.effects.igniteRadius;
                            ball.elementalEffects.burnDamage = elementData.effects.burnDamage;
                        } else if (newElement === 'ice') {
                            ball.elementalEffects.freezeRadius = elementData.effects.freezeRadius;
                            ball.elementalEffects.slowFactor = elementData.effects.slowFactor;
                        } else if (newElement === 'lightning') {
                            ball.elementalEffects.chainRange = elementData.effects.chainRange;
                            ball.elementalEffects.maxChains = elementData.effects.maxChains;
                        } else if (newElement === 'void') {
                            ball.elementalEffects.phaseChance = elementData.effects.phaseChance;
                            ball.elementalEffects.voidDamage = elementData.effects.voidDamage;
                        }
                        console.log(`Applied ${newElement} element to existing ball with effects:`, ball.elementalEffects);
                    }
                });
            }
            
            // Show activation message
            gameState.feedbackMessages.push({
                text: `✨ ${enchant.name} Activated!`,
                x: canvas.width / 2,
                y: canvas.height / 2,
                duration: 2000,
                fontSize: 14,
                color: '#FF69B4',
                glow: true
            });
            
            return true;
        }
        
        function deactivateEnchantment(enchant) {
            // Restore balls to normal element if this was an element override enchantment
            if (enchant.effects && enchant.effects.elementOverride) {
                gameState.balls.forEach(ball => {
                    ball.element = mysticalPowers.selectedElement; // Restore to selected element
                    
                    // Update visual properties
                    if (mysticalPowers.selectedElement !== 'normal' && mysticalPowers.elementalBalls[mysticalPowers.selectedElement]) {
                        const elementData = mysticalPowers.elementalBalls[mysticalPowers.selectedElement];
                        ball.color = elementData.color;
                        ball.trailColor = elementData.trailColor;
                    } else {
                        // Restore to normal ball
                        ball.color = undefined;
                        ball.trailColor = undefined;
                    }
                    console.log(`Restored ball element to ${mysticalPowers.selectedElement}`);
                });
            }
            
            // Show deactivation message
            gameState.feedbackMessages.push({
                text: `${enchant.name} Expired`,
                x: canvas.width / 2,
                y: 100,
                duration: 1500,
                fontSize: 10,
                color: '#888888'
            });
        }

        // ============================
        // PHASE 4: WORLD MAP & ZONE SYSTEM
        // ============================
        
        let worldMapSystem = {
            active: false,
            currentWorld: 1,
            currentZone: 1,
            mapOpen: false,
            unlockedWorlds: [1], // World 1 unlocked by default
            worldProgress: {
                1: { completed: 0, total: 20, unlocked: true },
                2: { completed: 0, total: 20, unlocked: false },
                3: { completed: 0, total: 20, unlocked: false },
                4: { completed: 0, total: 20, unlocked: false },
                5: { completed: 0, total: 20, unlocked: false }
            },
            worlds: {
                1: {
                    name: '🌊 Aquatic Depths',
                    theme: 'water',
                    description: 'Mysterious underwater caverns with flowing currents',
                    backgroundColor: '#001122',
                    primaryColor: '#0077BE',
                    secondaryColor: '#40E0D0',
                    unlockCondition: 'Available from start',
                    mechanics: {
                        waterCurrent: true,
                        bubblesEffect: true,
                        tidalWaves: true
                    },
                    completionReward: {
                        mysticalEnergy: 50,
                        unlockWorld: 2,
                        powerup: 'tidal_force'
                    }
                },
                2: {
                    name: '🔥 Molten Forge',
                    theme: 'fire',
                    description: 'Blazing volcanic chambers with lava flows',
                    backgroundColor: '#330000',
                    primaryColor: '#FF4500',
                    secondaryColor: '#FFD700',
                    unlockCondition: 'Complete Aquatic Depths',
                    mechanics: {
                        lavaRise: true,
                        heatDistortion: true,
                        emberRain: true
                    },
                    completionReward: {
                        mysticalEnergy: 75,
                        unlockWorld: 3,
                        powerup: 'inferno_blast'
                    }
                },
                3: {
                    name: '❄️ Frozen Tundra',
                    theme: 'ice',
                    description: 'Icy wastelands with crystalline formations',
                    backgroundColor: '#001133',
                    primaryColor: '#87CEEB',
                    secondaryColor: '#E0FFFF',
                    unlockCondition: 'Complete Molten Forge',
                    mechanics: {
                        iceSlides: true,
                        frostBreath: true,
                        crystalReflection: true
                    },
                    completionReward: {
                        mysticalEnergy: 100,
                        unlockWorld: 4,
                        powerup: 'arctic_freeze'
                    }
                },
                4: {
                    name: '⚡ Storm Nexus',
                    theme: 'lightning',
                    description: 'Electrified storm clouds and energy conduits',
                    backgroundColor: '#1a0d26',
                    primaryColor: '#FFD700',
                    secondaryColor: '#9370DB',
                    unlockCondition: 'Complete Frozen Tundra',
                    mechanics: {
                        lightningStrikes: true,
                        magneticFields: true,
                        energySurges: true
                    },
                    completionReward: {
                        mysticalEnergy: 150,
                        unlockWorld: 5,
                        powerup: 'storm_lord'
                    }
                },
                5: {
                    name: '🌌 Void Sanctuary',
                    theme: 'void',
                    description: 'Reality-bending dimension beyond comprehension',
                    backgroundColor: '#000000',
                    primaryColor: '#4B0082',
                    secondaryColor: '#9932CC',
                    unlockCondition: 'Complete Storm Nexus',
                    mechanics: {
                        voidTears: true,
                        gravityShifts: true,
                        realityDistortion: true
                    },
                    completionReward: {
                        mysticalEnergy: 200,
                        powerup: 'reality_shaper',
                        finalUnlock: true
                    }
                }
            },
            zoneModifiers: {
                // Each zone within a world can have unique modifiers
                aquatic: [
                    { zone: 1, name: 'Shallow Waters', modifier: { ballSpeed: 0.9, paddleSpeed: 1.1 } },
                    { zone: 5, name: 'Kelp Forest', modifier: { ballBounce: 1.2, visibility: 0.8 } },
                    { zone: 10, name: 'Deep Trench', modifier: { gravity: 1.3, magnetism: true } },
                    { zone: 15, name: 'Coral Reef', modifier: { multiReflection: true, colorShift: true } },
                    { zone: 20, name: 'Abyssal Plain', modifier: { darkness: 0.5, echolocation: true } }
                ],
                fire: [
                    { zone: 1, name: 'Ember Fields', modifier: { ballSpeed: 1.1, burnChance: 0.1 } },
                    { zone: 5, name: 'Lava Tubes', modifier: { bounceHeat: true, meltBlocks: 0.05 } },
                    { zone: 10, name: 'Magma Chamber', modifier: { explosionRadius: 1.5, heatWaves: true } },
                    { zone: 15, name: 'Volcanic Vent', modifier: { upwardForce: true, ashClouds: true } },
                    { zone: 20, name: 'Inferno Core', modifier: { fireImmunity: false, maxHeat: true } }
                ],
                ice: [
                    { zone: 1, name: 'Frost Fields', modifier: { ballSpeed: 0.85, freezeChance: 0.1 } },
                    { zone: 5, name: 'Ice Caverns', modifier: { slippery: true, crystalBounce: 1.3 } },
                    { zone: 10, name: 'Glacier Heart', modifier: { slowTime: 0.8, shatterEffect: true } },
                    { zone: 15, name: 'Blizzard Peak', modifier: { windForce: true, visibility: 0.6 } },
                    { zone: 20, name: 'Absolute Zero', modifier: { freezeAll: true, timeStop: 0.1 } }
                ],
                lightning: [
                    { zone: 1, name: 'Static Fields', modifier: { ballSpeed: 1.2, chainChance: 0.1 } },
                    { zone: 5, name: 'Tesla Coils', modifier: { electricArc: true, conductivity: 1.5 } },
                    { zone: 10, name: 'Storm Eye', modifier: { magneticPull: true, lightningBolts: true } },
                    { zone: 15, name: 'Energy Nexus', modifier: { powerAmplify: 2.0, overcharge: true } },
                    { zone: 20, name: 'Pure Energy', modifier: { phaseShift: true, energyOverload: true } }
                ],
                void: [
                    { zone: 1, name: 'Void Edge', modifier: { ballSpeed: 0.95, phaseChance: 0.05 } },
                    { zone: 5, name: 'Reality Tear', modifier: { gravityShift: true, dimensionSlip: 0.1 } },
                    { zone: 10, name: 'Nexus Point', modifier: { multiDimension: true, voidPull: true } },
                    { zone: 15, name: 'Singularity', modifier: { timeWarp: true, spaceDistortion: true } },
                    { zone: 20, name: 'The Source', modifier: { realityBreak: true, allPowers: true } }
                ]
            }
        };
        
        function initializeWorldMapSystem() {
            worldMapSystem.active = true;
            
            // Load saved world progress
            const savedProgress = localStorage.getItem('world_progress');
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                worldMapSystem.worldProgress = { ...worldMapSystem.worldProgress, ...progress };
                worldMapSystem.unlockedWorlds = Object.keys(worldMapSystem.worldProgress)
                    .filter(world => worldMapSystem.worldProgress[world].unlocked)
                    .map(world => parseInt(world));
                    
                // Set current world to the highest unlocked
                worldMapSystem.currentWorld = Math.max(...worldMapSystem.unlockedWorlds);
            }
            
            // Initialize current zone based on level
            updateCurrentZone();
        }
        
        function updateCurrentZone() {
            // Calculate which zone we're in based on the current level
            // Each world has 20 levels (zones)
            const worldLevels = 20;
            const totalWorlds = 5;
            
            if (level <= worldLevels) {
                worldMapSystem.currentWorld = 1;
                worldMapSystem.currentZone = level;
            } else {
                worldMapSystem.currentWorld = Math.min(Math.ceil(level / worldLevels), totalWorlds);
                worldMapSystem.currentZone = ((level - 1) % worldLevels) + 1;
            }
            
            // Ensure the world is unlocked
            if (!worldMapSystem.unlockedWorlds.includes(worldMapSystem.currentWorld)) {
                // If world isn't unlocked, stay in the highest unlocked world at zone 20
                worldMapSystem.currentWorld = Math.max(...worldMapSystem.unlockedWorlds);
                worldMapSystem.currentZone = 20;
            }
        }
        
        function completeCurrentZone() {
            const world = worldMapSystem.currentWorld;
            const zone = worldMapSystem.currentZone;
            
            // Track zone completion for analytics
            trackZoneCompleted(world, zone);
            
            // Mark zone as completed
            worldMapSystem.worldProgress[world].completed = Math.max(
                worldMapSystem.worldProgress[world].completed,
                zone
            );
            
            // Check if world is completed
            if (worldMapSystem.worldProgress[world].completed >= 20) {
                completeWorld(world);
            }
            
            // Save progress
            saveWorldProgress();
        }
        
        function completeWorld(worldNumber) {
            const world = worldMapSystem.worlds[worldNumber];
            if (!world) return;
            
            // Track world completion for analytics
            trackWorldCompleted(worldNumber, world.name);
            
            // Award completion rewards
            if (world.completionReward.mysticalEnergy) {
                gainMysticalEnergy(world.completionReward.mysticalEnergy);
            }
            
            // Unlock next world
            if (world.completionReward.unlockWorld) {
                const nextWorld = world.completionReward.unlockWorld;
                if (!worldMapSystem.unlockedWorlds.includes(nextWorld)) {
                    worldMapSystem.unlockedWorlds.push(nextWorld);
                    worldMapSystem.worldProgress[nextWorld].unlocked = true;
                    
                    // Show world unlock notification
                    const nextWorldData = worldMapSystem.worlds[nextWorld];
                    gameState.feedbackMessages.push({
                        text: `🌟 NEW WORLD UNLOCKED: ${nextWorldData.name}!`,
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        duration: 5000,
                        fontSize: 18,
                        color: nextWorldData.primaryColor,
                        glow: true
                    });
                }
            }
            
            // Show world completion message
            gameState.feedbackMessages.push({
                text: `✨ ${world.name} COMPLETED! ✨`,
                x: canvas.width / 2,
                y: canvas.height / 2 - 50,
                duration: 4000,
                fontSize: 16,
                color: world.primaryColor,
                glow: true
            });
        }
        
        function saveWorldProgress() {
            localStorage.setItem('world_progress', JSON.stringify(worldMapSystem.worldProgress));
        }
        
        function applyWorldEffects() {
            if (!worldMapSystem.active) return;
            
            const world = worldMapSystem.worlds[worldMapSystem.currentWorld];
            const theme = world.theme;
            
            // Apply world-specific visual effects
            applyWorldVisuals(world);
            
            // Apply zone-specific modifiers
            const zoneData = worldMapSystem.zoneModifiers[theme]?.find(z => z.zone === worldMapSystem.currentZone);
            if (zoneData) {
                applyZoneModifiers(zoneData.modifier);
            }
            
            // Apply world mechanics
            applyWorldMechanics(world.mechanics);
        }
        
        function applyWorldVisuals(world) {
            // Set background colors and gradients
            if (canvas) {
                const canvasContainer = canvas.parentElement;
                if (canvasContainer) {
                    canvasContainer.style.background = `linear-gradient(${world.backgroundColor}, ${world.primaryColor}22)`;
                }
            }
        }
        
        function applyZoneModifiers(modifiers) {
            if (!modifiers) return;
            
            // Apply temporary modifiers to game state
            if (modifiers.ballSpeed) {
                ballSpeed *= modifiers.ballSpeed;
            }
            if (modifiers.paddleSpeed) {
                paddleSpeed *= modifiers.paddleSpeed;
            }
            // Additional modifiers can be applied here
        }
        
        function applyWorldMechanics(mechanics) {
            if (!mechanics) return;
            
            // World-specific gameplay mechanics
            gameState.worldMechanics = {
                waterCurrent: mechanics.waterCurrent,
                lavaRise: mechanics.lavaRise,
                iceSlides: mechanics.iceSlides,
                lightningStrikes: mechanics.lightningStrikes,
                voidTears: mechanics.voidTears,
                // Add more as needed
            };
        }
        
        function updateWorldMechanics(deltaTime) {
            if (!worldMapSystem.active || !gameState.worldMechanics) return;
            
            // Update world-specific mechanics
            if (gameState.worldMechanics.waterCurrent) {
                updateWaterCurrent(deltaTime);
            }
            if (gameState.worldMechanics.lavaRise) {
                updateLavaRise(deltaTime);
            }
            if (gameState.worldMechanics.iceSlides) {
                updateIceSlides(deltaTime);
            }
            if (gameState.worldMechanics.lightningStrikes) {
                updateLightningStrikes(deltaTime);
            }
            if (gameState.worldMechanics.voidTears) {
                updateVoidTears(deltaTime);
            }
        }
        
        // World-specific mechanic implementations
        function updateWaterCurrent(deltaTime) {
            // Apply subtle horizontal force to balls
            gameState.balls.forEach(ball => {
                if (ball.launched) {
                    const currentForce = Math.sin(Date.now() * 0.001) * 0.1;
                    ball.dx += currentForce * (deltaTime / 1000);
                }
            });
        }
        
        function updateLavaRise(deltaTime) {
            // Periodically spawn rising lava particles
            if (Math.random() < 0.02) {
                gameState.particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height,
                    dx: 0,
                    dy: -50,
                    life: 3000,
                    maxLife: 3000,
                    color: '#FF4500',
                    size: 4,
                    type: 'lava'
                });
            }
        }
        
        function updateIceSlides(deltaTime) {
            // Make paddle more slippery
            if (paddle.velocity !== 0) {
                paddle.velocity *= 0.95; // Gradual deceleration
            }
        }
        
        function updateLightningStrikes(deltaTime) {
            // Random lightning strikes that can hit blocks
            if (Math.random() < 0.001) { // 0.1% chance per frame
                const x = Math.random() * canvas.width;
                const y = 50;
                
                // Find blocks near the strike
                blocks.forEach(block => {
                    if (!block.destroyed) {
                        const distance = Math.abs(block.x + block.width/2 - x);
                        if (distance < 50) {
                            // Lightning hit!
                            createLightningStrike(x, y, block.x + block.width/2, block.y + block.height/2);
                            damageBlock(block, 1);
                        }
                    }
                });
            }
        }
        
        function updateVoidTears(deltaTime) {
            // Randomly create void tears that affect ball physics
            if (Math.random() < 0.005) { // 0.5% chance per frame
                const tear = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * 0.6),
                    radius: 20,
                    life: 5000,
                    pullForce: 30
                };
                
                if (!gameState.voidTears) gameState.voidTears = [];
                gameState.voidTears.push(tear);
            }
            
            // Update existing void tears
            if (gameState.voidTears) {
                gameState.voidTears = gameState.voidTears.filter(tear => {
                    tear.life -= deltaTime;
                    
                    // Apply pull force to balls
                    gameState.balls.forEach(ball => {
                        const distance = Math.sqrt(
                            Math.pow(ball.x - tear.x, 2) + 
                            Math.pow(ball.y - tear.y, 2)
                        );
                        
                        if (distance < tear.radius * 3) {
                            const pullX = (tear.x - ball.x) / distance * tear.pullForce * 0.01;
                            const pullY = (tear.y - ball.y) / distance * tear.pullForce * 0.01;
                            ball.dx += pullX;
                            ball.dy += pullY;
                        }
                    });
                    
                    return tear.life > 0;
                });
            }
        }
        
        // World Map UI
        function drawWorldMapHUD() {
            if (!worldMapSystem.active) {
                const worldDisplay = document.getElementById('worldDisplay');
                if (worldDisplay) worldDisplay.style.display = 'none';
                const fsWorldDisplay = document.getElementById('fs-world-display');
                if (fsWorldDisplay) fsWorldDisplay.style.display = 'none';
                return;
            }
            
            // Update windowed world map display
            const worldDisplay = document.getElementById('worldDisplay');
            if (worldDisplay) worldDisplay.style.display = 'block';
            
            const world = worldMapSystem.worlds[worldMapSystem.currentWorld];
            if (world) {
                // Update world name
                const worldName = document.getElementById('worldName');
                if (worldName) {
                    worldName.textContent = world.name;
                    worldName.style.color = world.primaryColor;
                }
                
                // Update zone info
                const worldZone = document.getElementById('worldZone');
                if (worldZone) {
                    worldZone.textContent = `Zone ${worldMapSystem.currentZone}/20`;
                }
                
                // Update progress
                const worldProgress = document.getElementById('worldProgress');
                if (worldProgress) {
                    const completed = worldMapSystem.worldProgress[worldMapSystem.currentWorld].completed;
                    worldProgress.textContent = `Progress: ${completed}/20`;
                }
                
                // Update fullscreen world map display
                if (isFullscreen) {
                    const fsWorldDisplay = document.getElementById('fs-world-display');
                    if (fsWorldDisplay) {
                        fsWorldDisplay.style.display = 'block';
                        
                        // Update fullscreen world name
                        const fsWorldName = document.getElementById('fs-world-name');
                        if (fsWorldName) {
                            fsWorldName.textContent = world.name;
                            fsWorldName.style.color = world.primaryColor;
                        }
                        
                        // Update fullscreen zone info
                        const fsWorldZone = document.getElementById('fs-world-zone');
                        if (fsWorldZone) {
                            fsWorldZone.textContent = `Zone ${worldMapSystem.currentZone}/20`;
                        }
                        
                        // Update fullscreen progress
                        const fsWorldProgress = document.getElementById('fs-world-progress');
                        if (fsWorldProgress) {
                            const completed = worldMapSystem.worldProgress[worldMapSystem.currentWorld].completed;
                            fsWorldProgress.textContent = `Progress: ${completed}/20`;
                        }
                    }
                }
            }
        }
        
        function drawWorldMapOverlay() {
            if (!worldMapSystem.mapOpen) return;
            if (!ctx) return;
            
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.textAlign = 'center';
            
            // Title
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px "Press Start 2P", monospace';
            ctx.fillText('🗺️ WORLD MAP 🗺️', canvas.width / 2, 60);
            
            // Instructions
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 8px "Press Start 2P", monospace';
            ctx.fillText('1-5: Select World • SPACE: Travel • ESC: Close', canvas.width / 2, 85);
            
            // World grid
            const worldsPerRow = 3;
            const worldWidth = 180;
            const worldHeight = 120;
            const spacing = 20;
            const startX = (canvas.width - (worldsPerRow * worldWidth + (worldsPerRow - 1) * spacing)) / 2;
            const startY = 110;
            
            Object.entries(worldMapSystem.worlds).forEach(([worldNum, world], index) => {
                const worldNumber = parseInt(worldNum);
                const row = Math.floor(index / worldsPerRow);
                const col = index % worldsPerRow;
                const x = startX + col * (worldWidth + spacing);
                const y = startY + row * (worldHeight + spacing);
                
                const unlocked = worldMapSystem.unlockedWorlds.includes(worldNumber);
                const current = worldMapSystem.currentWorld === worldNumber;
                const completed = worldMapSystem.worldProgress[worldNumber].completed >= 20;
                
                // World background
                ctx.fillStyle = unlocked ? world.backgroundColor : '#333333';
                ctx.fillRect(x, y, worldWidth, worldHeight);
                
                // World border
                if (current) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                } else if (unlocked) {
                    ctx.strokeStyle = world.primaryColor;
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 1;
                }
                ctx.strokeRect(x, y, worldWidth, worldHeight);
                
                // World name and info
                ctx.fillStyle = unlocked ? world.primaryColor : '#666666';
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${worldNumber}. ${world.name}`, x + worldWidth/2, y + 20);
                
                if (unlocked) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 7px "Press Start 2P", monospace';
                    ctx.fillText(world.description, x + worldWidth/2, y + 35);
                    
                    // Progress
                    const progress = worldMapSystem.worldProgress[worldNumber];
                    ctx.fillText(`${progress.completed}/20 zones`, x + worldWidth/2, y + 55);
                    
                    // Completion status
                    if (completed) {
                        ctx.fillStyle = '#00FF00';
                        ctx.fillText('✓ COMPLETED', x + worldWidth/2, y + 75);
                    } else if (current) {
                        ctx.fillStyle = '#FFFF00';
                        ctx.fillText('◄ CURRENT', x + worldWidth/2, y + 75);
                    }
                } else {
                    ctx.fillStyle = '#666666';
                    ctx.font = 'bold 8px "Press Start 2P", monospace';
                    ctx.fillText('🔒 LOCKED', x + worldWidth/2, y + 40);
                    ctx.font = 'bold 6px "Press Start 2P", monospace';
                    ctx.fillText(world.unlockCondition, x + worldWidth/2, y + 55);
                }
            });
            
            ctx.restore();
        }
        
        function handleWorldMapInput(key) {
            if (!worldMapSystem.mapOpen) return false;
            
            if (key >= '1' && key <= '5') {
                const worldNumber = parseInt(key);
                if (worldMapSystem.unlockedWorlds.includes(worldNumber)) {
                    worldMapSystem.currentWorld = worldNumber;
                    worldMapSystem.currentZone = 1; // Start at zone 1 when switching worlds
                }
                return true;
            } else if (key === ' ') {
                // Travel to selected world
                worldMapSystem.mapOpen = false;
                
                // Restart level in new world
                if (gameRunning) {
                    // Calculate new level based on world and zone
                    const newLevel = (worldMapSystem.currentWorld - 1) * 20 + worldMapSystem.currentZone;
                    level = newLevel;
                    restartLevel();
                }
                return true;
            } else if (key === 'Escape') {
                worldMapSystem.mapOpen = false;
                return true;
            }
            
            return false;
        }

        // ============================
        // PHASE 4: DEEP ANALYTICS & PROGRESSION SYSTEM
        // ============================
        
        let analyticsSystem = {
            active: false,
            profileOpen: false,
            leaderboardOpen: false,
            replayMode: false,
            playerProfile: {
                playerId: null,
                playerName: 'Anonymous',
                accountCreated: null,
                totalPlayTime: 0,
                statistics: {
                    // Game Statistics
                    gamesPlayed: 0,
                    gamesCompleted: 0,
                    totalScore: 0,
                    highestScore: 0,
                    averageScore: 0,
                    totalBlocksDestroyed: 0,
                    totalLivesLost: 0,
                    totalBallsLaunched: 0,
                    
                    // Performance Metrics
                    averageAccuracy: 0,
                    bestCombo: 0,
                    totalCombos: 0,
                    powerupsCollected: 0,
                    bossesDefeated: 0,
                    worldsCompleted: 0,
                    mysticalPowersActivated: 0,
                    achievementsUnlocked: 0,
                    highestLevel: 0,
                    
                    // Time-based Stats
                    fastestLevel: Infinity,
                    longestSurvival: 0,
                    totalGameTime: 0,
                    averageGameTime: 0,
                    
                    // Advanced Analytics
                    heatmapData: {}, // Track where player moves paddle most
                    levelProgression: [], // Track progression through levels
                    deathAnalysis: [], // Track common death causes and locations
                    powerupPreferences: {}, // Track which powerups are used most
                    playPatterns: [], // Track when player plays (time of day, etc.)
                    worldProgress: {}, // Track progress through worlds and zones
                    
                    // Challenge Mode Stats
                    challengeModeStats: {
                        daily: { attempts: 0, completions: 0, bestScore: 0 },
                        survival: { attempts: 0, bestWave: 0, longestTime: 0 },
                        speedrun: { attempts: 0, bestTime: Infinity, completions: 0 },
                        precision: { attempts: 0, bestAccuracy: 0, completions: 0 },
                        chaos: { attempts: 0, completions: 0, bestScore: 0 }
                    },
                    
                    // Elemental Stats
                    elementalStats: {
                        normal: { used: 0, blocksDestroyed: 0, effectiveness: 0 },
                        fire: { used: 0, blocksDestroyed: 0, effectiveness: 0 },
                        ice: { used: 0, blocksDestroyed: 0, effectiveness: 0 },
                        lightning: { used: 0, blocksDestroyed: 0, effectiveness: 0 },
                        void: { used: 0, blocksDestroyed: 0, effectiveness: 0 }
                    }
                },
                achievements: [],
                milestones: [],
                badges: []
            },
            replaySystem: {
                currentReplay: null,
                savedReplays: [],
                maxReplays: 10,
                recording: false,
                playback: false,
                replayData: {
                    gameState: [],
                    inputs: [],
                    metadata: {}
                }
            },
            leaderboards: {
                global: [],
                weekly: [],
                daily: [],
                challengeMode: {},
                worldSpecific: {}
            },
            sessionAnalytics: {
                sessionStart: null,
                currentSession: {
                    startTime: null,
                    endTime: null,
                    gamesPlayed: 0,
                    totalScore: 0,
                    blocksDestroyed: 0,
                    livesLost: 0,
                    powerupsUsed: 0,
                    paddleMovement: [],
                    inputPatterns: []
                }
            }
        };
        
        function initializeAnalyticsSystem() {
            analyticsSystem.active = true;
            
            // Generate or load player ID
            let playerId = localStorage.getItem('player_id');
            if (!playerId) {
                playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('player_id', playerId);
                analyticsSystem.playerProfile.accountCreated = new Date().toISOString();
            }
            analyticsSystem.playerProfile.playerId = playerId;
            
            // Load saved profile data
            loadPlayerProfile();
            
            // Start new session
            startNewSession();
        }
        
        function loadPlayerProfile() {
            const savedProfile = localStorage.getItem('player_profile');
            if (savedProfile) {
                try {
                    const profile = JSON.parse(savedProfile);
                    analyticsSystem.playerProfile = { ...analyticsSystem.playerProfile, ...profile };
                } catch (error) {
                    console.error('Error loading player profile:', error);
                }
            }
        }
        
        function savePlayerProfile() {
            try {
                localStorage.setItem('player_profile', JSON.stringify(analyticsSystem.playerProfile));
            } catch (error) {
                console.error('Error saving player profile:', error);
            }
        }
        
        function startNewSession() {
            analyticsSystem.sessionAnalytics.sessionStart = Date.now();
            analyticsSystem.sessionAnalytics.currentSession = {
                startTime: Date.now(),
                endTime: null,
                gamesPlayed: 0,
                totalScore: 0,
                blocksDestroyed: 0,
                livesLost: 0,
                powerupsUsed: 0,
                paddleMovement: [],
                inputPatterns: []
            };
        }
        
        function endCurrentSession() {
            const session = analyticsSystem.sessionAnalytics.currentSession;
            session.endTime = Date.now();
            
            // Update player profile with session data
            const profile = analyticsSystem.playerProfile;
            profile.statistics.gamesPlayed += session.gamesPlayed;
            profile.statistics.totalScore += session.totalScore;
            profile.statistics.totalBlocksDestroyed += session.blocksDestroyed;
            profile.statistics.totalLivesLost += session.livesLost;
            profile.statistics.powerupsCollected += session.powerupsUsed;
            
            // Calculate session duration and add to total play time
            const sessionDuration = session.endTime - session.startTime;
            profile.totalPlayTime += sessionDuration;
            
            // Save updated profile
            savePlayerProfile();
        }
        
        // Analytics tracking functions
        function trackGameStart() {
            analyticsSystem.sessionAnalytics.currentSession.gamesPlayed++;
            analyticsSystem.playerProfile.statistics.gamesPlayed++;
            
            // Start replay recording if enabled
            if (shouldRecordReplay()) {
                startReplayRecording();
            }
        }
        
        function trackGameEnd(finalScore, level, reason) {
            const session = analyticsSystem.sessionAnalytics.currentSession;
            const profile = analyticsSystem.playerProfile;
            
            // Update session stats
            session.totalScore += finalScore;
            session.endTime = Date.now();
            
            // Update profile stats
            profile.statistics.totalScore += finalScore;
            profile.statistics.highestScore = Math.max(profile.statistics.highestScore, finalScore);
            profile.statistics.averageScore = profile.statistics.totalScore / profile.statistics.gamesPlayed;
            
            // Track completion
            if (reason === 'completed') {
                profile.statistics.gamesCompleted++;
            }
            
            // Calculate game duration
            const gameDuration = Date.now() - session.startTime;
            profile.statistics.totalGameTime += gameDuration;
            profile.statistics.averageGameTime = profile.statistics.totalGameTime / profile.statistics.gamesPlayed;
            
            // Track level progression
            profile.statistics.levelProgression.push({
                timestamp: Date.now(),
                finalLevel: level,
                finalScore: finalScore,
                reason: reason,
                duration: gameDuration
            });
            
            // End replay recording
            if (analyticsSystem.replaySystem.recording) {
                endReplayRecording(finalScore, level, reason);
            }
            
            savePlayerProfile();
        }
        
        function trackBlockDestroyed(blockType, method) {
            const session = analyticsSystem.sessionAnalytics.currentSession;
            const profile = analyticsSystem.playerProfile;
            
            session.blocksDestroyed++;
            profile.statistics.totalBlocksDestroyed++;
            
            // Track elemental effectiveness
            if (method && profile.statistics.elementalStats[method]) {
                profile.statistics.elementalStats[method].blocksDestroyed++;
                profile.statistics.elementalStats[method].effectiveness = 
                    profile.statistics.elementalStats[method].blocksDestroyed / 
                    profile.statistics.elementalStats[method].used;
            }
        }
        
        function trackPowerupUsed(powerupType) {
            const session = analyticsSystem.sessionAnalytics.currentSession;
            const profile = analyticsSystem.playerProfile;
            
            session.powerupsUsed++;
            profile.statistics.powerupsCollected++;
            
            // Track powerup preferences
            if (!profile.statistics.powerupPreferences[powerupType]) {
                profile.statistics.powerupPreferences[powerupType] = 0;
            }
            profile.statistics.powerupPreferences[powerupType]++;
        }
        
        function trackPaddleMovement(x, y) {
            const session = analyticsSystem.sessionAnalytics.currentSession;
            const profile = analyticsSystem.playerProfile;
            
            // Add to current session
            session.paddleMovement.push({ x, y, timestamp: Date.now() });
            
            // Update heatmap data (simplified grid)
            const gridX = Math.floor(x / (canvas.width / 20));
            const gridY = Math.floor(y / (canvas.height / 15));
            const gridKey = `${gridX},${gridY}`;
            
            if (!profile.statistics.heatmapData[gridKey]) {
                profile.statistics.heatmapData[gridKey] = 0;
            }
            profile.statistics.heatmapData[gridKey]++;
        }
        
        function trackCombo(comboSize) {
            const profile = analyticsSystem.playerProfile;
            
            profile.statistics.totalCombos++;
            profile.statistics.bestCombo = Math.max(profile.statistics.bestCombo, comboSize);
        }
        
        function trackBossDefeated(bossType) {
            const profile = analyticsSystem.playerProfile;
            profile.statistics.bossesDefeated++;
        }
        
        function trackWorldCompleted(worldNumber) {
            const profile = analyticsSystem.playerProfile;
            profile.statistics.worldsCompleted++;
        }
        
        function trackMysticalPowersActivated() {
            const profile = analyticsSystem.playerProfile;
            profile.statistics.mysticalPowersActivated++;
        }
        
        function trackChallengeStarted(mode) {
            const profile = analyticsSystem.playerProfile;
            if (!profile.statistics.challengeModeStats[mode]) {
                profile.statistics.challengeModeStats[mode] = { attempts: 0, completions: 0 };
            }
            profile.statistics.challengeModeStats[mode].attempts++;
        }
        
        function trackLevelCompleted(level) {
            const profile = analyticsSystem.playerProfile;
            profile.statistics.highestLevel = Math.max(profile.statistics.highestLevel, level);
        }
        
        function trackAchievementUnlocked(id, name) {
            const profile = analyticsSystem.playerProfile;
            profile.statistics.achievementsUnlocked++;
            profile.milestones.push({
                type: 'achievement',
                name: name,
                timestamp: Date.now()
            });
        }
        
        function trackZoneCompleted(world, zone) {
            const profile = analyticsSystem.playerProfile;
            if (!profile.statistics.worldProgress[world]) {
                profile.statistics.worldProgress[world] = { zonesCompleted: 0 };
            }
            profile.statistics.worldProgress[world].zonesCompleted = Math.max(
                profile.statistics.worldProgress[world].zonesCompleted, 
                zone
            );
        }
        
        // Replay System
        function shouldRecordReplay() {
            // Record replays for notable games (high scores, achievements, etc.)
            return analyticsSystem.replaySystem.savedReplays.length < analyticsSystem.replaySystem.maxReplays;
        }
        
        function startReplayRecording() {
            analyticsSystem.replaySystem.recording = true;
            analyticsSystem.replaySystem.replayData = {
                gameState: [],
                inputs: [],
                metadata: {
                    startTime: Date.now(),
                    playerName: analyticsSystem.playerProfile.playerName,
                    gameVersion: '4.0'
                }
            };
        }
        
        function recordReplayFrame() {
            if (!analyticsSystem.replaySystem.recording) return;
            
            // Record current game state (simplified)
            const state = {
                timestamp: Date.now(),
                level: level,
                score: score,
                lives: lives,
                ballPositions: gameState.balls.map(ball => ({ x: ball.x, y: ball.y, dx: ball.dx, dy: ball.dy })),
                paddlePosition: { x: paddle.x, y: paddle.y },
                blockStates: blocks.map(block => ({ 
                    x: block.x, y: block.y, destroyed: block.destroyed, health: block.health 
                }))
            };
            
            analyticsSystem.replaySystem.replayData.gameState.push(state);
        }
        
        function recordReplayInput(inputType, data) {
            if (!analyticsSystem.replaySystem.recording) return;
            
            analyticsSystem.replaySystem.replayData.inputs.push({
                timestamp: Date.now(),
                type: inputType,
                data: data
            });
        }
        
        function endReplayRecording(finalScore, level, reason) {
            if (!analyticsSystem.replaySystem.recording) return;
            
            analyticsSystem.replaySystem.recording = false;
            
            const replay = {
                id: Date.now(),
                metadata: {
                    ...analyticsSystem.replaySystem.replayData.metadata,
                    endTime: Date.now(),
                    finalScore: finalScore,
                    finalLevel: level,
                    reason: reason
                },
                data: analyticsSystem.replaySystem.replayData
            };
            
            // Save replay if it's noteworthy
            if (isNoteworthyReplay(replay)) {
                analyticsSystem.replaySystem.savedReplays.push(replay);
                
                // Remove oldest replay if at capacity
                if (analyticsSystem.replaySystem.savedReplays.length > analyticsSystem.replaySystem.maxReplays) {
                    analyticsSystem.replaySystem.savedReplays.shift();
                }
                
                // Save replays to localStorage
                saveReplays();
            }
        }
        
        function isNoteworthyReplay(replay) {
            const profile = analyticsSystem.playerProfile;
            
            // High score
            if (replay.metadata.finalScore >= profile.statistics.highestScore * 0.8) return true;
            
            // High level reached
            if (replay.metadata.finalLevel >= 50) return true;
            
            // Game completed
            if (replay.metadata.reason === 'completed') return true;
            
            // Boss defeated
            if (replay.metadata.finalLevel % 25 === 0) return true;
            
            return false;
        }
        
        function saveReplays() {
            try {
                localStorage.setItem('game_replays', JSON.stringify(analyticsSystem.replaySystem.savedReplays));
            } catch (error) {
                console.error('Error saving replays:', error);
            }
        }
        
        function loadReplays() {
            try {
                const saved = localStorage.getItem('game_replays');
                if (saved) {
                    analyticsSystem.replaySystem.savedReplays = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading replays:', error);
            }
        }
        
        // Achievement and Milestone System
        function checkMilestones() {
            const profile = analyticsSystem.playerProfile;
            const stats = profile.statistics;
            
            const milestones = [
                { id: 'first_game', name: 'First Steps', condition: () => stats.gamesPlayed >= 1, reward: 'Welcome Badge' },
                { id: 'score_1000', name: 'Rising Star', condition: () => stats.highestScore >= 1000, reward: '10 Mystical Energy' },
                { id: 'score_10000', name: 'High Achiever', condition: () => stats.highestScore >= 10000, reward: '25 Mystical Energy' },
                { id: 'score_100000', name: 'Score Master', condition: () => stats.highestScore >= 100000, reward: '50 Mystical Energy' },
                { id: 'blocks_1000', name: 'Destroyer', condition: () => stats.totalBlocksDestroyed >= 1000, reward: 'Fire Element Unlock' },
                { id: 'blocks_5000', name: 'Demolition Expert', condition: () => stats.totalBlocksDestroyed >= 5000, reward: 'Lightning Element Unlock' },
                { id: 'games_10', name: 'Dedicated Player', condition: () => stats.gamesPlayed >= 10, reward: 'Persistence Badge' },
                { id: 'games_50', name: 'Veteran', condition: () => stats.gamesPlayed >= 50, reward: 'Veteran Badge' },
                { id: 'games_100', name: 'Master Player', condition: () => stats.gamesPlayed >= 100, reward: 'Master Badge' },
                { id: 'playtime_1hour', name: 'Time Investment', condition: () => profile.totalPlayTime >= 3600000, reward: 'Time Badge' },
                { id: 'combo_50', name: 'Combo King', condition: () => stats.bestCombo >= 50, reward: 'Combo Master Badge' },
                { id: 'boss_5', name: 'Boss Hunter', condition: () => stats.bossesDefeated >= 5, reward: 'Boss Slayer Badge' },
                { id: 'world_complete', name: 'World Traveler', condition: () => stats.worldsCompleted >= 1, reward: 'Explorer Badge' }
            ];
            
            milestones.forEach(milestone => {
                if (!profile.milestones.includes(milestone.id) && milestone.condition()) {
                    profile.milestones.push(milestone.id);
                    showMilestoneUnlock(milestone);
                    awardMilestoneReward(milestone.reward);
                }
            });
        }
        
        function showMilestoneUnlock(milestone) {
            gameState.feedbackMessages.push({
                text: `🏆 MILESTONE: ${milestone.name}!`,
                x: canvas.width / 2,
                y: canvas.height / 2,
                duration: 4000,
                fontSize: 16,
                color: '#FFD700',
                glow: true
            });
        }
        
        function awardMilestoneReward(reward) {
            if (reward.includes('Mystical Energy')) {
                const amount = parseInt(reward.match(/\d+/)[0]);
                gainMysticalEnergy(amount);
            } else if (reward.includes('Element Unlock')) {
                // Handle element unlocks
            }
            // Add more reward types as needed
        }
        
        // Analytics UI Functions
        function drawPlayerProfileOverlay() {
            if (!analyticsSystem.profileOpen) return;
            if (!ctx) return;
            
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.textAlign = 'center';
            
            // Title
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#00FFFF';
            ctx.font = 'bold 20px "Press Start 2P", monospace';
            ctx.fillText('📊 PLAYER PROFILE 📊', canvas.width / 2, 60);
            
            // Player info
            const profile = analyticsSystem.playerProfile;
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 12px "Press Start 2P", monospace';
            ctx.fillText(`Player: ${profile.playerName}`, canvas.width / 2, 90);
            
            if (profile.accountCreated) {
                const created = new Date(profile.accountCreated).toLocaleDateString();
                ctx.font = 'bold 8px "Press Start 2P", monospace';
                ctx.fillText(`Account Created: ${created}`, canvas.width / 2, 105);
            }
            
            // Play time
            const hours = Math.floor(profile.totalPlayTime / 3600000);
            const minutes = Math.floor((profile.totalPlayTime % 3600000) / 60000);
            ctx.fillText(`Total Play Time: ${hours}h ${minutes}m`, canvas.width / 2, 120);
            
            // Statistics in columns
            const stats = profile.statistics;
            const leftX = canvas.width / 4;
            const rightX = (canvas.width * 3) / 4;
            let leftY = 150;
            let rightY = 150;
            const lineHeight = 20;
            
            ctx.textAlign = 'left';
            ctx.font = 'bold 8px "Press Start 2P", monospace';
            
            // Left column - Game Stats
            ctx.fillStyle = '#FFD700';
            ctx.fillText('GAME STATISTICS', leftX - 50, leftY);
            leftY += lineHeight;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(`Games Played: ${stats.gamesPlayed}`, leftX - 50, leftY);
            leftY += 15;
            ctx.fillText(`Games Completed: ${stats.gamesCompleted}`, leftX - 50, leftY);
            leftY += 15;
            ctx.fillText(`Highest Score: ${stats.highestScore.toLocaleString()}`, leftX - 50, leftY);
            leftY += 15;
            ctx.fillText(`Average Score: ${Math.round(stats.averageScore).toLocaleString()}`, leftX - 50, leftY);
            leftY += 15;
            ctx.fillText(`Blocks Destroyed: ${stats.totalBlocksDestroyed.toLocaleString()}`, leftX - 50, leftY);
            leftY += 15;
            ctx.fillText(`Lives Lost: ${stats.totalLivesLost}`, leftX - 50, leftY);
            leftY += 15;
            ctx.fillText(`Powerups Collected: ${stats.powerupsCollected}`, leftX - 50, leftY);
            
            // Right column - Performance Stats
            ctx.fillStyle = '#FFD700';
            ctx.fillText('PERFORMANCE', rightX - 50, rightY);
            rightY += lineHeight;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(`Best Combo: ${stats.bestCombo}`, rightX - 50, rightY);
            rightY += 15;
            ctx.fillText(`Total Combos: ${stats.totalCombos}`, rightX - 50, rightY);
            rightY += 15;
            ctx.fillText(`Bosses Defeated: ${stats.bossesDefeated}`, rightX - 50, rightY);
            rightY += 15;
            ctx.fillText(`Worlds Completed: ${stats.worldsCompleted}`, rightX - 50, rightY);
            rightY += 15;
            
            const avgGameTimeMin = Math.floor(stats.averageGameTime / 60000);
            const avgGameTimeSec = Math.floor((stats.averageGameTime % 60000) / 1000);
            ctx.fillText(`Avg Game Time: ${avgGameTimeMin}:${avgGameTimeSec.toString().padStart(2, '0')}`, rightX - 50, rightY);
            
            // Milestones section
            if (profile.milestones.length > 0) {
                ctx.fillStyle = '#FFD700';
                ctx.textAlign = 'center';
                ctx.fillText('MILESTONES ACHIEVED', canvas.width / 2, rightY + 40);
                
                ctx.fillStyle = '#00FF00';
                ctx.font = 'bold 7px "Press Start 2P", monospace';
                profile.milestones.slice(0, 10).forEach((milestone, index) => {
                    const row = Math.floor(index / 2);
                    const col = index % 2;
                    const x = canvas.width / 2 + (col === 0 ? -100 : 100);
                    const y = rightY + 60 + row * 15;
                    ctx.fillText(`✓ ${milestone.replace('_', ' ').toUpperCase()}`, x, y);
                });
            }
            
            // Instructions
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 8px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('ESC: Close • R: View Replays', canvas.width / 2, canvas.height - 40);
            
            ctx.restore();
        }
        
        function drawReplayBrowser() {
            if (!analyticsSystem.replaySystem.playback) return;
            if (!ctx) return;
            
            // Simple replay browser overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.textAlign = 'center';
            
            // Title
            ctx.shadowColor = '#FF69B4';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#FF69B4';
            ctx.font = 'bold 18px "Press Start 2P", monospace';
            ctx.fillText('🎬 REPLAY BROWSER 🎬', canvas.width / 2, 60);
            
            // Replay list
            const replays = analyticsSystem.replaySystem.savedReplays;
            if (replays.length === 0) {
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px "Press Start 2P", monospace';
                ctx.fillText('No replays available', canvas.width / 2, canvas.height / 2);
            } else {
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'left';
                
                replays.slice(0, 8).forEach((replay, index) => {
                    const y = 100 + index * 30;
                    const date = new Date(replay.metadata.endTime).toLocaleDateString();
                    const score = replay.metadata.finalScore.toLocaleString();
                    const level = replay.metadata.finalLevel;
                    
                    ctx.fillText(`${index + 1}. ${date} | Score: ${score} | Level: ${level}`, 50, y);
                });
            }
            
            // Instructions
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 8px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('1-8: Select Replay • SPACE: Play • ESC: Close', canvas.width / 2, canvas.height - 40);
            
            ctx.restore();
        }
        
        function handleAnalyticsInput(key) {
            if (analyticsSystem.profileOpen) {
                if (key === 'Escape') {
                    analyticsSystem.profileOpen = false;
                    return true;
                } else if (key === 'r' || key === 'R') {
                    analyticsSystem.profileOpen = false;
                    analyticsSystem.replaySystem.playback = true;
                    return true;
                }
            } else if (analyticsSystem.replaySystem.playback) {
                if (key === 'Escape') {
                    analyticsSystem.replaySystem.playback = false;
                    return true;
                } else if (key >= '1' && key <= '8') {
                    const replaytIndex = parseInt(key) - 1;
                    const replays = analyticsSystem.replaySystem.savedReplays;
                    if (replayIndex < replays.length) {
                        // Start replay playback (simplified implementation)
                        analyticsSystem.replaySystem.currentReplay = replays[replayIndex];
                        analyticsSystem.replaySystem.playback = false;
                        // Note: Full replay implementation would require more complex state management
                    }
                    return true;
                }
            }
            
            return false;
        }
        
        function updateAnalyticsSystem(deltaTime) {
            if (!analyticsSystem.active) return;
            
            // Record replay frame if recording
            if (analyticsSystem.replaySystem.recording && Math.random() < 0.1) { // Record 10% of frames
                recordReplayFrame();
            }
            
            // Periodically check milestones
            if (Math.random() < 0.01) { // Check occasionally
                checkMilestones();
            }
            
            // Track paddle movement occasionally
            if (gameState.paddle && Math.random() < 0.05) { // Track 5% of frames
                trackPaddleMovement(paddle.x, paddle.y);
            }
        }

        let bossSystem = {
            active: false,
            currentBoss: null,
            phase: 1,
            maxPhases: 3,
            phaseTransitionTimer: 0,
            regenerationTimer: 0,
            nextRegeneration: 0,
            bossBlocks: [],
            originalBossBlocks: [], // For regeneration
            attackTimer: 0,
            nextAttack: 0,
            specialAttackCooldown: 0,
            bossHealthBar: { current: 0, max: 0 },
            defeated: false,
            rewards: { score: 0, lives: 0, powerups: [] }
        };

        // Boss definitions for milestone levels
        const bossDefinitions = {
            25: { // The Fortress
                name: "The Fortress",
                description: "Multi-layered regenerating shields",
                icon: "🏰",
                color: "#8B4513",
                glowColor: "#FF6347",
                maxHealth: 150,
                phases: [
                    {
                        name: "Outer Walls",
                        regenerationRate: 30000, // 30 seconds
                        regenerationCount: 2,
                        pattern: "fortress_outer"
                    },
                    {
                        name: "Inner Keep",
                        regenerationRate: 20000, // 20 seconds
                        regenerationCount: 1,
                        pattern: "fortress_inner"
                    },
                    {
                        name: "Core Chamber",
                        regenerationRate: 15000, // 15 seconds
                        regenerationCount: 3,
                        pattern: "fortress_core"
                    }
                ],
                rewards: { score: 50000, lives: 2, powerups: ['multi_ball', 'expand_paddle'] }
            },
            50: { // The Swarm
                name: "The Swarm",
                description: "Mobile enemy blocks that reorganize",
                icon: "🌀",
                color: "#FF1493",
                glowColor: "#FF69B4",
                maxHealth: 200,
                phases: [
                    {
                        name: "Scout Formation",
                        moveSpeed: 0.5,
                        reorganizeTimer: 8000, // 8 seconds
                        pattern: "swarm_scouts"
                    },
                    {
                        name: "Attack Swarm",
                        moveSpeed: 1.0,
                        reorganizeTimer: 6000, // 6 seconds
                        pattern: "swarm_attack"
                    },
                    {
                        name: "Queen's Guard",
                        moveSpeed: 1.5,
                        reorganizeTimer: 4000, // 4 seconds
                        pattern: "swarm_queen"
                    }
                ],
                rewards: { score: 75000, lives: 3, powerups: ['laser_paddle', 'slow_ball'] }
            },
            75: { // The Void Titan
                name: "The Void Titan",
                description: "Creates ball-eating void zones",
                icon: "🕳️",
                color: "#4B0082",
                glowColor: "#9400D3",
                maxHealth: 300,
                phases: [
                    {
                        name: "Void Awakening",
                        voidZones: 2,
                        voidGrowthRate: 0.3,
                        pattern: "void_awakening"
                    },
                    {
                        name: "Reality Tear",
                        voidZones: 4,
                        voidGrowthRate: 0.5,
                        pattern: "void_tear"
                    },
                    {
                        name: "Dimensional Collapse",
                        voidZones: 6,
                        voidGrowthRate: 0.8,
                        pattern: "void_collapse"
                    }
                ],
                rewards: { score: 100000, lives: 4, powerups: ['sticky_paddle', 'combo_multiplier'] }
            },
            100: { // The Master Core
                name: "The Master Core",
                description: "Combines all boss mechanics",
                icon: "👑",
                color: "#FFD700",
                glowColor: "#FFA500",
                maxHealth: 500,
                phases: [
                    {
                        name: "Adaptive Defense",
                        regenerationRate: 10000,
                        regenerationCount: 2,
                        moveSpeed: 0.8,
                        pattern: "master_defense"
                    },
                    {
                        name: "Chaos Protocol",
                        voidZones: 3,
                        voidGrowthRate: 0.4,
                        moveSpeed: 1.2,
                        reorganizeTimer: 5000,
                        pattern: "master_chaos"
                    },
                    {
                        name: "Final Form",
                        regenerationRate: 8000,
                        regenerationCount: 4,
                        voidZones: 8,
                        voidGrowthRate: 1.0,
                        moveSpeed: 2.0,
                        reorganizeTimer: 3000,
                        pattern: "master_final"
                    }
                ],
                rewards: { score: 250000, lives: 5, powerups: ['all_powerups'] }
            }
        };

        // Boss block patterns
        function generateBossPattern(patternName, bossLevel) {
            const patterns = {
                // Level 25 - The Fortress patterns
                fortress_outer: () => {
                    const pattern = [];
                    // Outer fortress walls
                    for (let row = 2; row < 8; row++) {
                        for (let col = 2; col < 18; col++) {
                            if (row === 2 || row === 7 || col === 2 || col === 17) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_wall',
                                    hits: 3,
                                    maxHits: 3,
                                    regenerable: true
                                });
                            }
                        }
                    }
                    return pattern;
                },
                fortress_inner: () => {
                    const pattern = [];
                    // Inner keep structure
                    for (let row = 3; row < 7; row++) {
                        for (let col = 4; col < 16; col++) {
                            if (row === 3 || row === 6 || col === 4 || col === 15 || 
                                (row === 4 && (col === 6 || col === 8 || col === 11 || col === 13))) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_wall',
                                    hits: 2,
                                    maxHits: 2,
                                    regenerable: true
                                });
                            }
                        }
                    }
                    return pattern;
                },
                fortress_core: () => {
                    const pattern = [];
                    // Core chamber with heavy protection
                    for (let row = 4; row < 6; row++) {
                        for (let col = 8; col < 12; col++) {
                            pattern.push({
                                x: col * 40 + 20,
                                y: row * 25 + 50,
                                width: 38,
                                height: 23,
                                type: 'boss_core',
                                hits: 5,
                                maxHits: 5,
                                regenerable: true
                            });
                        }
                    }
                    return pattern;
                },
                // Level 50 - The Swarm patterns
                swarm_scouts: () => {
                    const pattern = [];
                    // Scout formation - scattered mobile blocks
                    const positions = [
                        {x: 3, y: 2}, {x: 7, y: 3}, {x: 11, y: 2}, {x: 15, y: 3},
                        {x: 2, y: 5}, {x: 6, y: 6}, {x: 12, y: 5}, {x: 16, y: 6}
                    ];
                    positions.forEach(pos => {
                        pattern.push({
                            x: pos.x * 40 + 20,
                            y: pos.y * 25 + 50,
                            width: 38,
                            height: 23,
                            type: 'boss_swarm',
                            hits: 2,
                            maxHits: 2,
                            mobile: true,
                            originalX: pos.x * 40 + 20,
                            originalY: pos.y * 25 + 50
                        });
                    });
                    return pattern;
                },
                swarm_attack: () => {
                    const pattern = [];
                    // Attack formation - tighter formation
                    for (let row = 3; row < 6; row++) {
                        for (let col = 6; col < 14; col++) {
                            if ((row + col) % 2 === 0) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_swarm',
                                    hits: 3,
                                    maxHits: 3,
                                    mobile: true,
                                    originalX: col * 40 + 20,
                                    originalY: row * 25 + 50
                                });
                            }
                        }
                    }
                    return pattern;
                },
                swarm_queen: () => {
                    const pattern = [];
                    // Queen's guard - central protection
                    const centerX = 10, centerY = 4;
                    for (let angle = 0; angle < 360; angle += 45) {
                        const radian = angle * Math.PI / 180;
                        const x = centerX + Math.cos(radian) * 3;
                        const y = centerY + Math.sin(radian) * 2;
                        pattern.push({
                            x: x * 40 + 20,
                            y: y * 25 + 50,
                            width: 38,
                            height: 23,
                            type: 'boss_queen',
                            hits: 4,
                            maxHits: 4,
                            mobile: true,
                            originalX: x * 40 + 20,
                            originalY: y * 25 + 50
                        });
                    }
                    return pattern;
                },
                // Level 75 - The Void Titan patterns
                void_awakening: () => {
                    const pattern = [];
                    // Initial void barriers
                    for (let row = 2; row < 8; row++) {
                        for (let col = 1; col < 19; col++) {
                            if (col === 1 || col === 18 || row === 2 || row === 7 ||
                                (row === 4 && col >= 8 && col <= 12)) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_void',
                                    hits: 3,
                                    maxHits: 3,
                                    voidGenerator: col >= 8 && col <= 12 && row === 4
                                });
                            }
                        }
                    }
                    return pattern;
                },
                void_tear: () => {
                    const pattern = [];
                    // More void generators
                    for (let row = 3; row < 7; row++) {
                        for (let col = 3; col < 17; col++) {
                            if ((row === 3 || row === 6) && col % 3 === 0) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_void',
                                    hits: 4,
                                    maxHits: 4,
                                    voidGenerator: true
                                });
                            }
                        }
                    }
                    return pattern;
                },
                void_collapse: () => {
                    const pattern = [];
                    // Maximum void chaos
                    for (let row = 2; row < 8; row++) {
                        for (let col = 2; col < 18; col++) {
                            if ((row + col) % 4 === 0) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_void_core',
                                    hits: 5,
                                    maxHits: 5,
                                    voidGenerator: true
                                });
                            }
                        }
                    }
                    return pattern;
                },
                // Level 100 - Master Core patterns
                master_defense: () => {
                    const pattern = [];
                    // Adaptive defensive formation
                    for (let row = 2; row < 8; row++) {
                        for (let col = 4; col < 16; col++) {
                            if ((row % 2 === 0 && col % 3 === 1) || 
                                (row % 2 === 1 && col % 3 === 2)) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_master',
                                    hits: 4,
                                    maxHits: 4,
                                    regenerable: true,
                                    mobile: true,
                                    originalX: col * 40 + 20,
                                    originalY: row * 25 + 50
                                });
                            }
                        }
                    }
                    return pattern;
                },
                master_chaos: () => {
                    const pattern = [];
                    // Chaos with mobility and void
                    for (let row = 3; row < 7; row++) {
                        for (let col = 5; col < 15; col++) {
                            if (Math.random() < 0.6) {
                                pattern.push({
                                    x: col * 40 + 20,
                                    y: row * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_master',
                                    hits: 5,
                                    maxHits: 5,
                                    mobile: true,
                                    voidGenerator: Math.random() < 0.3,
                                    originalX: col * 40 + 20,
                                    originalY: row * 25 + 50
                                });
                            }
                        }
                    }
                    return pattern;
                },
                master_final: () => {
                    const pattern = [];
                    // Ultimate final form
                    const centerX = 10, centerY = 5;
                    for (let layer = 1; layer <= 3; layer++) {
                        for (let angle = 0; angle < 360; angle += 30) {
                            const radian = angle * Math.PI / 180;
                            const x = centerX + Math.cos(radian) * layer * 2;
                            const y = centerY + Math.sin(radian) * layer;
                            if (x >= 2 && x <= 18 && y >= 2 && y <= 8) {
                                pattern.push({
                                    x: x * 40 + 20,
                                    y: y * 25 + 50,
                                    width: 38,
                                    height: 23,
                                    type: 'boss_final',
                                    hits: 6,
                                    maxHits: 6,
                                    regenerable: true,
                                    mobile: true,
                                    voidGenerator: layer === 1,
                                    originalX: x * 40 + 20,
                                    originalY: y * 25 + 50
                                });
                            }
                        }
                    }
                    return pattern;
                }
            };
            
            return patterns[patternName] ? patterns[patternName]() : [];
        }

        // Check if current level is a boss level
        function isBossLevel(level) {
            return [25, 50, 75, 100].includes(level);
        }

        // Initialize boss battle
        function initializeBoss(level) {
            if (!isBossLevel(level)) return false;
            
            const bossDef = bossDefinitions[level];
            if (!bossDef) return false;
            
            bossSystem.active = true;
            bossSystem.currentBoss = {...bossDef, bossLevel: level};
            bossSystem.phase = 1;
            bossSystem.defeated = false;
            bossSystem.bossHealthBar.max = bossDef.maxHealth;
            bossSystem.bossHealthBar.current = bossDef.maxHealth;
            bossSystem.regenerationTimer = 0;
            bossSystem.attackTimer = 0;
            bossSystem.specialAttackCooldown = 0;
            
            // Create initial boss blocks
            createBossPhase(level, 1);
            
            // Show boss introduction
            showBossIntroduction(bossDef);
            
            return true;
        }

        // Create blocks for specific boss phase
        function createBossPhase(level, phase) {
            const bossDef = bossDefinitions[level];
            if (!bossDef || !bossDef.phases || !Array.isArray(bossDef.phases) || !bossDef.phases[phase - 1]) return;
            
            const phaseData = bossDef.phases[phase - 1];
            const pattern = generateBossPattern(phaseData.pattern, level);
            
            // Clear existing boss blocks
            bossSystem.bossBlocks = [];
            bossSystem.originalBossBlocks = [];
            
            // Create boss blocks
            pattern.forEach(blockData => {
                const block = {
                    ...blockData,
                    color: bossDef.color,
                    glowColor: bossDef.glowColor,
                    isBoss: true,
                    bossLevel: level,
                    phase: phase
                };
                
                bossSystem.bossBlocks.push(block);
                bossSystem.originalBossBlocks.push({...block});
            });
            
            // Add boss blocks to main blocks array
            blocks.push(...bossSystem.bossBlocks);
            
            // Set phase-specific timers
            if (phaseData.regenerationRate) {
                bossSystem.nextRegeneration = Date.now() + phaseData.regenerationRate;
            }
            if (phaseData.reorganizeTimer) {
                bossSystem.nextAttack = Date.now() + phaseData.reorganizeTimer;
            }
        }

        // Update boss battle mechanics
        function updateBossSystem(deltaTime) {
            if (!bossSystem.active || !bossSystem.currentBoss) return;
            
            const now = Date.now();
            const bossDef = bossSystem.currentBoss;
            if (!bossDef || !bossDef.phases || !Array.isArray(bossDef.phases) || !bossDef.phases[bossSystem.phase - 1]) return;
            const currentPhase = bossDef.phases[bossSystem.phase - 1];
            
            // Update boss health based on destroyed blocks
            const remainingBossBlocks = blocks.filter(block => block.isBoss);
            const destroyedBlocks = bossSystem.bossBlocks.length - remainingBossBlocks.length;
            bossSystem.bossHealthBar.current = Math.max(0, 
                bossSystem.bossHealthBar.max - (destroyedBlocks * 10));
            
            // Handle regeneration
            if (currentPhase.regenerationRate && now >= bossSystem.nextRegeneration) {
                regenerateBossBlocks(currentPhase);
                bossSystem.nextRegeneration = now + currentPhase.regenerationRate;
            }
            
            // Handle mobile blocks
            if (currentPhase.moveSpeed) {
                updateMobileBossBlocks(currentPhase.moveSpeed, deltaTime);
            }
            
            // Handle reorganization
            if (currentPhase.reorganizeTimer && now >= bossSystem.nextAttack) {
                reorganizeBossBlocks();
                bossSystem.nextAttack = now + currentPhase.reorganizeTimer;
            }
            
            // Handle void zones
            if (currentPhase.voidZones) {
                updateVoidZones(currentPhase, deltaTime);
            }
            
            // Check for phase transition
            if (remainingBossBlocks.length === 0) {
                if (bossSystem.phase < bossSystem.maxPhases) {
                    transitionBossPhase();
                } else {
                    defeatBoss();
                }
            }
        }

        // Regenerate some boss blocks
        function regenerateBossBlocks(phaseData) {
            const destroyedBlocks = bossSystem.originalBossBlocks.filter(original => 
                !blocks.some(current => current.x === original.x && current.y === original.y && current.isBoss)
            );
            
            if (destroyedBlocks.length === 0) return;
            
            const regenCount = Math.min(phaseData.regenerationCount || 1, destroyedBlocks.length);
            const toRegenerate = destroyedBlocks.slice(0, regenCount);
            
            toRegenerate.forEach(blockData => {
                const newBlock = {...blockData, regenerating: true, regenStartTime: Date.now()};
                blocks.push(newBlock);
                bossSystem.bossBlocks.push(newBlock);
            });
            
            // Show regeneration effect
            showBossRegenerationEffect(toRegenerate);
        }

        // Update mobile boss blocks
        function updateMobileBossBlocks(moveSpeed, deltaTime) {
            const mobileBlocks = blocks.filter(block => block.isBoss && block.mobile);
            
            mobileBlocks.forEach(block => {
                if (!block.moveDirection) {
                    block.moveDirection = Math.random() * Math.PI * 2;
                    block.moveTimer = 0;
                }
                
                block.moveTimer += deltaTime;
                if (block.moveTimer > 2000) { // Change direction every 2 seconds
                    block.moveDirection = Math.random() * Math.PI * 2;
                    block.moveTimer = 0;
                }
                
                const moveX = Math.cos(block.moveDirection) * moveSpeed;
                const moveY = Math.sin(block.moveDirection) * moveSpeed;
                
                // Move with boundary checking
                const newX = block.x + moveX;
                const newY = block.y + moveY;
                
                if (newX > 20 && newX < canvas.width - 60) {
                    block.x = newX;
                }
                if (newY > 80 && newY < 300) {
                    block.y = newY;
                }
            });
        }

        // Reorganize boss blocks into new formations
        function reorganizeBossBlocks() {
            const mobileBlocks = blocks.filter(block => block.isBoss && block.mobile);
            if (mobileBlocks.length === 0) return;
            
            // Create new formation
            const formations = ['circle', 'line', 'triangle', 'diamond'];
            const formation = formations.length > 0 ? formations[Math.floor(Math.random() * formations.length)] : 'circle';
            
            reorganizeToFormation(mobileBlocks, formation);
        }

        // Reorganize blocks into specific formation
        function reorganizeToFormation(blocks, formation) {
            const centerX = canvas.width / 2;
            const centerY = 200;
            
            blocks.forEach((block, index) => {
                let targetX, targetY;
                
                switch (formation) {
                    case 'circle':
                        const angle = (index / blocks.length) * Math.PI * 2;
                        targetX = centerX + Math.cos(angle) * 100;
                        targetY = centerY + Math.sin(angle) * 50;
                        break;
                    case 'line':
                        targetX = centerX - (blocks.length * 20) + (index * 40);
                        targetY = centerY;
                        break;
                    case 'triangle':
                        const row = Math.floor(Math.sqrt(index * 2));
                        const posInRow = index - (row * (row + 1)) / 2;
                        targetX = centerX - (row * 20) + (posInRow * 40);
                        targetY = centerY - (row * 30);
                        break;
                    case 'diamond':
                        const side = Math.floor(index / 4);
                        const posOnSide = index % 4;
                        const diamond_angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                        const diamond_angle = diamond_angles[posOnSide];
                        targetX = centerX + Math.cos(diamond_angle) * (50 + side * 30);
                        targetY = centerY + Math.sin(diamond_angle) * (25 + side * 15);
                        break;
                    default:
                        targetX = block.x;
                        targetY = block.y;
                }
                
                // Animate to new position
                block.targetX = targetX;
                block.targetY = targetY;
                block.isReorganizing = true;
                block.reorganizeStartTime = Date.now();
            });
        }

        // Update void zones for void titan boss
        let voidZones = [];
        
        function updateVoidZones(phaseData, deltaTime) {
            // Create void zones if needed
            while (voidZones.length < phaseData.voidZones) {
                createVoidZone();
            }
            
            // Update existing void zones
            voidZones.forEach(zone => {
                if (zone.growing) {
                    zone.radius += phaseData.voidGrowthRate;
                    if (zone.radius > zone.maxRadius) {
                        zone.growing = false;
                        zone.shrinking = true;
                    }
                } else if (zone.shrinking) {
                    zone.radius -= phaseData.voidGrowthRate * 0.5;
                    if (zone.radius <= 10) {
                        zone.radius = 10;
                        zone.shrinking = false;
                        zone.growing = true;
                    }
                }
                
                // Check for ball collisions with void zones
                gameState.balls.forEach((ball, ballIndex) => {
                    const dx = ball.x - zone.x;
                    const dy = ball.y - zone.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < zone.radius + ball.radius) {
                        // Ball is absorbed by void
                        gameState.balls.splice(ballIndex, 1);
                        showVoidAbsorptionEffect(zone.x, zone.y);
                    }
                });
            });
        }

        function createVoidZone() {
            const zone = {
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * 150 + 100,
                radius: 10,
                maxRadius: 60 + Math.random() * 40,
                growing: true,
                shrinking: false,
                color: '#4B0082',
                glowColor: '#9400D3'
            };
            voidZones.push(zone);
        }

        // Transition to next boss phase
        function transitionBossPhase() {
            bossSystem.phase++;
            bossSystem.phaseTransitionTimer = 3000; // 3 second transition
            
            // Show phase transition effect
            showBossPhaseTransition();
            
            setTimeout(() => {
                createBossPhase(bossSystem.currentBoss.bossLevel || level, bossSystem.phase);
                bossSystem.phaseTransitionTimer = 0;
            }, 3000);
        }

        // Defeat the boss
        function defeatBoss() {
            bossSystem.defeated = true;
            bossSystem.active = false;
            
            const rewards = bossSystem.currentBoss.rewards;
            
            // Save replay for boss defeat
            saveReplay(`Boss Defeated: ${bossSystem.currentBoss.name}`, 'boss_defeat');
            
            // Award rewards
            score += rewards.score;
            lives += rewards.lives;
            
            // Award powerups
            if (rewards.powerups.includes('all_powerups')) {
                // Special case for final boss
                activateAllPowerups();
            } else {
                rewards.powerups.forEach(powerupType => {
                    activateSpecificPowerup(powerupType);
                });
            }
            
            // Show victory screen
            showBossVictoryScreen();
            
            // Clean up boss system
            voidZones = [];
            bossSystem.bossBlocks = [];
            bossSystem.originalBossBlocks = [];
            bossSystem.currentBoss = null;
            
            // Track boss defeat achievement
            trackBossDefeated(level);
        }

        // Boss UI and visual effects
        function showBossIntroduction(bossDef) {
            // Implementation for boss introduction screen
            console.log(`BOSS BATTLE: ${bossDef.name} - ${bossDef.description}`);
        }

        function showBossRegenerationEffect(blocks) {
            // Implementation for regeneration visual effect
            console.log(`Boss regenerated ${blocks.length} blocks`);
        }

        function showBossPhaseTransition() {
            // Implementation for phase transition effect
            console.log(`Boss entering phase ${bossSystem.phase}`);
        }

        function showBossVictoryScreen() {
            // Implementation for victory screen
            console.log(`Boss defeated! Rewards: ${JSON.stringify(bossSystem.currentBoss.rewards)}`);
        }

        function showVoidAbsorptionEffect(x, y) {
            // Implementation for void absorption effect
            console.log(`Ball absorbed by void at (${x}, ${y})`);
        }

        function activateAllPowerups() {
            // Implementation for activating all powerups
            console.log("All powerups activated!");
        }

        function activateSpecificPowerup(type) {
            // Implementation for specific powerup activation
            console.log(`Powerup activated: ${type}`);
        }

        function trackBossDefeated(level) {
            // Track boss defeats for achievements
            if (!achievements.session.bossesDefeated) {
                achievements.session.bossesDefeated = new Set();
            }
            achievements.session.bossesDefeated.add(level);
        }

        // ===== PERSISTENT UPGRADE SHOP SYSTEM =====
        // Meta-progression system using earned upgrade points
        
        let upgradeShop = {
            upgradePoints: 0,
            totalPointsEarned: 0,
            upgrades: {
                // Paddle Upgrades
                paddle_size: { level: 0, maxLevel: 5, baseCost: 10, multiplier: 1.5 },
                paddle_speed: { level: 0, maxLevel: 5, baseCost: 15, multiplier: 1.4 },
                paddle_magnetic: { level: 0, maxLevel: 3, baseCost: 25, multiplier: 2.0 },
                paddle_splitting: { level: 0, maxLevel: 3, baseCost: 30, multiplier: 2.2 },
                
                // Ball Upgrades
                ball_damage: { level: 0, maxLevel: 5, baseCost: 12, multiplier: 1.6 },
                ball_speed: { level: 0, maxLevel: 4, baseCost: 18, multiplier: 1.7 },
                ball_piercing: { level: 0, maxLevel: 3, baseCost: 35, multiplier: 2.5 },
                ball_homing: { level: 0, maxLevel: 2, baseCost: 50, multiplier: 3.0 },
                
                // Meta Upgrades
                banking_interest: { level: 0, maxLevel: 5, baseCost: 20, multiplier: 1.8 },
                event_frequency: { level: 0, maxLevel: 4, baseCost: 25, multiplier: 2.0 },
                powerup_duration: { level: 0, maxLevel: 5, baseCost: 15, multiplier: 1.5 },
                combo_retention: { level: 0, maxLevel: 3, baseCost: 40, multiplier: 2.3 },
                
                // Special Upgrades
                life_saver: { level: 0, maxLevel: 3, baseCost: 60, multiplier: 3.5 },
                score_guardian: { level: 0, maxLevel: 2, baseCost: 80, multiplier: 4.0 },
                boss_hunter: { level: 0, maxLevel: 3, baseCost: 100, multiplier: 5.0 },
                void_immunity: { level: 0, maxLevel: 1, baseCost: 150, multiplier: 1.0 }
            },
            shopOpen: false,
            selectedCategory: 'paddle'
        };

        // Upgrade definitions with descriptions and effects
        const upgradeDefinitions = {
            paddle_size: {
                name: "Paddle Size",
                description: "Increase paddle width",
                icon: "📏",
                category: "paddle",
                effect: level => `+${level * 15}px width`,
                apply: level => {
                    paddle.width = paddle.originalWidth + (level * 15);
                }
            },
            paddle_speed: {
                name: "Paddle Speed", 
                description: "Increase paddle movement speed",
                icon: "⚡",
                category: "paddle",
                effect: level => `+${level * 20}% speed`,
                apply: level => {
                    paddle.speed = 19.2 * (1 + level * 0.2);
                }
            },
            paddle_magnetic: {
                name: "Magnetic Paddle",
                description: "Attract balls when close",
                icon: "🧲",
                category: "paddle",
                effect: level => level > 0 ? `${level * 30}px range` : "Locked",
                apply: level => {
                    paddle.magneticRange = level * 30;
                    paddle.magneticStrength = level * 0.3;
                }
            },
            paddle_splitting: {
                name: "Ball Splitting",
                description: "Chance to split balls on hit",
                icon: "⚡",
                category: "paddle",
                effect: level => level > 0 ? `${level * 10}% chance` : "Locked",
                apply: level => {
                    paddle.splitChance = level * 0.1;
                }
            },
            ball_damage: {
                name: "Ball Damage",
                description: "Increase damage to blocks",
                icon: "💥",
                category: "ball",
                effect: level => `+${level * 25}% damage`,
                apply: level => {
                    // Applied in collision detection
                }
            },
            ball_speed: {
                name: "Ball Speed",
                description: "Increase ball movement speed", 
                icon: "🚀",
                category: "ball",
                effect: level => `+${level * 15}% speed`,
                apply: level => {
                    // Applied when creating balls
                }
            },
            ball_piercing: {
                name: "Piercing Balls",
                description: "Balls can pass through weak blocks",
                icon: "🏹",
                category: "ball",
                effect: level => level > 0 ? `${level} blocks pierced` : "Locked",
                apply: level => {
                    // Applied in collision detection
                }
            },
            ball_homing: {
                name: "Homing Balls",
                description: "Balls slightly track towards blocks",
                icon: "🎯",
                category: "ball", 
                effect: level => level > 0 ? `${level * 0.5} tracking` : "Locked",
                apply: level => {
                    // Applied in ball movement
                }
            },
            banking_interest: {
                name: "Better Banking",
                description: "Increase banking interest rate",
                icon: "💰",
                category: "meta",
                effect: level => `+${level * 2}% interest`,
                apply: level => {
                    scoreBanking.interestRate = 0.05 + (level * 0.02);
                }
            },
            event_frequency: {
                name: "Event Frequency",
                description: "Temporary events occur more often",
                icon: "⭐",
                category: "meta",
                effect: level => `-${level * 15}s cooldown`,
                apply: level => {
                    temporaryEvents.eventCooldown = Math.max(30000, 60000 - (level * 15000));
                }
            },
            powerup_duration: {
                name: "Powerup Duration",
                description: "Powerups last longer",
                icon: "⏰",
                category: "meta",
                effect: level => `+${level * 25}% duration`,
                apply: level => {
                    // Applied in powerup timer calculations
                }
            },
            combo_retention: {
                name: "Combo Retention", 
                description: "Keep combo longer between hits",
                icon: "🔥",
                category: "meta",
                effect: level => `+${level * 2}s retention`,
                apply: level => {
                    // Applied in combo timer calculations
                }
            },
            life_saver: {
                name: "Life Saver",
                description: "Chance to prevent death",
                icon: "💖",
                category: "special",
                effect: level => level > 0 ? `${level * 15}% chance` : "Locked",
                apply: level => {
                    // Applied in death logic
                }
            },
            score_guardian: {
                name: "Score Guardian",
                description: "Reduce score loss on death",
                icon: "🛡️",
                category: "special",
                effect: level => level > 0 ? `-${level * 25}% loss` : "Locked",
                apply: level => {
                    // Applied in death penalty calculations
                }
            },
            boss_hunter: {
                name: "Boss Hunter",
                description: "Extra damage to boss blocks",
                icon: "⚔️",
                category: "special",
                effect: level => level > 0 ? `+${level * 50}% boss damage` : "Locked",
                apply: level => {
                    // Applied in boss block collision
                }
            },
            void_immunity: {
                name: "Void Immunity",
                description: "Balls immune to void zones",
                icon: "🌟",
                category: "special",
                effect: level => level > 0 ? "Complete immunity" : "Locked",
                apply: level => {
                    // Applied in void zone collision
                }
            }
        };

        // Calculate upgrade cost
        function getUpgradeCost(upgradeId) {
            const upgrade = upgradeShop.upgrades[upgradeId];
            if (!upgrade || upgrade.level >= upgrade.maxLevel) return null;
            
            return Math.floor(upgrade.baseCost * Math.pow(upgrade.multiplier, upgrade.level));
        }

        // Purchase upgrade
        function purchaseUpgrade(upgradeId) {
            const cost = getUpgradeCost(upgradeId);
            const upgrade = upgradeShop.upgrades[upgradeId];
            
            if (!cost || upgradeShop.upgradePoints < cost || upgrade.level >= upgrade.maxLevel) {
                return false;
            }
            
            upgradeShop.upgradePoints -= cost;
            upgrade.level++;
            
            // Apply upgrade effects
            const definition = upgradeDefinitions[upgradeId];
            if (definition && definition.apply) {
                definition.apply(upgrade.level);
            }
            
            return true;
        }

        // Earn upgrade points
        function earnUpgradePoints(points, reason = 'general') {
            upgradeShop.upgradePoints += points;
            upgradeShop.totalPointsEarned += points;
            
            // Show notification
            showUpgradePointsEarned(points, reason);
        }

        // Award upgrade points based on performance
        function awardUpgradePoints() {
            let pointsEarned = 0;
            let reasons = [];
            
            // Level completion base points
            pointsEarned += Math.floor(level / 5) + 1;
            reasons.push(`Level ${level} completion`);
            
            // Score-based points
            const scorePoints = Math.floor(score / 50000);
            if (scorePoints > 0) {
                pointsEarned += scorePoints;
                reasons.push(`High score bonus`);
            }
            
            // Achievement points
            const newAchievements = achievements.unlocked.size - (upgradeShop.lastAchievementCount || 0);
            if (newAchievements > 0) {
                pointsEarned += newAchievements * 3;
                reasons.push(`${newAchievements} achievements`);
                upgradeShop.lastAchievementCount = achievements.unlocked.size;
            }
            
            // Boss defeat bonus
            if (bossSystem.defeated) {
                const bossBonus = level >= 100 ? 15 : level >= 75 ? 12 : level >= 50 ? 10 : 8;
                pointsEarned += bossBonus;
                reasons.push(`Boss defeat bonus`);
            }
            
            // Banking efficiency bonus
            if (scoreBanking.bankedScore > 0) {
                const bankingBonus = Math.floor(scoreBanking.bankedScore / 100000);
                if (bankingBonus > 0) {
                    pointsEarned += bankingBonus;
                    reasons.push(`Banking efficiency`);
                }
            }
            
            if (pointsEarned > 0) {
                earnUpgradePoints(pointsEarned, reasons.join(', '));
            }
        }

        // Open upgrade shop
        function openUpgradeShop() {
            upgradeShop.shopOpen = true;
            
            // Remember if game was running and pause it
            upgradeShop.wasGameRunning = gameRunning;
            if (gameRunning) {
                gamePaused = true;
                console.log('Game paused for upgrade shop');
            }
            
            // Award points when shop opens
            awardUpgradePoints();
            
            // Show shop overlay
            showUpgradeShopOverlay();
        }

        // Close upgrade shop
        function closeUpgradeShop() {
            upgradeShop.shopOpen = false;
            
            // Resume game if it was running when shop opened
            if (upgradeShop.wasGameRunning && gamePaused) {
                gamePaused = false;
                console.log('Upgrade shop closed - resuming game');
            }
            upgradeShop.wasGameRunning = false; // Reset flag
        }

        // Handle shop input
        function handleShopInput(key) {
            if (!upgradeShop.shopOpen) return false;
            
            switch (key) {
                case 'Escape':
                case 'q':
                case 'Q':
                case 'u':
                case 'U':
                    closeUpgradeShop();
                    return true;
                    
                case '1':
                    upgradeShop.selectedCategory = 'paddle';
                    return true;
                case '2':
                    upgradeShop.selectedCategory = 'ball';
                    return true;
                case '3':
                    upgradeShop.selectedCategory = 'meta';
                    return true;
                case '4':
                    upgradeShop.selectedCategory = 'special';
                    return true;
                    
                // Purchase upgrades with number keys
                case 'a': case 'A':
                    return tryPurchaseByIndex(0);
                case 's': case 'S':
                    return tryPurchaseByIndex(1);
                case 'd': case 'D':
                    return tryPurchaseByIndex(2);
                case 'f': case 'F':
                    return tryPurchaseByIndex(3);
            }
            
            return false;
        }

        // Try to purchase upgrade by category index
        function tryPurchaseByIndex(index) {
            const categoryUpgrades = Object.keys(upgradeDefinitions)
                .filter(id => upgradeDefinitions[id].category === upgradeShop.selectedCategory);
            
            if (index < categoryUpgrades.length) {
                const upgradeId = categoryUpgrades[index];
                if (purchaseUpgrade(upgradeId)) {
                    showUpgradePurchased(upgradeId);
                    return true;
                }
            }
            return false;
        }

        // Apply all current upgrades (called on game start)
        function applyAllUpgrades() {
            Object.keys(upgradeShop.upgrades).forEach(upgradeId => {
                const upgrade = upgradeShop.upgrades[upgradeId];
                const definition = upgradeDefinitions[upgradeId];
                
                if (upgrade.level > 0 && definition && definition.apply) {
                    definition.apply(upgrade.level);
                }
            });
        }

        // Get upgrade effects for gameplay mechanics
        function getUpgradeEffect(upgradeId) {
            const upgrade = upgradeShop.upgrades[upgradeId];
            return upgrade ? upgrade.level : 0;
        }

        // UI notification functions (placeholder implementations)
        function showUpgradePointsEarned(points, reason) {
            console.log(`Earned ${points} upgrade points: ${reason}`);
        }

        function showUpgradePurchased(upgradeId) {
            const definition = upgradeDefinitions[upgradeId];
            console.log(`Purchased: ${definition.name} Level ${upgradeShop.upgrades[upgradeId].level}`);
        }

        function showUpgradeShopOverlay() {
            // Implementation in draw function
            console.log('Upgrade shop opened');
        }

        // ===== ACHIEVEMENT GALLERY SYSTEM =====
        // Visual interface for viewing all achievements and progress
        
        let achievementGallery = {
            galleryOpen: false,
            selectedCategory: 'Score',
            categories: ['Score', 'Survival', 'Skill', 'Discovery', 'Special', 'Boss']
        };

        // Open achievement gallery
        function openAchievementGallery() {
            achievementGallery.galleryOpen = true;
            // Remember if game was running and pause it
            achievementGallery.wasGameRunning = gameRunning;
            if (gameRunning) {
                gamePaused = true;
                console.log('Game paused for achievement gallery');
            }
        }

        // Close achievement gallery
        function closeAchievementGallery() {
            achievementGallery.galleryOpen = false;
            // Resume game if it was running when gallery opened
            if (achievementGallery.wasGameRunning && gamePaused) {
                gamePaused = false;
                console.log('Achievement gallery closed - resuming game');
            }
            achievementGallery.wasGameRunning = false; // Reset flag
        }

        // Handle achievement gallery input
        function handleAchievementGalleryInput(key) {
            if (!achievementGallery.galleryOpen) return false;
            
            switch (key) {
                case 'Escape':
                case 'j':
                case 'J':
                case 'a':
                case 'A':
                    closeAchievementGallery();
                    return true;
                    
                case '1':
                    achievementGallery.selectedCategory = 'Score';
                    return true;
                case '2':
                    achievementGallery.selectedCategory = 'Survival';
                    return true;
                case '3':
                    achievementGallery.selectedCategory = 'Skill';
                    return true;
                case '4':
                    achievementGallery.selectedCategory = 'Discovery';
                    return true;
                case '5':
                    achievementGallery.selectedCategory = 'Special';
                    return true;
                case '6':
                    achievementGallery.selectedCategory = 'Boss';
                    return true;
            }
            
            return false;
        }

        // Draw achievement gallery overlay
        function drawAchievementGallery() {
            if (!achievementGallery.galleryOpen) return;
            if (!ctx) return;
            
            ctx.save();
            
            // Semi-transparent background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.fillStyle = '#FFD700';
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            ctx.font = 'bold 28px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('🏆 ACHIEVEMENT GALLERY', canvas.width / 2, 50);
            
            // Achievement progress summary
            const totalAchievements = Object.keys(achievements.definitions).length;
            const unlockedCount = achievements.unlocked.size;
            ctx.fillStyle = '#00FFFF';
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 10;
            ctx.font = 'bold 16px "Press Start 2P", monospace';
            ctx.fillText(`${unlockedCount}/${totalAchievements} Achievements Unlocked`, canvas.width / 2, 85);
            
            // Category tabs - wider to fit text
            const tabWidth = 120;
            const tabHeight = 32;
            const tabSpacing = 12;
            const totalTabWidth = (tabWidth + tabSpacing) * achievementGallery.categories.length - tabSpacing;
            const tabStartX = (canvas.width - totalTabWidth) / 2;
            
            achievementGallery.categories.forEach((category, index) => {
                const tabX = tabStartX + (tabWidth + tabSpacing) * index;
                const tabY = 105;
                const isSelected = achievementGallery.selectedCategory === category;
                
                // Tab background
                ctx.fillStyle = isSelected ? 'rgba(255, 215, 0, 0.3)' : 'rgba(100, 100, 100, 0.3)';
                ctx.fillRect(tabX, tabY, tabWidth, tabHeight);
                
                // Tab border
                ctx.strokeStyle = isSelected ? '#FFD700' : '#CCCCCC';
                ctx.lineWidth = 2;
                ctx.strokeRect(tabX, tabY, tabWidth, tabHeight);
                
                // Tab text
                ctx.fillStyle = isSelected ? '#FFD700' : '#FFFFFF';
                ctx.shadowColor = isSelected ? '#FFD700' : '#000000';
                ctx.shadowBlur = isSelected ? 8 : 3;
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${index + 1} ${category}`, tabX + tabWidth / 2, tabY + 21);
            });
            
            // Get achievements for selected category
            const categoryAchievements = Object.values(achievements.definitions)
                .filter(achievement => achievement.category === achievementGallery.selectedCategory);
            
            // Achievement grid
            const achievementWidth = 300;
            const achievementHeight = 140;
            const achievementSpacing = 20;
            const achievementsPerRow = 2;
            const startX = (canvas.width - (achievementWidth * achievementsPerRow + achievementSpacing * (achievementsPerRow - 1))) / 2;
            const startY = 155;
            
            categoryAchievements.forEach((achievement, index) => {
                const row = Math.floor(index / achievementsPerRow);
                const col = index % achievementsPerRow;
                const achX = startX + (achievementWidth + achievementSpacing) * col;
                const achY = startY + (achievementHeight + achievementSpacing) * row;
                
                const isUnlocked = achievements.unlocked.has(achievement.id);
                const progress = getAchievementProgress(achievement);
                
                // Achievement background
                let bgColor = 'rgba(50, 50, 50, 0.8)';
                if (isUnlocked) {
                    bgColor = 'rgba(255, 215, 0, 0.2)';
                } else if (progress > 0) {
                    bgColor = 'rgba(100, 100, 100, 0.4)';
                }
                
                ctx.fillStyle = bgColor;
                ctx.fillRect(achX, achY, achievementWidth, achievementHeight);
                
                // Achievement border
                ctx.strokeStyle = isUnlocked ? '#FFD700' : '#666666';
                ctx.lineWidth = isUnlocked ? 3 : 2;
                ctx.strokeRect(achX, achY, achievementWidth, achievementHeight);
                
                // Achievement icon
                ctx.fillStyle = isUnlocked ? '#FFD700' : '#888888';
                ctx.font = 'bold 20px "Press Start 2P", monospace';
                ctx.textAlign = 'left';
                ctx.fillText(achievement.icon, achX + 10, achY + 30);
                
                // Achievement name - wrap to multiple lines
                ctx.fillStyle = isUnlocked ? '#FFD700' : '#CCCCCC';
                ctx.font = 'bold 12px "Press Start 2P", monospace';
                const nameLines = wrapText(ctx, achievement.name, achievementWidth - 55);
                nameLines.forEach((line, lineIndex) => {
                    ctx.fillText(line, achX + 45, achY + 25 + lineIndex * 14);
                });
                
                // Achievement description
                ctx.fillStyle = isUnlocked ? '#FFFFFF' : '#888888';
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                const descLines = wrapText(ctx, achievement.description, achievementWidth - 55);
                const descStartY = achY + 25 + nameLines.length * 14 + 8; // Start after name with padding
                descLines.forEach((line, lineIndex) => {
                    ctx.fillText(line, achX + 45, descStartY + lineIndex * 12);
                });
                
                // Progress bar for incomplete achievements
                if (!isUnlocked && progress > 0) {
                    const progressBarWidth = achievementWidth - 20;
                    const progressBarHeight = 6;
                    const progressBarX = achX + 10;
                    const progressBarY = achY + achievementHeight - 30;
                    
                    // Progress background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
                    
                    // Progress fill
                    const progressPercent = Math.min(1, progress / achievement.target);
                    ctx.fillStyle = '#00AA00';
                    ctx.fillRect(progressBarX, progressBarY, progressBarWidth * progressPercent, progressBarHeight);
                    
                    // Progress text
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 9px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.floor(progress)}/${achievement.target}`, achX + achievementWidth / 2, achY + achievementHeight - 8);
                } else if (isUnlocked) {
                    // Unlocked indicator
                    ctx.fillStyle = '#00FF00';
                    ctx.font = 'bold 11px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('✓ UNLOCKED', achX + achievementWidth / 2, achY + achievementHeight - 12);
                }
            });
            
            // Instructions
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = '#000000';
            ctx.shadowBlur = 3;
            ctx.font = 'bold 12px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('1-6: Change Category  •  A/ESC/J: Close', canvas.width / 2, canvas.height - 20);
            
            ctx.restore();
        }

        // Get current progress for an achievement
        function getAchievementProgress(achievement) {
            switch (achievement.id) {
                // Score achievements
                case 'first_thousand':
                case 'ten_thousand':
                case 'hundred_thousand':
                case 'million_club':
                    return score;
                
                // Survival achievements
                case 'getting_started':
                case 'quarter_century':
                case 'halfway_hero':
                case 'three_quarters':
                case 'completionist':
                    return level;
                
                // Skill achievements
                case 'combo_master':
                    return achievements.session.maxCombo || 0;
                case 'precision_player':
                    return difficultyAdjustment.playerAccuracy * 100;
                case 'banking_baron':
                    return achievements.session.interestEarned || 0;
                case 'speed_demon_survivor':
                    return achievements.session.eventsSurvived.has('speed_demon') ? 1 : 0;
                
                // Discovery achievements
                case 'treasure_hunter':
                    return achievements.session.treasuresOpened || 0;
                case 'shield_breaker':
                    return achievements.session.shieldsDestroyed || 0;
                case 'magnetic_master':
                    return achievements.session.magneticHits || 0;
                case 'chain_reaction':
                    return achievements.session.maxChainReaction || 0;
                
                // Special achievements
                case 'event_survivor':
                    return achievements.session.eventsSurvived.size || 0;
                case 'golden_hour_master':
                    return achievements.session.goldenHourScore || 0;
                case 'difficulty_master':
                    return difficultyAdjustment.currentModifier * 100;
                
                // Boss achievements
                case 'fortress_destroyer':
                    return (achievements.session.bossesDefeated && achievements.session.bossesDefeated.has(25)) ? 1 : 0;
                case 'swarm_conqueror':
                    return (achievements.session.bossesDefeated && achievements.session.bossesDefeated.has(50)) ? 1 : 0;
                case 'void_slayer':
                    return (achievements.session.bossesDefeated && achievements.session.bossesDefeated.has(75)) ? 1 : 0;
                case 'master_champion':
                    return (achievements.session.bossesDefeated && achievements.session.bossesDefeated.has(100)) ? 1 : 0;
                case 'boss_hunter':
                    return achievements.session.bossesDefeated ? achievements.session.bossesDefeated.size : 0;
                
                default:
                    return 0;
            }
        }

        // Apply homing effect to balls (upgrade mechanic)
        function applyHomingEffect(ball, homingStrength, deltaMultiplier) {
            // Find the closest non-destroyed block
            let closestBlock = null;
            let closestDistance = Infinity;
            
            blocks.forEach(block => {
                if (!block.destroyed) {
                    const blockCenterX = block.x + block.width / 2;
                    const blockCenterY = block.y + block.height / 2;
                    const distance = Math.sqrt(
                        (ball.x - blockCenterX) ** 2 + (ball.y - blockCenterY) ** 2
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBlock = block;
                    }
                }
            });
            
            if (closestBlock && closestDistance < 200) { // Only home within 200px
                const blockCenterX = closestBlock.x + closestBlock.width / 2;
                const blockCenterY = closestBlock.y + closestBlock.height / 2;
                
                // Calculate direction to block
                const directionX = (blockCenterX - ball.x) / closestDistance;
                const directionY = (blockCenterY - ball.y) / closestDistance;
                
                // Apply gentle homing force
                const force = homingStrength * deltaMultiplier * 0.01;
                ball.dx += directionX * force;
                ball.dy += directionY * force;
                
                // Maintain reasonable speed
                const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                if (currentSpeed > ball.speed * 1.2) {
                    const scale = (ball.speed * 1.2) / currentSpeed;
                    ball.dx *= scale;
                    ball.dy *= scale;
                }
            }
        }

        // Scalable paddle and ball dimensions
        let paddleWidth = 120;
        let paddleHeight = 15;
        let ballRadius = 8;
        
        // Paddle with enhanced properties
        const paddle = {
            x: 0,
            y: 0,
            width: paddleWidth,
            height: paddleHeight,
            speed: 19.2, // 8 * 2.4 to feel like 144hz instead of 60hz
            originalWidth: paddleWidth,
            laser: false,
            sticky: false,
            powerUpTimer: 0,
            velocity: 0,
            lastX: 0
        };

        // Ball template - standardized to scalable radius for consistency
        const ballTemplate = {
            x: 0,
            y: 0,
            radius: ballRadius,
            dx: 0,
            dy: 0,
            speed: 5,
            launched: false,
            trail: []
        };

        // Power-up types with new additions including combo multipliers
        const powerUpTypes = [
            { type: 'multiball', color: '#FF6B6B', symbol: '●●●', chance: 0.10 },
            { type: 'bigpaddle', color: '#4ECDC4', symbol: '━━━', chance: 0.14 },
            { type: 'laser', color: '#45B7D1', symbol: '⚡', chance: 0.10 },
            { type: 'sticky', color: '#96CEB4', symbol: '〇', chance: 0.10 },
            { type: 'extralife', color: '#FFEAA7', symbol: '♥', chance: 0.06 },
            { type: 'slowball', color: '#DDA0DD', symbol: '🐌', chance: 0.10 },
            { type: 'megaball', color: '#98D8C8', symbol: '⚫', chance: 0.07 },
            { type: 'rocket', color: '#FF4500', symbol: '🚀', chance: 0.09 },
            { type: 'smallpaddle', color: '#FF8C94', symbol: '━', chance: 0.07 },
            { type: 'speedball', color: '#A8E6CF', symbol: '⚡', chance: 0.07 },
            // New combo multiplier pickups
            { type: 'combo2x', color: '#FF6B35', symbol: '2×', chance: 0.06 },
            { type: 'combo5x', color: '#F7931E', symbol: '5×', chance: 0.03 },
            { type: 'combo10x', color: '#FFD700', symbol: '10×', chance: 0.01 }
        ];

        // Power-up timing variables
        let lastExtraLifeSpawn = 0;
        const EXTRA_LIFE_COOLDOWN = 25000; // 25 seconds in milliseconds
        let paddleSizeLevel = 0; // Track paddle size changes (-4 to +4)

        // Block system
        const blocks = [];
        const blockRows = 8;
        const blockCols = 20; // Doubled from 10 to 20 for half-width bricks
        
        // Scalable block dimensions (will be updated by scaling system)
        let blockWidth = 38; // Adjusted for 800px width (20 blocks × 38 + 19 gaps × 2 = 798px)
        let blockHeight = 20; // Proportionally adjusted
        let blockPadding = 2; // Smaller padding for 800px width
        
        // Level Manager for modular level loading
        // Feature flag: set to true to use external JSON levels (levels 1-10)
        const USE_EXTERNAL_LEVELS = true;
        let levelManager = null;
        
        // Initialize LevelManager
        if (typeof LevelManager !== 'undefined') {
            levelManager = new LevelManager({
                useExternalLevels: USE_EXTERNAL_LEVELS,
                basePath: '/js/modules/levels/data/',
                maxCacheSize: 20, // Cache up to 20 levels
                loadTimeoutMs: 3000 // 3 second timeout
            });
        }
        const blockColors = [
            '#FF0040', // Bright red
            '#00FFD4', // Bright cyan  
            '#FF6600', // Bright orange
            '#8000FF', // Bright purple
            '#00FF40', // Bright green
            '#FF0080', // Bright magenta
            '#0080FF', // Bright blue
            '#FFFF00', // Bright yellow
            '#FF4080', // Hot pink
            '#80FF00', // Lime green
            '#4080FF', // Sky blue
            '#FF8040', // Coral
            '#FF2000', // Deep red for pixel art
            '#FF6000', // Orange-red for pixel art
            '#FFB000', // Gold for pixel art
            '#FFFFFF', // White for pixel art
            '#CCCCCC', // Light gray for pixel art
            '#808080', // Dark gray for pixel art
            '#FF00FF', // Bright magenta for pixel art
            '#00FFFF'  // Cyan for pixel art
        ];

        // Level names for the 100-level system (spooky/cyber themed)
        const levelNames = [
            "Viral Vortex",          // 1 - first lava blocks (was 5)
            "Pixel Purgatory",       // 2 - original level 1 with colors (was 4)
            "Cyber Crypt",           // 3 (was 3)
            "Neon Nightmare",         // 4 (was 2)
            "Digital Dawn",           // 5 (was 1)
            "Data Decay",            // 6
            "System Spiral",         // 7
            "Ghost Grid",            // 8
            "Phantom Protocol",      // 9
            "Demon Download",        // 10
            "Cryptic Code",          // 11
            "Shadow Server",         // 12
            "Haunted Hardware",      // 13
            "Spectral Syntax",       // 14
            "Mystic Matrix",         // 15 - first pixel art
            "Cursed Circuit",        // 16
            "Wraith Web",            // 17
            "Banshee Bandwidth",     // 18
            "Poltergeist Port",      // 19
            "Reaper's Realm",        // 20 - ALL LAVA (instant win)
            "Undead Upload",         // 21
            "Vampire Vector",        // 22
            "Witch's WiFi",          // 23
            "Demon Database",        // 24
            "Specter Signal",        // 25
            "Necro Network",         // 26
            "Phantom Firewall",      // 27
            "Ghoul Gateway",         // 28
            "Zombie Zone",           // 29
            "Terror Terminal",       // 30
            "Skull Screen",          // 31
            "Bone Bandwidth",        // 32
            "Soul Server",           // 33
            "Death Download",        // 34
            "Grave Graphics",        // 35
            "Crypt Code",            // 36
            "Tomb Terminal",         // 37
            "Coffin Cache",          // 38
            "Mummy Memory",          // 39
            "Pharaoh's Protocol",    // 40 - map clearing level
            "Ancient Algorithm",     // 41
            "Curse Compiler",        // 42
            "Pyramid Program",       // 43
            "Sarcophagus Script",    // 44
            "Hieroglyph Hack",      // 45 - map clearing level
            "Sphinx System",         // 46
            "Anubis Array",          // 47
            "Ra's Registry",         // 48
            "Osiris OS",             // 49
            "Void Vector",           // 50 - map clearing level
            "Black Binary",          // 51
            "Dark Data",             // 52
            "Shadow Script",         // 53
            "Midnight Matrix",       // 54
            "Eclipse Engine",        // 55 - map clearing level
            "Lunar Logic",           // 56
            "Solar System",          // 57
            "Stellar Script",        // 58
            "Cosmic Code",           // 59
            "Galaxy Gateway",        // 60 - map clearing level
            "Nebula Network",        // 61
            "Quasar Query",          // 62
            "Pulsar Protocol",       // 63
            "Supernova System",      // 64
            "Blackhole Binary",      // 65 - map clearing level
            "Wormhole Web",          // 66
            "Dimensional Data",      // 67
            "Parallel Protocol",     // 68
            "Quantum Query",         // 69
            "Atomic Array",          // 70 - map clearing level
            "Nuclear Network",       // 71
            "Fusion Framework",      // 72
            "Plasma Protocol",       // 73
            "Energy Engine",         // 74
            "Photon Program",        // 75 - map clearing level
            "Laser Logic",           // 76
            "Beam Binary",           // 77
            "Ray Registry",          // 78
            "Light Logic",           // 79
            "Prism Protocol",        // 80 - map clearing level
            "Crystal Core",          // 81
            "Diamond Data",          // 82
            "Emerald Engine",        // 83
            "Ruby Registry",         // 84
            "Sapphire System",       // 85 - map clearing level
            "Barrier Genesis",       // 86 - First void blocks
            "Void Corridors",        // 87 - Horizontal void lanes
            "Shadow Maze",           // 88 - Simple maze with void walls
            "Diagonal Shadows",      // 89 - Diagonal void barriers
            "Void Fortress",         // 90 - Fortress with void walls
            "Abyss Gates",           // 91 - Strategic void placement
            "Spiral Void",           // 92 - Spiral void pattern
            "Shadow Prison",         // 93 - Complex void maze
            "Void Cathedral",        // 94 - Gothic arch patterns
            "Darkness Rising",       // 95 - Complex void barriers
            "Event Horizon",         // 96 - Near-endgame challenge
            "Final Approach",        // 97 - Extremely challenging void
            "Penultimate Shadow",    // 98 - Master-level void manipulation
            "Edge of Oblivion",      // 99 - Nearly impossible challenge
            "ULTIMATE VOID"          // 100 - The final void challenge
        ];

        // Input handling
        const keys = {};
        let mouseX = 0;
        let touchX = 0;
        let mouseMovementX = 0;
        
        // High Score System
        let allTimeHighScore = { score: 0, player: 'Nobody' };
        let sessionPersonalBest = 0;
        
        function getLocalHighScore() {
            return parseInt(localStorage.getItem('breakout-highscore')) || 0;
        }

        function setLocalHighScore(newScore) {
            const currentHigh = getLocalHighScore();
            if (newScore > currentHigh) {
                localStorage.setItem('breakout-highscore', newScore.toString());
                
                // Save replay for new high score
                saveReplay(`High Score: ${newScore.toLocaleString()}`, 'high_score');
                
                return true;
            }
            return false;
        }

        function updatePersonalBest(newScore) {
            if (newScore > sessionPersonalBest) {
                sessionPersonalBest = newScore;
                return true;
            }
            return false;
        }

        // Fetch all-time high score from database
        async function fetchAllTimeHighScore() {
            try {
                const response = await fetch('scores_api.php?limit=1');
                if (response.ok) {
                    const scores = await response.json();
                    if (scores.length > 0) {
                        allTimeHighScore = {
                            score: scores[0].score,
                            player: scores[0].player_name
                        };
                        // Update all-time champion display
                        if (allTimeScoreElement) allTimeScoreElement.textContent = allTimeHighScore.score.toLocaleString();
                        if (allTimePlayerElement) allTimePlayerElement.textContent = allTimeHighScore.player;
                        
                        // Update UI to show the personal best
                        updateUI();
                    }
                }
            } catch (error) {
                console.error('Failed to fetch all-time high score:', error);
            }
        }

        function getCurrentHighScore() {
            return Math.max(allTimeHighScore.score, getLocalHighScore());
        }

        // Client-side profanity filter (lightweight version)
        function containsProfanityJS(text) {
            // Core profanity list for client-side checking
            const profanityList = [
                'fuck', 'shit', 'bitch', 'damn', 'hell', 'ass', 'crap', 'piss', 'cock', 'dick', 'pussy', 'cunt', 'whore', 'slut',
                'bastard', 'asshole', 'bullshit', 'goddamn', 'wtf', 'stfu', 'gtfo', 'nigger', 'nigga', 'faggot', 'retard',
                'nazi', 'hitler', 'porn', 'sex', 'cum', 'kill', 'murder', 'rape', 'bomb', 'suicide', 'kys', 'admin', 'mod'
            ];
            
            const normalized = normalizeProfanityTextJS(text);
            
            for (const word of profanityList) {
                const normalizedWord = normalizeProfanityTextJS(word);
                if (normalized.includes(normalizedWord)) {
                    return true;
                }
                
                // Check for variations with separators
                const pattern = normalizedWord.split('').join('[0-9\\s\\-_\\.\\*\\+]*?');
                const regex = new RegExp(pattern, 'i');
                if (regex.test(normalized)) {
                    return true;
                }
            }
            
            return false;
        }

        function normalizeProfanityTextJS(text) {
            text = text.toLowerCase().trim();
            
            // Remove separators
            text = text.replace(/[\s\-_\.\*\+!@#$%^&]/g, '');
            
            // Replace leetspeak
            const leetspeak = {
                '4': 'a', '@': 'a', '3': 'e', '1': 'i', '!': 'i', '|': 'i',
                '0': 'o', '5': 's', '$': 's', '7': 't', '+': 't', '8': 'b'
            };
            
            for (const [leet, normal] of Object.entries(leetspeak)) {
                text = text.replace(new RegExp(leet.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), normal);
            }
            
            // Remove remaining numbers
            text = text.replace(/[0-9]+/g, '');
            
            return text;
        }

        // Check for admin localStorage reset - DISABLED (admin panel removed)
        async function checkLocalStorageReset() {
            // This functionality has been disabled as the admin panel was removed
            return;
        }

        // Sound System (Web Audio API simulation)
        function playSound(type) {
            if (!soundEnabled) return;
            
            // Simple sound effects using oscillator
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const sounds = {
                paddle: { freq: 200, duration: 0.1 },
                block: { freq: 400, duration: 0.15 },
                powerup: { freq: 600, duration: 0.2 },
                life: { freq: 150, duration: 0.3 },
                win: { freq: 800, duration: 0.5 }
            };
            
            const sound = sounds[type] || sounds.block;
            oscillator.frequency.setValueAtTime(sound.freq, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + sound.duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + sound.duration);
        }

        // Handle responsive canvas sizing
        function resizeCanvas() {
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            
            // For mobile devices
            if (window.innerWidth <= 768) {
                // Calculate dimensions maintaining aspect ratio
                const maxWidth = Math.min(containerWidth - 20, window.innerWidth - 20);
                const aspectRatio = 800 / 600;
                
                canvas.style.width = maxWidth + 'px';
                canvas.style.height = (maxWidth / aspectRatio) + 'px';
                
                // Adjust game scale factor
                const scaleFactor = maxWidth / 800;
                canvas.setAttribute('data-scale', scaleFactor);
            } else {
                // Desktop - use original size
                canvas.style.width = '800px';
                canvas.style.height = '600px';
                canvas.setAttribute('data-scale', '1');
            }
        }

        async function initBreakoutGame() {
            console.log('initBreakoutGame called');
            
            // Load game configuration first
            await loadGameConfig();
            
            // Setup live config reloading
            setupConfigReloadListener();
            
            canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            console.log('Canvas found:', canvas);
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context!');
                return;
            }
            console.log('Canvas context obtained');
            
            // Initialize scaling system with current canvas dimensions
            updateGameScale(canvas.width, canvas.height);
            console.log('Scaling system initialized');
            
            scoreElement = document.getElementById('score');
            livesElement = document.getElementById('lives');
            levelElement = document.getElementById('level');
            personalBestElement = document.getElementById('personalBest');
            allTimeScoreElement = document.getElementById('allTimeScore');
            allTimePlayerElement = document.getElementById('allTimePlayer');
            pauseBtn = document.getElementById('pauseBtn');
            resetBtn = document.getElementById('resetBtn');

            // Handle responsive sizing
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Check for admin localStorage reset
            checkLocalStorageReset();

            // Fetch all-time high score from database
            fetchAllTimeHighScore();

            // Setup mouse and touch controls
            setupControls();

            // Initialize first ball (potentially elemental)
            const firstBall = mysticalPowers.active ? 
                createElementalBall(mysticalPowers.selectedElement) : 
                {
                    x: paddle.x + paddle.width / 2,
                    y: paddle.y - ballRadius - 5,
                    radius: ballRadius,
                    dx: 0,
                    dy: 0,
                    speed: 5, // Hard-coded to base speed - NO level increases
                    launched: false,
                    trail: [],
                    element: 'normal'
                };
                
            // Ensure positioning and base properties are correct
            firstBall.x = canvas.width / 2;
            firstBall.y = paddle.y - 20;
            firstBall.radius = ballTemplate.radius;
            firstBall.launched = false;
            if (!firstBall.trail) firstBall.trail = [];
            
            console.log(`Game initialized at level ${level}: Ball created with element ${firstBall.element || 'normal'}`);
            gameState.balls = [firstBall];

            // Initialize game elements with proper scaling after ball is created
            initializeGameElements();
            paddle.lastX = paddle.x; // Initialize lastX to prevent velocity glitch
            paddle.velocity = 0; // Reset velocity

            await initBlocks();
            updateUI();
            draw();
            
            // Game is ready but not started yet
            gameStarted = false;
            gameRunning = false;
            if (pauseBtn) pauseBtn.disabled = true;
            
            // Start the game loop to continuously render the start screen
            if (!animationId) {
                gameLoop();
            }
        }

        function setupControls() {
            // Helper function to get scaled coordinates
            function getScaledCoordinates(clientX, rect) {
                const scale = parseFloat(canvas.getAttribute('data-scale') || '1');
                const x = (clientX - rect.left) / scale;
                return x;
            }

            // Mouse controls - listen to document for global mouse tracking
            document.addEventListener('mousemove', (e) => {
                if (pointerLocked) {
                    // Use movementX for locked pointer with increased sensitivity
                    const rect = canvas.getBoundingClientRect();
                    const scale = parseFloat(canvas.getAttribute('data-scale') || '1');
                    
                    // Calculate sensitivity multiplier to match unlocked feel
                    // Higher base sensitivity for better feel on all refresh rates
                    const baseSensitivity = gameConfig.mouse_sensitivity || 2.5;
                    // Apply more aggressive scaling - pointer lock typically needs 3-5x more sensitivity
                    const sensitivityMultiplier = baseSensitivity * 1.8; // Increased from previous values
                    
                    // Apply movement with proper scaling
                    const scaledMovement = (e.movementX * sensitivityMultiplier) / scale;
                    mouseX = Math.max(paddle.width / 2, Math.min(canvas.width - paddle.width / 2, 
                        (mouseX || paddle.x + paddle.width / 2) + scaledMovement));
                } else {
                    const rect = canvas.getBoundingClientRect();
                    // Update mouseX with scaled coordinates
                    mouseX = getScaledCoordinates(e.clientX, rect);
                }
            });

            // Pointer lock event handlers
            document.addEventListener('pointerlockchange', () => {
                pointerLocked = document.pointerLockElement === canvas;
                if (pointerLocked) {
                    console.log('Pointer locked to game canvas');
                    // Reset movement accumulator
                    mouseMovementX = 0;
                } else {
                    console.log('Pointer lock released');
                }
            });

            document.addEventListener('pointerlockerror', () => {
                console.error('Pointer lock failed');
            });

            // Touch controls
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                touchX = getScaledCoordinates(e.touches[0].clientX, rect);
            });

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameStarted) {
                    startGame();
                } else if (gameRunning && gameState.balls.length > 0) {
                    launchNextBall(); // Launch balls sequentially
                }
            });
            
            // Mouse click handler (same behavior as touch and spacebar)
            canvas.addEventListener('click', async (e) => {
                // Request pointer lock if not already locked and game is running
                if (gameRunning && !pointerLocked && canvas.requestPointerLock) {
                    canvas.requestPointerLock();
                }
                
                // Check if achievement gallery is open - block all game clicks
                if (achievementGallery.galleryOpen) {
                    return; // Prevent any game interaction when achievement gallery is open
                }
                
                // Focus the canvas to capture keyboard events
                canvas.focus();
                
                // Handle overlay dismissal first
                if (gameOverlay.active) {
                    // Don't handle clicks for interactive hall of fame - only keyboard input
                    if (gameOverlay.type === 'hallOfFameInput') {
                        return;
                    }
                    if (gameOverlay.type === 'nameError') {
                        // Return to the input screen to try again
                        if (gameOverlay.returnToInput && gameOverlay.originalData) {
                            // Restore the input screen with original data
                            gameOverlay = {
                                active: true,
                                type: 'hallOfFameInput',
                                title: '🏆 HALL OF FAME - TOP 10 🏆',
                                scores: [], // Will be populated by getHighScores
                                playerScore: gameOverlay.originalData.playerScore,
                                playerLevel: gameOverlay.originalData.playerLevel,
                                playerRank: gameOverlay.originalData.playerRank,
                                insertAtIndex: gameOverlay.originalData.insertAtIndex,
                                inputName: '',
                                cursorVisible: true,
                                cursorBlinkTime: Date.now(),
                                instruction: 'Type your name. Press ENTER to save your score'
                            };
                            // Refresh scores
                            gameOverlay.scores = await getHighScores(10);
                        } else {
                            gameOverlay.active = false;
                        }
                        return;
                    }
                    if (gameOverlay.type === 'levelComplete') {
                        // Continue to next level (level already incremented in nextLevel function)
                        if (level > totalLevels) {
                            // Ultimate game completion - all 100 levels cleared!
                            legitGameCompleted = true;
                            recordCompletionist(); // Record the completion
                            gameOverlay = {
                                active: true,
                                type: 'ultimateVictory',
                                title: 'ULTIMATE VICTORY!',
                                subtitle: 'Master of the Void',
                                message: 'You have conquered all 100 levels of the ULTIMATE VOID!',
                                playerName: currentUser ? currentUser.username : 'Anonymous Hero',
                                finalScore: score.toLocaleString(),
                                instruction: 'Press SPACE for Hall of Fame • H for Completionists • R to Reset'
                            };
                            return;
                        } else {
                            // Level setup already done in nextLevel() - just dismiss overlay
                            gameOverlay.active = false;
                        }
                    } else if (gameOverlay.type === 'gameOver') {
                        // Game over screen doesn't respond to click - use H/R keys instead
                        return;
                    } else if (gameOverlay.type === 'gameComplete') {
                        // Restart from level 1
                        resetGame();
                    } else if (gameOverlay.type === 'ultimateVictory') {
                        // Show Hall of Fame for ultimate victors
                        showRegularHallOfFame();
                    } else if (gameOverlay.type === 'completionistsHallOfFame') {
                        // Return to previous screen
                        gameOverlay.active = false;
                        gameStarted = false;
                    } else if (gameOverlay.type === 'levelReady') {
                        // Just dismiss the overlay, game continues
                    } else if (gameOverlay.type === 'paused') {
                        // Unpause the game
                        togglePause();
                        return; // togglePause handles overlay cleanup
                    } else if (gameOverlay.type === 'hallOfFame') {
                        // Close hall of fame and return to previous screen if it was shown from there
                        if (gameOverlay.returnToGameOver) {
                            if (gameOverlay.gameOverData.type === 'ultimateVictory') {
                                // Restore the ultimate victory screen
                                gameOverlay = {
                                    active: true,
                                    type: 'ultimateVictory',
                                    title: 'ULTIMATE VICTORY!',
                                    subtitle: 'Master of the Void',
                                    message: gameOverlay.gameOverData.message,
                                    playerName: gameOverlay.gameOverData.playerName,
                                    finalScore: gameOverlay.gameOverData.finalScore,
                                    instruction: 'Press SPACE for Hall of Fame • H for Completionists • R to Reset'
                                };
                            } else {
                                // Restore the game over screen
                                gameOverlay = {
                                    active: true,
                                    type: 'gameOver',
                                    title: '🎮 GAME OVER 🎮',
                                    playerName: gameOverlay.gameOverData.playerName,
                                    finalScore: gameOverlay.gameOverData.finalScore,
                                    levelReached: gameOverlay.gameOverData.levelReached,
                                    instruction: 'Press H for Hall of Fame or R to Reset'
                                };
                            }
                        } else {
                            // Just close the hall of fame overlay (called from start screen)
                            removeOverlayKeyHandler();
                        }
                    } else if (gameOverlay.type === 'completionistsHallOfFame') {
                        // Close completionist hall of fame and return to previous screen if it was shown from there
                        if (gameOverlay.returnToGameOver) {
                            if (gameOverlay.gameOverData.type === 'ultimateVictory') {
                                // Restore the ultimate victory screen
                                gameOverlay = {
                                    active: true,
                                    type: 'ultimateVictory',
                                    title: 'ULTIMATE VICTORY!',
                                    subtitle: 'Master of the Void',
                                    message: gameOverlay.gameOverData.message,
                                    playerName: gameOverlay.gameOverData.playerName,
                                    finalScore: gameOverlay.gameOverData.finalScore,
                                    instruction: 'Press SPACE for Hall of Fame • H for Completionists • R to Reset'
                                };
                            } else {
                                // Restore the game over screen
                                gameOverlay = {
                                    active: true,
                                    type: 'gameOver',
                                    title: '🎮 GAME OVER 🎮',
                                    playerName: gameOverlay.gameOverData.playerName,
                                    finalScore: gameOverlay.gameOverData.finalScore,
                                    levelReached: gameOverlay.gameOverData.levelReached,
                                    instruction: 'Press H for Hall of Fame or R to Reset'
                                };
                            }
                        } else {
                            // Just close the completionist hall of fame overlay (called from start screen)
                            removeOverlayKeyHandler();
                        }
                    } else if (gameOverlay.type === 'hallOfFameNoQualify') {
                        // Show game over screen with final details
                        const playerScore = gameOverlay.playerScore;
                        const playerLevel = gameOverlay.playerLevel;
                        const playerName = gameOverlay.playerName || 'Anonymous';
                        gameStarted = false; // Now it's safe to return to start screen
                        gameOverlay = {
                            active: true,
                            type: 'gameOver',
                            title: '🎮 GAME OVER 🎮',
                            playerName: playerName,
                            finalScore: playerScore ? playerScore.toLocaleString() : '0',
                            levelReached: playerLevel || 1,
                            message: `Final Score: ${playerScore ? playerScore.toLocaleString() : '0'}\nLevel Reached: ${playerLevel || 1}\nPlayer: ${playerName}\n\nYour score didn't make the top 10.`,
                            instruction: 'Click RESET button below to restart'
                        };
                        return;
                    }
                    
                    gameOverlay.active = false;
                    return;
                }
                
                if (!gameStarted) {
                    startGame();
                } else if (gameRunning && gameState.balls.length > 0) {
                    // Launch next ball in sequence or fire laser (same logic as space key)
                    const ballLaunched = launchNextBall();
                    if (!ballLaunched && paddle.laser) {
                        fireLaser();
                    }
                } else if (paddle.laser && gameRunning) {
                    fireLaser();
                }
            });
            
            // Add keyboard event listeners
            canvas.addEventListener('keydown', handleGameKeydown);
            canvas.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Add global keyboard handler for start screen (works even when canvas not focused)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'h' || e.key === 'H' || e.key === ' ') {
                    console.log('Document keydown:', e.key, 'gameStarted:', gameStarted, 'gameRunning:', gameRunning, 'gameOverlay.active:', gameOverlay.active);
                }
                
                // Handle start screen keys - allow Hall of Fame even if game was started before
                if (!gameRunning && !gameOverlay.active) {
                    if (e.key === ' ') {
                        e.preventDefault();
                        console.log('Space pressed - checking for challenge mode or starting game');
                        canvas.focus(); // Focus canvas for game controls
                        
                        // If challenge mode selection is open, handle it there
                        if (challengeModes.modeSelectionOpen) {
                            handleChallengeModeInput(e.key);
                        } else {
                            // Start classic mode by default
                            initializeChallengeMode('classic');
                            startGame();
                        }
                        return;
                    } else if (e.key === 'h' || e.key === 'H') {
                        e.preventDefault();
                        console.log('H key pressed from start screen - calling showRegularHallOfFame');
                        showRegularHallOfFame();
                        return;
                    } else if (e.key === 'c' || e.key === 'C') {
                        e.preventDefault();
                        console.log('C key pressed - opening challenge mode selection');
                        challengeModes.modeSelectionOpen = true;
                        challengeModes.selectedMode = 'classic';
                        return;
                    } else if (challengeModes.modeSelectionOpen) {
                        e.preventDefault();
                        handleChallengeModeInput(e.key);
                        return;
                    } else if (e.key === 'w' || e.key === 'W') {
                        e.preventDefault();
                        console.log('W key pressed - opening world map');
                        worldMapSystem.mapOpen = true;
                        return;
                    } else if (mysticalPowers.menuOpen) {
                        e.preventDefault();
                        handleMysticalPowersInput(e.key);
                        return;
                    } else if (e.key === 'p' || e.key === 'P') {
                        e.preventDefault();
                        console.log('P key pressed - opening player profile');
                        analyticsSystem.profileOpen = true;
                        return;
                    } else if (worldMapSystem.mapOpen) {
                        e.preventDefault();
                        handleWorldMapInput(e.key);
                        return;
                    } else if (analyticsSystem.profileOpen || analyticsSystem.replaySystem.playback) {
                        e.preventDefault();
                        handleAnalyticsInput(e.key);
                        return;
                    }
                }
            });
        }

        // Store current overlay handlers for keyboard events
        let overlayKeydownHandler = null;
        
        // Use canvas-specific keydown handlers
        let lastProcessedEvent = null;

        async function handleGameKeydown(e) {
            // Prevent duplicate processing of the same event
            if (lastProcessedEvent === e) {
                return;
            }
            lastProcessedEvent = e;
            
            // Clear the flag after a short delay to allow new events
            setTimeout(() => {
                if (lastProcessedEvent === e) {
                    lastProcessedEvent = null;
                }
            }, 10);
            
            // Handle keyboard events for game controls
            // Allow keyboard input when: canvas focused, game overlay active, or on start screen
            // But block if achievement gallery is open
            if (achievementGallery.galleryOpen) {
                // Only allow achievement gallery input
                if (handleAchievementGalleryInput(e.key)) {
                    e.preventDefault();
                }
                return;
            }
            
            if (document.activeElement !== canvas && !gameOverlay.active && gameStarted) {
                return;
            }
            
            // Handle name input for interactive hall of fame
            if (gameOverlay.active && gameOverlay.type === 'hallOfFameInput') {
                console.log('Hall of fame input - Key pressed:', e.key, 'Current input:', gameOverlay.inputName);
                
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // Prevent multiple simultaneous submissions
                    if (scoreSubmissionInProgress) {
                        console.log('Score submission already in progress, ignoring Enter press');
                        return;
                    }
                    
                    console.log('Enter pressed - submitting score');
                    scoreSubmissionInProgress = true; // Mark submission as in progress
                    
                    // Submit the score with the entered name
                    const finalName = gameOverlay.inputName.trim() || 'Anonymous';
                    const finalScore = gameOverlay.playerScore;
                    const finalLevel = gameOverlay.playerLevel;
                    
                    console.log('Submitting score:', finalName, finalScore, finalLevel);
                    
                    // Submit score directly (validation happens server-side)
                    try {
                        await submitScore(finalName, finalScore, finalLevel);
                        console.log('Score submitted successfully');
                        scoreSubmissionInProgress = false; // Reset flag on success
                    } catch (error) {
                        console.error('Score submission error:', error);
                        scoreSubmissionInProgress = false; // Reset flag on error
                        
                        // Check if this is a name-related error that we can handle gracefully
                        const errorMsg = error.message || error.toString();
                        if (errorMsg.includes('reserved for registered users') || 
                            errorMsg.includes('choose a different name') ||
                            errorMsg.includes('must use their registered username') ||
                            errorMsg.includes('Inappropriate player name')) {
                            
                            // Show error and return to name input
                            gameOverlay = {
                                active: true,
                                type: 'nameError',
                                title: '❌ NAME ISSUE ❌',
                                message: errorMsg.includes('Inappropriate') ? 
                                    'That name contains inappropriate content. Please choose a different name.' :
                                    'That name is reserved for registered users. Please choose a different name or log in.',
                                instruction: 'Press SPACE to try again with a different name',
                                returnToInput: true,
                                originalData: {
                                    playerScore: finalScore,
                                    playerLevel: finalLevel,
                                    playerRank: gameOverlay.playerRank,
                                    insertAtIndex: gameOverlay.insertAtIndex
                                }
                            };
                            return; // Don't continue to game over screen
                        }
                        
                        // For other errors, still continue to game over screen
                    }
                    
                    // Show game over screen
                    gameStarted = false; // Now it's safe to return to start screen
                    gameOverlay = {
                        active: true,
                        type: 'gameOver',
                        title: '🎮 GAME OVER 🎮',
                        playerName: finalName,
                        finalScore: finalScore,
                        levelReached: finalLevel,
                        instruction: 'Press H for Hall of Fame or R to Reset'
                    };
                    return;
                } else if (e.key === 'Backspace') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    gameOverlay.inputName = gameOverlay.inputName.slice(0, -1);
                    return;
                } else if (e.key.length === 1 && gameOverlay.inputName.length < 15) {
                    // Only allow printable characters and limit length
                    if (/^[a-zA-Z0-9\s!@#$%^&*()_+\-=\[\]{}|;':",./<>?`~]$/.test(e.key)) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        gameOverlay.inputName += e.key;
                    }
                    return;
                }
                return;
            }
            
            // Handle H and R keys for game over screen
            if (gameOverlay.active && gameOverlay.type === 'gameOver') {
                if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    // Store game over data and show hall of fame
                    const gameOverData = {
                        playerName: gameOverlay.playerName,
                        finalScore: gameOverlay.finalScore,
                        levelReached: gameOverlay.levelReached
                    };
                    showRegularHallOfFame(true, gameOverData);
                    return;
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    // Reset the game
                    resetGame();
                    return;
                }
                return; // Don't allow other keys for game over screen
            }
            
            // Handle ultimateVictory screen - special keys for 100% completion
            if (gameOverlay.active && gameOverlay.type === 'ultimateVictory') {
                if (e.key === ' ') {
                    e.preventDefault();
                    // Show regular Hall of Fame
                    showRegularHallOfFame(true, {
                        type: 'ultimateVictory',
                        playerName: gameOverlay.playerName,
                        finalScore: gameOverlay.finalScore,
                        message: gameOverlay.message
                    });
                    return;
                } else if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    // Show Completionists Hall of Fame
                    showCompletionistHallOfFame(true, {
                        type: 'ultimateVictory',
                        playerName: gameOverlay.playerName,
                        finalScore: gameOverlay.finalScore,
                        message: gameOverlay.message
                    });
                    return;
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    // Reset the game to level 1
                    resetGame();
                    return;
                }
                return; // Don't allow other keys for ultimate victory screen
            }
            
            // Handle completionists hall of fame screen
            if (gameOverlay.active && gameOverlay.type === 'completionistsHallOfFame') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    // Return to previous screen or start screen
                    gameOverlay.active = false;
                    gameStarted = false;
                    return;
                } else if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    // Navigate to regular hall of fame
                    showRegularHallOfFame(gameOverlay.returnToGameOver, gameOverlay.gameOverData);
                    return;
                }
                return; // Don't allow other keys for completionists screen
            }
            
            // Handle space key for hall of fame when player didn't qualify
            if (gameOverlay.active && gameOverlay.type === 'hallOfFameNoQualify') {
                if (e.key === ' ') {
                    e.preventDefault();
                    // Show game over screen with final details
                    const playerScore = gameOverlay.playerScore;
                    const playerLevel = gameOverlay.playerLevel;
                    const playerName = gameOverlay.playerName || 'Anonymous';
                    gameStarted = false; // Now it's safe to return to start screen
                    gameOverlay = {
                        active: true,
                        type: 'gameOver',
                        title: '🎮 GAME OVER 🎮',
                        playerName: playerName,
                        finalScore: playerScore ? playerScore.toLocaleString() : '0',
                        levelReached: playerLevel || 1,
                        message: `Final Score: ${playerScore ? playerScore.toLocaleString() : '0'}\nLevel Reached: ${playerLevel || 1}\nPlayer: ${playerName}\n\nYour score didn't make the top 10.`,
                        instruction: 'Press SPACE or CLICK to restart'
                    };
                    return;
                }
                return;
            }
            
            // Handle space key or enter for regular hall of fame (called from button)
            if (gameOverlay.active && gameOverlay.type === 'hallOfFame') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    // Check if we should return to game over screen
                    if (gameOverlay.returnToGameOver) {
                        // Restore the game over screen
                        gameOverlay = {
                            active: true,
                            type: 'gameOver',
                            title: '🎮 GAME OVER 🎮',
                            playerName: gameOverlay.gameOverData.playerName,
                            finalScore: gameOverlay.gameOverData.finalScore,
                            levelReached: gameOverlay.gameOverData.levelReached,
                            instruction: 'Press H for Hall of Fame or R to Reset'
                        };
                    } else {
                        // Just close the hall of fame overlay (called from start screen) - don't allow game start
                        gameOverlay.active = false;
                        removeOverlayKeyHandler();
                        // Ensure we stay on start screen, don't allow immediate restart  
                        gameStarted = false;
                    }
                    return;
                } else if (e.key === 'c' || e.key === 'C') {
                    e.preventDefault();
                    // Navigate to completionist hall of fame
                    showCompletionistHallOfFame(gameOverlay.returnToGameOver, gameOverlay.gameOverData);
                    return;
                }
                return;
            }
            
            
            // Prevent game input when achievement gallery is open
            if (achievementGallery.galleryOpen) {
                return; // Block all game input when achievement gallery is open
            }
            
            keys[e.key] = true;
            if (e.key === ' ') {
                // Only prevent default if not typing in an input field
                const activeElement = document.activeElement;
                const isInputField = activeElement && (
                    activeElement.tagName === 'INPUT' || 
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.contentEditable === 'true'
                );
                
                if (!isInputField) {
                    e.preventDefault();
                    
                    // Handle overlay dismissal first
                    if (gameOverlay.active) {
                        // Don't handle space for interactive hall of fame - only keyboard input
                        if (gameOverlay.type === 'hallOfFameInput') {
                            return;
                        }
                        if (gameOverlay.type === 'nameError') {
                            // Return to the input screen to try again
                            if (gameOverlay.returnToInput && gameOverlay.originalData) {
                                // Restore the input screen with original data
                                gameOverlay = {
                                    active: true,
                                    type: 'hallOfFameInput',
                                    title: '🏆 HALL OF FAME - TOP 10 🏆',
                                    scores: await getHighScores(10),
                                    playerScore: gameOverlay.originalData.playerScore,
                                    playerLevel: gameOverlay.originalData.playerLevel,
                                    playerRank: gameOverlay.originalData.playerRank,
                                    insertAtIndex: gameOverlay.originalData.insertAtIndex,
                                    inputName: '',
                                    cursorVisible: true,
                                    cursorBlinkTime: Date.now(),
                                    instruction: 'Type your name. Press ENTER to save your score'
                                };
                            } else {
                                gameOverlay.active = false;
                            }
                            return;
                        }
                        if (gameOverlay.type === 'levelComplete') {
                            // Continue to next level (level already incremented in nextLevel function)
                            if (level > totalLevels) {
                                // Ultimate game completion - all 100 levels cleared!
                                legitGameCompleted = true;
                                recordCompletionist(); // Record the completion
                                gameOverlay = {
                                    active: true,
                                    type: 'ultimateVictory',
                                    title: 'ULTIMATE VICTORY!',
                                    subtitle: 'Master of the Void',
                                    message: 'You have conquered all 100 levels of the ULTIMATE VOID!',
                                    playerName: currentUser ? currentUser.username : 'Anonymous Hero',
                                    finalScore: score.toLocaleString(),
                                    instruction: 'Press SPACE for Hall of Fame • H for Completionists • R to Reset'
                                };
                                return;
                            } else {
                                // Level setup already done in nextLevel() - just dismiss overlay
                                gameOverlay.active = false;
                            }
                        } else if (gameOverlay.type === 'gameOver') {
                            // Game over screen doesn't respond to space - use H/R keys instead
                            return;
                        } else if (gameOverlay.type === 'gameComplete') {
                            // Restart from level 1
                            resetGame();
                        } else if (gameOverlay.type === 'ultimateVictory') {
                            // Show Hall of Fame for ultimate victors
                            showRegularHallOfFame();
                        } else if (gameOverlay.type === 'levelReady') {
                            // Just dismiss the overlay, game continues
                        } else if (gameOverlay.type === 'paused') {
                            // Unpause the game
                            togglePause();
                            return; // togglePause handles overlay cleanup
                        } else if (gameOverlay.type === 'hallOfFame') {
                            // Check if we should return to previous screen
                            if (gameOverlay.returnToGameOver) {
                                if (gameOverlay.gameOverData.type === 'ultimateVictory') {
                                    // Restore the ultimate victory screen
                                    gameOverlay = {
                                        active: true,
                                        type: 'ultimateVictory',
                                        title: 'ULTIMATE VICTORY!',
                                        subtitle: 'Master of the Void',
                                        message: gameOverlay.gameOverData.message,
                                        playerName: gameOverlay.gameOverData.playerName,
                                        finalScore: gameOverlay.gameOverData.finalScore,
                                        instruction: 'Press SPACE for Hall of Fame • H for Completionists • R to Reset'
                                    };
                                } else {
                                    // Restore the game over screen
                                    gameOverlay = {
                                        active: true,
                                        type: 'gameOver',
                                        title: '🎮 GAME OVER 🎮',
                                        playerName: gameOverlay.gameOverData.playerName,
                                        finalScore: gameOverlay.gameOverData.finalScore,
                                        levelReached: gameOverlay.gameOverData.levelReached,
                                        instruction: 'Press H for Hall of Fame or R to Reset'
                                    };
                                }
                                return;
                            } else {
                                // Close hall of fame (called from start screen) - don't allow game start
                                gameOverlay.active = false;
                                // Ensure we stay on start screen, don't allow immediate restart
                                gameStarted = false;
                            }
                        } else if (gameOverlay.type === 'completionistsHallOfFame') {
                            // Check if we should return to previous screen
                            if (gameOverlay.returnToGameOver) {
                                if (gameOverlay.gameOverData.type === 'ultimateVictory') {
                                    // Restore the ultimate victory screen
                                    gameOverlay = {
                                        active: true,
                                        type: 'ultimateVictory',
                                        title: 'ULTIMATE VICTORY!',
                                        subtitle: 'Master of the Void',
                                        message: gameOverlay.gameOverData.message,
                                        playerName: gameOverlay.gameOverData.playerName,
                                        finalScore: gameOverlay.gameOverData.finalScore,
                                        instruction: 'Press SPACE for Hall of Fame • H for Completionists • R to Reset'
                                    };
                                } else {
                                    // Restore the game over screen
                                    gameOverlay = {
                                        active: true,
                                        type: 'gameOver',
                                        title: '🎮 GAME OVER 🎮',
                                        playerName: gameOverlay.gameOverData.playerName,
                                        finalScore: gameOverlay.gameOverData.finalScore,
                                        levelReached: gameOverlay.gameOverData.levelReached,
                                        instruction: 'Press H for Hall of Fame or R to Reset'
                                    };
                                }
                                return;
                            } else {
                                // Close completionist hall of fame (called from start screen)
                                gameOverlay.active = false;
                                gameStarted = false;
                            }
                        } else if (gameOverlay.type === 'hallOfFameNoQualify') {
                            // Show game over screen with final details
                            const playerScore = gameOverlay.playerScore;
                            const playerLevel = gameOverlay.playerLevel;
                            const playerName = gameOverlay.playerName || 'Anonymous';
                            gameOverlay = {
                                active: true,
                                type: 'gameOver',
                                title: '🎮 GAME OVER 🎮',
                                playerName: playerName,
                                finalScore: playerScore ? playerScore.toLocaleString() : '0',
                                levelReached: playerLevel || 1,
                                message: `Final Score: ${playerScore ? playerScore.toLocaleString() : '0'}\nLevel Reached: ${playerLevel || 1}\nPlayer: ${playerName}\n\nYour score didn't make the top 10.`,
                                instruction: 'Click RESET button below to restart'
                            };
                            return;
                        }
                        
                        gameOverlay.active = false;
                        return;
                    }
                    
                    if (!gameStarted && canvas) {
                        startGame();
                    } else if (gameRunning && gameState.balls.length > 0) {
                        // Launch next ball in sequence or fire laser
                        const ballLaunched = launchNextBall();
                        if (!ballLaunched && paddle.laser) {
                            fireLaser();
                        }
                    } else if (paddle.laser && gameRunning) {
                        fireLaser();
                    }
                }
            }
            if (e.key === 's' || e.key === 'S') {
                soundEnabled = !soundEnabled;
            }
            
            // Phase 3: Score banking controls
            if ((e.key === 'b' || e.key === 'B') && gameStarted && gameRunning && level >= 3) {
                e.preventDefault();
                bankCurrentScore();
            }
            if ((e.key === 'v' || e.key === 'V') && gameStarted && gameRunning && scoreBanking.bankedScore > 0) {
                e.preventDefault();
                withdrawBankedScore();
            }
            
            if ((e.key === 'Escape' || e.key === 'p' || e.key === 'P') && gameStarted && gameRunning && !mysticalPowers.menuOpen && !achievementGallery.galleryOpen && !upgradeShop.shopOpen) {
                e.preventDefault();
                togglePause();
            }
            
            // Handle upgrade shop
            if (handleShopInput(e.key)) {
                e.preventDefault();
                return;
            }
            
            // Handle achievement gallery
            if (handleAchievementGalleryInput(e.key)) {
                e.preventDefault();
                return;
            }
            
            // Open upgrade shop with 'U' key
            if ((e.key === 'u' || e.key === 'U') && gameStarted && !mysticalPowers.menuOpen) {
                e.preventDefault();
                openUpgradeShop();
                return;
            }
            
            // Check if achievement gallery is open and handle its input first
            if (achievementGallery.galleryOpen) {
                if (handleAchievementGalleryInput(e.key)) {
                    e.preventDefault();
                    return; // Achievement gallery handled the input, stop here
                }
            }
            
            // Open achievement gallery with 'J' key
            if ((e.key === 'j' || e.key === 'J') && gameStarted && !achievementGallery.galleryOpen) {
                e.preventDefault();
                openAchievementGallery();
                return;
            }
            
            // Open mystical powers menu with 'M' key (available during gameplay)
            if ((e.key === 'm' || e.key === 'M') && gameStarted && mysticalPowers.active && !mysticalPowers.menuOpen) {
                e.preventDefault();
                console.log('M key pressed during gameplay - opening mystical powers menu');
                mysticalPowers.menuOpen = true;
                mysticalPowers.wasGameRunning = gameRunning; // Remember if game was running
                if (gameRunning) {
                    gamePaused = true; // Pause the game while menu is open
                    console.log('Game paused for mystical powers menu');
                }
                return;
            }
            
            // Handle mystical powers menu input when menu is open
            if (mysticalPowers.menuOpen) {
                e.preventDefault();
                console.log('Mystical powers menu is open, handling input:', e.key);
                handleMysticalPowersInput(e.key);
                return;
            }
        }
        
        // Don't attach any global handlers - use dynamic handlers instead
        
        // Add overlay handler when needed
        function addOverlayKeyHandler() {
            if (!overlayKeydownHandler) {
                overlayKeydownHandler = (e) => handleGameKeydown(e);
                document.addEventListener('keydown', overlayKeydownHandler);
            }
        }
        
        // Remove overlay handler when not needed
        function removeOverlayKeyHandler() {
            if (overlayKeydownHandler) {
                document.removeEventListener('keydown', overlayKeydownHandler);
                overlayKeydownHandler = null;
            }
        }
        
        // Event listeners now added inside setupControls() function

        // Particle System
        function createParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 1.0,
                    decay: Math.random() * 0.02 + 0.01
                });
            }
        }

        function updateParticles(deltaMultiplier = 1) {
            gameState.particles = gameState.particles.filter(particle => {
                if (particle.type === 'lightning') {
                    // Lightning particles don't move, just fade out
                    particle.life -= deltaMultiplier * 10; // Decay faster for lightning
                    return particle.life > 0;
                } else {
                    // Regular particles move and decay
                    particle.x += particle.dx * deltaMultiplier;
                    particle.y += particle.dy * deltaMultiplier;
                    particle.dx *= 0.98;
                    particle.dy *= 0.98;
                    particle.life -= particle.decay;
                    return particle.life > 0;
                }
            });
        }

        function drawParticles() {
            if (!ctx) return;
            gameState.particles.forEach(particle => {
                if (particle.type === 'lightning') {
                    // Draw lightning bolt effect
                    const progress = 1 - (particle.life / particle.maxLife);
                    ctx.globalAlpha = particle.life / particle.maxLife;
                    ctx.strokeStyle = particle.color;
                    ctx.lineWidth = 3 - (progress * 2); // Fade out thickness
                    ctx.shadowColor = particle.color;
                    ctx.shadowBlur = 10;
                    
                    // Draw jagged lightning bolt
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y);
                    
                    // Create jagged path
                    const segments = 5;
                    const dx = (particle.targetX - particle.x) / segments;
                    const dy = (particle.targetY - particle.y) / segments;
                    
                    for (let i = 1; i < segments; i++) {
                        const offsetX = (Math.random() - 0.5) * 20;
                        const offsetY = (Math.random() - 0.5) * 20;
                        ctx.lineTo(
                            particle.x + dx * i + offsetX,
                            particle.y + dy * i + offsetY
                        );
                    }
                    ctx.lineTo(particle.targetX, particle.targetY);
                    ctx.stroke();
                    
                    // Add glow effect
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = (particle.life / particle.maxLife) * 0.5;
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                } else {
                    // Regular particle
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;
                    ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                }
            });
            ctx.globalAlpha = 1.0;
        }

        // Score Popup System
        function createScorePopup(x, y, points, combo = 1) {
            gameState.scorePopups.push({
                x: x,
                y: y,
                points: points,
                combo: combo,
                life: 2.0, // 2 second lifetime
                startY: y,
                color: combo >= 100 ? '#8B00FF' : combo >= 25 ? '#FF4500' : combo >= 5 ? '#FF8C00' : combo >= 3 ? '#FFD700' : '#FFFFFF'
            });
        }

        function updateScorePopups(deltaMultiplier = 1) {
            gameState.scorePopups = gameState.scorePopups.filter(popup => {
                popup.life -= 0.02 * deltaMultiplier; // Fade over time
                popup.y = popup.startY - (2.0 - popup.life) * 40; // Float upward
                return popup.life > 0;
            });
        }

        function drawScorePopups() {
            if (!ctx) return;
            gameState.scorePopups.forEach(popup => {
                ctx.save();
                ctx.globalAlpha = popup.life / 2.0;
                ctx.fillStyle = popup.color;
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                
                // Add glow for high combo scores
                if (popup.combo >= 5) {
                    ctx.shadowColor = popup.color;
                    ctx.shadowBlur = 6;
                }
                
                const text = popup.combo > 1 ? `${popup.points} (${popup.combo}x)` : `${popup.points}`;
                ctx.fillText(text, popup.x, popup.y);
                ctx.restore();
            });
        }

        // Power-up System
        // Add powerup timing control
        let lastPowerUpSpawnTime = 0;
        const POWERUP_SPAWN_DELAY = 1000; // 1 second delay between spawns
        const MAX_SIMULTANEOUS_POWERUPS = 4; // Maximum 4 powerups falling at once

        function spawnPowerUp(x, y, forceSpawn = false) {
            const currentTime = Date.now();
            
            // Check timing constraints
            if (currentTime - lastPowerUpSpawnTime < POWERUP_SPAWN_DELAY) {
                return; // Too soon since last powerup
            }
            
            // Count non-laser powerups currently falling
            const fallingPowerUps = gameState.powerUps.filter(p => !p.isLaser).length;
            if (fallingPowerUps >= MAX_SIMULTANEOUS_POWERUPS) {
                return; // Too many powerups already falling
            }
            
            // Phase 3: Apply difficulty-adjusted spawn rate
            const baseSpawnRate = 0.8; // 80% base chance
            const adjustedSpawnRate = forceSpawn ? 1.0 : Math.min(0.9, getDifficultyAdjustedSpawnRate());
            
            if (forceSpawn || Math.random() < adjustedSpawnRate) {
                // Filter out extralife if it's on cooldown
                let availablePowerUps = powerUpTypes;
                if (currentTime - lastExtraLifeSpawn < EXTRA_LIFE_COOLDOWN) {
                    availablePowerUps = powerUpTypes.filter(type => type.type !== 'extralife');
                }
                
                const totalChance = availablePowerUps.reduce((sum, type) => sum + type.chance, 0);
                let random = Math.random() * totalChance;
                
                for (const type of availablePowerUps) {
                    random -= type.chance;
                    if (random <= 0) {
                        gameState.powerUps.push({
                            x: x,
                            y: y,
                            type: type.type,
                            color: type.color,
                            symbol: type.symbol,
                            dy: 2
                        });
                        lastPowerUpSpawnTime = currentTime; // Update last spawn time
                        
                        // Track extralife spawn time
                        if (type.type === 'extralife') {
                            lastExtraLifeSpawn = currentTime;
                        }
                        break;
                    }
                }
            }
        }
        
        // Helper function for consistent powerup spawning on block hits
        function trySpawnPowerUpOnHit(x, y) {
            if (Math.random() < 0.7) { // 70% chance on any block hit (increased from 30%)
                spawnPowerUp(x, y, false); // Use normal spawn logic with timing constraints
            }
        }

        function updatePowerUps(deltaMultiplier = 1) {
            gameState.powerUps = gameState.powerUps.filter(powerUp => {
                powerUp.y += powerUp.dy * deltaMultiplier * SPEED_MULTIPLIER;
                
                // Handle laser beams differently
                if (powerUp.isLaser) {
                    // Remove laser beams that go off screen
                    return powerUp.y > 0;
                }
                
                // Check collision with paddle for regular power-ups
                if (powerUp.y + 10 > paddle.y &&
                    powerUp.x > paddle.x &&
                    powerUp.x < paddle.x + paddle.width) {
                    
                    activatePowerUp(powerUp.type);
                    playSound('powerup');
                    createParticles(powerUp.x, powerUp.y, powerUp.color, 12);
                    return false; // Remove power-up
                }
                
                return powerUp.y < canvas.height; // Keep if still on screen
            });
        }

        function showPowerUpFeedback(message, color = '#FFFFFF') {
            const lineHeight = 20; // Space between lines
            const rightMargin = canvas.width - 20; // Right side of screen with margin
            const startY = canvas.height * 0.55; // Moved lower - better middle position
            
            // Push existing messages down
            gameState.feedbackMessages.forEach(msg => {
                msg.targetY += lineHeight;
            });
            
            // Add new message at the top
            gameState.feedbackMessages.push({
                text: message,
                x: rightMargin, // Right side with margin
                y: startY,
                targetY: startY,
                color: color,
                alpha: 1.0,
                scale: 0.1, // Start small
                maxScale: 1.0,
                duration: 300, // 5 seconds at 60fps
                frame: 0
            });
            
            // Remove messages that have been pushed too far down (max 8 lines)
            const maxY = startY + (lineHeight * 7); // 8 lines total (0-7)
            gameState.feedbackMessages = gameState.feedbackMessages.filter(msg => msg.targetY <= maxY);
        }

        function updateFeedbackMessages(deltaMultiplier = 1) {
            gameState.feedbackMessages = gameState.feedbackMessages.filter(msg => {
                msg.frame += deltaMultiplier;
                
                // Smooth vertical movement animation
                const moveSpeed = 0.15 * deltaMultiplier; // How fast messages slide to their target position
                if (Math.abs(msg.y - msg.targetY) > 0.5) {
                    msg.y += (msg.targetY - msg.y) * moveSpeed;
                } else {
                    msg.y = msg.targetY;
                }
                
                // Scale animation: grow quickly to full size
                if (msg.frame < 8) {
                    msg.scale = (msg.frame / 8) * msg.maxScale;
                } else if (msg.frame > msg.duration - 90) {
                    // Fade out over last 1.5 seconds (90 frames)
                    const fadeFrames = msg.duration - msg.frame;
                    msg.alpha = fadeFrames / 90;
                } else {
                    msg.scale = msg.maxScale;
                    msg.alpha = 1.0;
                }
                
                // Remove if duration exceeded
                return msg.frame < msg.duration;
            });
        }

        function drawFeedbackMessages() {
            if (!ctx) return;
            gameState.feedbackMessages.forEach(msg => {
                ctx.save();
                ctx.globalAlpha = msg.alpha;
                ctx.font = `bold ${Math.floor(13 * msg.scale)}px "Press Start 2P", monospace`;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                
                // Simple glow effect
                ctx.shadowColor = msg.color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = msg.color;
                ctx.fillText(msg.text, msg.x, msg.y);
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // Draw thin black outline for contrast
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeText(msg.text, msg.x, msg.y);
                
                // Draw bright main text in the powerup color
                ctx.fillStyle = msg.color;
                ctx.fillText(msg.text, msg.x, msg.y);
                
                ctx.restore();
            });
        }

        function activatePowerUp(type) {
            sessionStats.powerupsCollected++;
            trackPowerupUsed(type);
            switch (type) {
                case 'multiball':
                    showPowerUpFeedback('MULTIBALL!', '#00FFFF');
                    
                    // If sticky paddle is active, release ALL stuck balls simultaneously
                    if (paddle.sticky) {
                        gameState.balls.forEach(ball => {
                            if (ball.stuckToPaddle) {
                                // Properly release the stuck ball with random trajectory
                                ball.stuckToPaddle = false; // Clear stuck state FIRST
                                ball.launched = true;        // Then set launched
                                ball.stickOrder = undefined;
                                ball.stickOffset = undefined;
                                
                                // Launch with random angle (not horizontal!)
                                const angle = (Math.random() - 0.5) * Math.PI * 0.8; // Random angle between -72 and 72 degrees
                                ball.dx = Math.sin(angle) * ball.speed;
                                ball.dy = -Math.abs(Math.cos(angle)) * ball.speed; // Always upward
                                
                                // Apply pending speed multiplier if any (from speedball powerups collected while stuck)
                                if (ball.pendingSpeedMultiplier && ball.pendingSpeedMultiplier > 1) {
                                    ball.dx *= ball.pendingSpeedMultiplier;
                                    ball.dy *= ball.pendingSpeedMultiplier;
                                    ball.pendingSpeedMultiplier = undefined; // Clear after applying
                                }
                                
                                ball.trail = [];
                            }
                        });
                    }
                    
                    // Apply to ALL active balls (launched OR stuck to paddle)
                    if (gameState.balls.length < 15) { // Increased limit for multiple balls
                        const currentBalls = [...gameState.balls]; // Copy current balls array
                        for (let ballIndex = 0; ballIndex < currentBalls.length; ballIndex++) {
                            const sourceBall = currentBalls[ballIndex];
                            // Include both launched balls and balls that were stuck to paddle
                            if (!sourceBall.launched && !sourceBall.stuckToPaddle) continue; // Skip only truly unlaunched balls
                            
                            // Create 2 new balls for each existing ball
                            for (let i = 0; i < 2; i++) {
                                const newBall = { ...ballTemplate };
                                newBall.x = sourceBall.x + (Math.random() - 0.5) * 50;
                                newBall.y = sourceBall.y;
                                // Set speed based on source ball's current speed (accounts for slow effect)
                                let newBallSpeed = sourceBall.speed || ballTemplate.speed;
                                // Apply ball speed upgrade
                                const speedUpgrade = getUpgradeEffect('ball_speed');
                                if (speedUpgrade > 0) {
                                    newBallSpeed *= (1 + speedUpgrade * 0.15);
                                }
                                newBall.dx = (Math.random() - 0.5) * 8;
                                newBall.dy = -newBallSpeed;
                                newBall.speed = newBallSpeed;
                                newBall.launched = true;
                                newBall.trail = [];
                                newBall.mega = sourceBall.mega; // Inherit mega status
                                newBall.megaStartTime = sourceBall.megaStartTime; // Inherit mega start time
                                newBall.megaDuration = sourceBall.megaDuration; // Inherit mega duration
                                newBall.rocket = sourceBall.rocket; // Inherit rocket status
                                newBall.rocketStartTime = sourceBall.rocketStartTime; // Inherit rocket start time
                                newBall.rocketDuration = sourceBall.rocketDuration; // Inherit rocket duration
                                newBall.slow = sourceBall.slow; // Inherit slow status
                                newBall.slowStartTime = sourceBall.slowStartTime; // Inherit slow start time
                                newBall.slowDuration = sourceBall.slowDuration; // Inherit slow duration
                                newBall.originalSpeed = sourceBall.originalSpeed; // Inherit original speed
                                
                                // Check for active element override enchantments
                                if (mysticalPowers.active) {
                                    const elementOverride = mysticalPowers.activeEnchantments.find(
                                        e => e.effects && e.effects.elementOverride
                                    );
                                    if (elementOverride) {
                                        const element = elementOverride.effects.elementOverride;
                                        newBall.element = element;
                                        if (element !== 'normal' && mysticalPowers.elementalBalls[element]) {
                                            const elementData = mysticalPowers.elementalBalls[element];
                                            newBall.color = elementData.color;
                                            newBall.trailColor = elementData.trailColor;
                                            
                                            // Set up elemental effects
                                            newBall.elementalEffects = {};
                                            if (element === 'fire') {
                                                newBall.elementalEffects.burnRadius = elementData.effects.igniteRadius;
                                                newBall.elementalEffects.burnDamage = elementData.effects.burnDamage;
                                            } else if (element === 'ice') {
                                                newBall.elementalEffects.freezeRadius = elementData.effects.freezeRadius;
                                                newBall.elementalEffects.slowFactor = elementData.effects.slowFactor;
                                            } else if (element === 'lightning') {
                                                newBall.elementalEffects.chainRange = elementData.effects.chainRange;
                                                newBall.elementalEffects.maxChains = elementData.effects.maxChains;
                                            } else if (element === 'void') {
                                                newBall.elementalEffects.phaseChance = elementData.effects.phaseChance;
                                                newBall.elementalEffects.voidDamage = elementData.effects.voidDamage;
                                            }
                                        }
                                    } else {
                                        // Inherit element from source ball if no override
                                        newBall.element = sourceBall.element;
                                        newBall.elementalEffects = sourceBall.elementalEffects ? {...sourceBall.elementalEffects} : {};
                                    }
                                }
                                
                                gameState.balls.push(newBall);
                            }
                        }
                    }
                    break;
                case 'bigpaddle':
                    showPowerUpFeedback('BIG PADDLE!', '#00BFFF');
                    // Increase paddle size with limits
                    paddleSizeLevel = Math.min(4, paddleSizeLevel + 1);
                    {
                        const minPaddleWidth = ballTemplate.radius * 2; // Minimum: ball width
                        const defaultPaddleWidth = paddle.originalWidth; // Default: 188
                        const maxPaddleWidth = paddle.originalWidth * 2; // Maximum: 4 notches up
                        const sizeStep = (defaultPaddleWidth - minPaddleWidth) / 4; // Step size for levels -4 to 0
                        const bigSizeStep = (maxPaddleWidth - defaultPaddleWidth) / 4; // Step size for levels 0 to +4
                        
                        if (paddleSizeLevel <= 0) {
                            paddle.width = Math.max(minPaddleWidth, defaultPaddleWidth + paddleSizeLevel * sizeStep);
                        } else {
                            paddle.width = Math.min(maxPaddleWidth, defaultPaddleWidth + paddleSizeLevel * bigSizeStep);
                        }
                    }
                    paddle.powerUpTimer = 600; // 10 seconds at 60fps
                    break;
                case 'laser':
                    // Check if paddle is at the absolute minimum size
                    const absoluteMinPaddle = ballTemplate.radius * 2;
                    if (paddle.width <= absoluteMinPaddle) {
                        showPowerUpFeedback('LASER BLOCKED - Paddle too small!', '#FF4444');
                        // Powerup is consumed but has no effect
                        break;
                    }
                    showPowerUpFeedback('LASER!', '#FFD700');
                    paddle.laser = true;
                    paddle.powerUpTimer = 600; // 10 seconds
                    break;
                case 'sticky':
                    showPowerUpFeedback('STICKY PADDLE!', '#00FF7F');
                    paddle.sticky = true;
                    paddle.powerUpTimer = 900; // 15 seconds
                    break;
                case 'extralife':
                    showPowerUpFeedback('+1 LIFE!', '#FF1493');
                    lives++;
                    updateUI();
                    playSound('life');
                    break;
                case 'smallpaddle':
                    showPowerUpFeedback('SMALL PADDLE!', '#FF8C94');
                    // Decrease paddle size with limits
                    paddleSizeLevel = Math.max(-4, paddleSizeLevel - 1);
                    {
                        const minPaddleWidth = ballTemplate.radius * 2; // Minimum: ball width
                        const defaultPaddleWidth = paddle.originalWidth; // Default: 188
                        const maxPaddleWidth = paddle.originalWidth * 2; // Maximum: 4 notches up
                        const sizeStep = (defaultPaddleWidth - minPaddleWidth) / 4; // Step size for levels -4 to 0
                        const bigSizeStep = (maxPaddleWidth - defaultPaddleWidth) / 4; // Step size for levels 0 to +4
                        
                        if (paddleSizeLevel <= 0) {
                            paddle.width = Math.max(minPaddleWidth, defaultPaddleWidth + paddleSizeLevel * sizeStep);
                        } else {
                            paddle.width = Math.min(maxPaddleWidth, defaultPaddleWidth + paddleSizeLevel * bigSizeStep);
                        }
                    }
                    paddle.powerUpTimer = 900; // 15 seconds
                    break;
                case 'speedball':
                    showPowerUpFeedback('SPEED BALL!', '#A8E6CF');
                    // Increase ball speed temporarily with timer (mirroring slowball behavior)
                    gameState.balls.forEach(ball => {
                        const speedMultiplier = 1.3; // 30% speed increase
                        
                        // Store original speed if not already speeded up
                        if (!ball.speedUp) {
                            ball.originalSpeedForSpeedUp = ball.speed;
                        }
                        
                        ball.speedUp = true;
                        ball.speedUpStartTime = Date.now();
                        ball.speedUpDuration = (gameConfig.speedball_duration || 8) * 1000; // Configurable duration in milliseconds
                        ball.speed = ball.originalSpeedForSpeedUp * speedMultiplier;
                        
                        // Check if ball is stuck to paddle (velocity is zero)
                        if (ball.stuckToPaddle && ball.dx === 0 && ball.dy === 0) {
                            // Store pending speed multiplier for when ball is launched
                            ball.pendingSpeedMultiplier = (ball.pendingSpeedMultiplier || 1) * speedMultiplier;
                        } else {
                            // Ball is moving, apply speed boost to current velocity
                            const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                            if (currentSpeed > 0) {
                                const length = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                                ball.dx = (ball.dx / length) * ball.speed;
                                ball.dy = (ball.dy / length) * ball.speed;
                            }
                        }
                    });
                    break;
                case 'slowball':
                    showPowerUpFeedback('SLOW BALL!', '#00CED1');
                    gameState.balls.forEach(ball => {
                        ball.slow = true;
                        ball.slowStartTime = Date.now();
                        ball.slowDuration = 5000; // 5 seconds in milliseconds
                        ball.originalSpeed = ball.speed; // Store original speed
                        ball.speed = Math.max(ball.speed * 0.7, 2);
                        const length = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        ball.dx = (ball.dx / length) * ball.speed;
                        ball.dy = (ball.dy / length) * ball.speed;
                    });
                    break;
                case 'megaball':
                    showPowerUpFeedback('EXPLOSIVE BALL!', '#FF4500');
                    gameState.balls.forEach(ball => {
                        ball.mega = true;
                        ball.megaStartTime = Date.now(); // Store start time in milliseconds
                        ball.megaDuration = 6000; // 6 seconds in milliseconds
                    });
                    break;
                case 'rocket':
                    showPowerUpFeedback('ROCKET BALL!', '#FFD700');
                    gameState.balls.forEach(ball => {
                        ball.rocket = true;
                        ball.rocketStartTime = Date.now(); // Store start time in milliseconds
                        ball.rocketDuration = 8000; // 8 seconds in milliseconds
                    });
                    break;
                // New combo multiplier pickups
                case 'combo2x':
                    // Check for mega combo event override
                    const combo2xMultiplier = getComboOverride() || 2;
                    applyTempComboMultiplier(combo2xMultiplier, 8000); // 2x for 8 seconds (or 10x during mega combo)
                    break;
                case 'combo5x':
                    // Check for mega combo event override
                    const combo5xMultiplier = getComboOverride() || 5;
                    applyTempComboMultiplier(combo5xMultiplier, 6000); // 5x for 6 seconds (or 10x during mega combo)
                    break;
                case 'combo10x':
                    // Check for mega combo event override (already 10x, but extend duration during event)
                    const combo10xMultiplier = getComboOverride() || 10;
                    const combo10xDuration = getComboOverride() ? 6000 : 4000; // Extended duration during mega combo
                    applyTempComboMultiplier(combo10xMultiplier, combo10xDuration);
                    break;
            }
        }

        // New function for combo multiplier system
        function applyTempComboMultiplier(multiplier, duration) {
            gameState.tempComboMultiplier = multiplier;
            gameState.tempComboDuration = duration;
            gameState.tempComboStartTime = Date.now();
            gameState.tempComboTimer = duration;
            
            // Visual feedback with enhanced effects for higher multipliers
            const colors = {
                2: '#FF6B35',
                5: '#F7931E', 
                10: '#FFD700'
            };
            
            const messages = {
                2: 'COMBO 2X BOOST!',
                5: 'COMBO 5X BOOST!',
                10: 'COMBO 10X BOOST!'
            };
            
            showPowerUpFeedback(messages[multiplier], colors[multiplier]);
            
            // Add some screen shake for dramatic effect
            gameState.screenShake = Math.min(multiplier * 2, 12);
        }

        // Update function to handle temp combo multiplier decay
        function updateTempComboMultiplier() {
            if (gameState.tempComboTimer > 0) {
                gameState.tempComboTimer -= 16.67; // Assume 60fps (~16.67ms per frame)
                if (gameState.tempComboTimer <= 0) {
                    gameState.tempComboMultiplier = 1;
                    gameState.tempComboTimer = 0;
                    gameState.tempComboDuration = 0;
                    gameState.tempComboStartTime = 0;
                }
            }
        }

        async function initBlocks() {
            blocks.length = 0;
            await generateBlocksForLevelAsync(level);
        }
        
        // Synchronous fallback for compatibility
        function initBlocksSync() {
            blocks.length = 0;
            generateBlocksForLevelOriginal(level);
        }

        // Color theme definitions
        const colorThemes = {
            rainbow: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'],
            ocean: ['#001F3F', '#003A70', '#0074D9', '#39CCCC', '#7FDBFF', '#85DCB0', '#B3E5FC'],
            sunset: ['#FF6B35', '#F7931E', '#FCEE21', '#FF9F1C', '#FF4E50', '#FC913A', '#F9D423'],
            nature: ['#355E3B', '#4F7942', '#228B22', '#32CD32', '#7CFC00', '#ADFF2F', '#9ACD32'],
            space: ['#0B0C10', '#1F2833', '#45A29E', '#66FCF1', '#C5C6C7', '#1F2833', '#0B0C10'],
            neon: ['#FF00FF', '#00FFFF', '#FF00AA', '#00FF00', '#FFFF00', '#FF0099', '#00FFAA'],
            pastel: ['#FFB6C1', '#FFC0CB', '#FFE4E1', '#F0E68C', '#E6E6FA', '#D8BFD8', '#F5DEB3']
        };

        // Pattern helper functions
        function createSpiral(theme, currentLevel, hitModifier = 1) {
            const colors = colorThemes[theme] || colorThemes.rainbow;
            let colorIndex = 0;
            let top = 0, bottom = blockRows - 1, left = 0, right = blockCols - 1;
            let spiralLevel = 0;
            
            while (top <= bottom && left <= right) {
                const currentColor = colors[colorIndex % colors.length];
                const requestedHits = Math.min(4, 1 + Math.floor(spiralLevel / 2)) * hitModifier;
                const hits = getBlockHitCount(currentLevel, requestedHits);
                
                // Top row
                for (let col = left; col <= right; col++) {
                    blocks.push(createBlock(col, top, hits, 'normal', currentColor));
                }
                top++;
                
                // Right column
                for (let row = top; row <= bottom; row++) {
                    blocks.push(createBlock(right, row, hits, 'normal', currentColor));
                }
                right--;
                
                // Bottom row
                if (top <= bottom) {
                    for (let col = right; col >= left; col--) {
                        blocks.push(createBlock(col, bottom, hits, 'normal', currentColor));
                    }
                    bottom--;
                }
                
                // Left column
                if (left <= right) {
                    for (let row = bottom; row >= top; row--) {
                        blocks.push(createBlock(left, row, hits, 'normal', currentColor));
                    }
                    left++;
                }
                
                colorIndex++;
                spiralLevel++;
            }
        }

        function createDiamond(theme, currentLevel, filled = true, hitModifier = 1) {
            const colors = colorThemes[theme] || colorThemes.rainbow;
            const centerRow = Math.floor(blockRows / 2);
            const centerCol = Math.floor(blockCols / 2);
            
            for (let row = 0; row < blockRows; row++) {
                const colorIndex = row % colors.length;
                const currentColor = colors[colorIndex];
                const rowDist = Math.abs(row - centerRow);
                const width = blockCols - rowDist * 4;
                
                if (width > 0) {
                    const start = Math.floor((blockCols - width) / 2);
                    const end = start + width - 1;
                    
                    if (filled) {
                        for (let col = start; col <= end; col++) {
                            const hits = getBlockHitCount(currentLevel, Math.min(4, 1 + Math.floor(rowDist / 2)) * hitModifier);
                            blocks.push(createBlock(col, row, hits, 'normal', currentColor));
                        }
                    } else {
                        // Only edges
                        if (start >= 0 && start < blockCols) {
                            blocks.push(createBlock(start, row, getBlockHitCount(currentLevel, 2 * hitModifier), 'normal', currentColor));
                        }
                        if (end >= 0 && end < blockCols && end !== start) {
                            blocks.push(createBlock(end, row, getBlockHitCount(currentLevel, 2 * hitModifier), 'normal', currentColor));
                        }
                    }
                }
            }
        }

        function createCheckerboard(theme, currentLevel, size = 2, hitModifier = 1) {
            const colors = colorThemes[theme] || colorThemes.rainbow;
            
            for (let row = 0; row < blockRows; row++) {
                for (let col = 0; col < blockCols; col++) {
                    const checkRow = Math.floor(row / size);
                    const checkCol = Math.floor(col / size);
                    
                    if ((checkRow + checkCol) % 2 === 0) {
                        const colorIndex = ((checkRow * 3) + checkCol) % colors.length;
                        const hits = getBlockHitCount(currentLevel, 1 + (row % 2) * hitModifier);
                        blocks.push(createBlock(col, row, hits, 'normal', colors[colorIndex]));
                    }
                }
            }
        }

        function createWavePattern(theme, currentLevel, amplitude = 2, frequency = 0.5, hitModifier = 1) {
            const colors = colorThemes[theme] || colorThemes.rainbow;
            
            for (let col = 0; col < blockCols; col++) {
                const wave = Math.sin(col * frequency) * amplitude;
                const centerRow = Math.floor(blockRows / 2);
                
                for (let row = 0; row < blockRows; row++) {
                    const distance = Math.abs(row - (centerRow + wave));
                    
                    if (distance <= amplitude) {
                        const colorIndex = Math.floor(distance + col / 3) % colors.length;
                        const hits = getBlockHitCount(currentLevel, Math.min(4, 1 + Math.floor(distance)) * hitModifier);
                        blocks.push(createBlock(col, row, hits, 'normal', colors[colorIndex]));
                    }
                }
            }
        }

        function createGradientPattern(theme, currentLevel, direction = 'horizontal', hitModifier = 1) {
            const colors = colorThemes[theme] || colorThemes.rainbow;
            
            for (let row = 0; row < blockRows; row++) {
                for (let col = 0; col < blockCols; col++) {
                    let colorIndex;
                    
                    if (direction === 'horizontal') {
                        colorIndex = Math.floor(col * colors.length / blockCols);
                    } else if (direction === 'vertical') {
                        colorIndex = Math.floor(row * colors.length / blockRows);
                    } else if (direction === 'diagonal') {
                        colorIndex = Math.floor((row + col) * colors.length / (blockRows + blockCols));
                    } else if (direction === 'radial') {
                        const centerRow = blockRows / 2;
                        const centerCol = blockCols / 2;
                        const distance = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2));
                        const maxDistance = Math.sqrt(Math.pow(centerRow, 2) + Math.pow(centerCol, 2));
                        colorIndex = Math.floor(distance * colors.length / maxDistance);
                    }
                    
                    colorIndex = Math.min(colorIndex, colors.length - 1);
                    const hits = getBlockHitCount(currentLevel, 1 + Math.floor(colorIndex / 2) * hitModifier);
                    blocks.push(createBlock(col, row, hits, 'normal', colors[colorIndex]));
                }
            }
        }

        function createPixelArt(artData, theme, currentLevel, hitModifier = 1) {
            const colors = colorThemes[theme] || colorThemes.rainbow;
            
            for (let row = 0; row < Math.min(artData.length, blockRows); row++) {
                for (let col = 0; col < Math.min(artData[row].length, blockCols); col++) {
                    if (artData[row][col] > 0) {
                        const colorIndex = (artData[row][col] - 1) % colors.length;
                        const hits = getBlockHitCount(currentLevel, artData[row][col] * hitModifier);
                        blocks.push(createBlock(col, row, hits, 'normal', colors[colorIndex]));
                    }
                }
            }
        }

        // New async level generation function
        async function generateBlocksForLevelAsync(currentLevel) {
            // Clear existing blocks
            blocks.length = 0;
            
            // Try to load from external JSON first (for levels 1-10)
            if (levelManager && USE_EXTERNAL_LEVELS && currentLevel <= 10) {
                try {
                    const startTime = performance.now();
                    const levelData = await levelManager.loadLevel(currentLevel);
                    
                    if (levelData && levelData.blocks) {
                        // Convert JSON blocks to game format
                        const gameBlocks = levelManager.convertBlocksToGameFormat(
                            levelData.blocks,
                            { blockWidth, blockHeight, blockPadding }
                        );
                        
                        // Add blocks to the game
                        blocks.push(...gameBlocks);
                        
                        const loadTime = performance.now() - startTime;
                        console.log(`✅ Level ${currentLevel} loaded from JSON in ${loadTime.toFixed(2)}ms (${gameBlocks.length} blocks)`);
                        return; // Successfully loaded from JSON
                    }
                } catch (error) {
                    console.warn(`⚠️ Failed to load level ${currentLevel} from JSON:`, error.message);
                    console.log(`🔄 Falling back to procedural generation for level ${currentLevel}`);
                }
            }
            
            // Fallback to original procedural generation
            generateBlocksForLevelOriginal(currentLevel);
        }
        
        // Original synchronous level generation function (renamed for fallback)
        function generateBlocksForLevelOriginal(currentLevel) {
            // Clear existing blocks
            blocks.length = 0;
            
            // Check for boss levels first
            if (isBossLevel(currentLevel)) {
                if (initializeBoss(currentLevel)) {
                    return; // Boss initialization handled block creation
                }
            }
            
            // Define 100 unique levels
            switch(currentLevel) {
                // Levels 1-10: Introduction patterns (simple but visually interesting)
                case 1:
                    // Rainbow rows - simple horizontal stripes
                    createGradientPattern('rainbow', currentLevel, 'horizontal', 1);
                    break;
                    
                case 2:
                    // Ocean waves - gentle wave pattern
                    createWavePattern('ocean', currentLevel, 1.5, 0.3, 1);
                    break;
                    
                case 3:
                    // Pastel checkerboard - large squares
                    createCheckerboard('pastel', currentLevel, 3, 1);
                    break;
                    
                case 4:
                    // Small diamond outline
                    createDiamond('sunset', currentLevel, false, 1);
                    break;
                    
                case 5:
                    // Nature gradient - vertical
                    createGradientPattern('nature', currentLevel, 'vertical', 1);
                    break;
                    
                case 6:
                    // Simple spiral - single layer
                    const colors6 = colorThemes.neon;
                    let colorIdx6 = 0;
                    for (let row = 0; row < 3; row++) {
                        for (let col = 2; col < blockCols - 2; col++) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 1), 'normal', colors6[colorIdx6 % colors6.length]));
                            colorIdx6++;
                        }
                    }
                    break;
                    
                case 7:
                    // Heart shape (simple pixel art)
                    const heart = [
                        [0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0],
                        [1,2,2,1,0,1,2,2,1,0,1,2,2,1,0,1,2,2,1,0],
                        [1,2,2,2,1,2,2,2,1,0,1,2,2,2,1,2,2,2,1,0],
                        [0,1,2,2,2,2,2,1,0,0,0,1,2,2,2,2,2,1,0,0],
                        [0,0,1,2,2,2,1,0,0,0,0,0,1,2,2,2,1,0,0,0],
                        [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0,0],
                        [0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ];
                    createPixelArt(heart, 'sunset', currentLevel, 1);
                    break;
                    
                case 8:
                    // Diagonal gradient stripes
                    createGradientPattern('space', currentLevel, 'diagonal', 1);
                    break;
                    
                case 9:
                    // Small checkerboard pattern
                    createCheckerboard('rainbow', currentLevel, 2, 1);
                    break;
                    
                case 10:
                    // Radial gradient (bullseye)
                    createGradientPattern('ocean', currentLevel, 'radial', 1);
                    break;
                    
                // Levels 11-25: Geometric patterns with increasing complexity
                case 11:
                    // Double spiral
                    createSpiral('neon', currentLevel, 1);
                    // Add center blocks
                    const center11 = Math.floor(blockCols / 2);
                    for (let row = 3; row < 5; row++) {
                        blocks.push(createBlock(center11 - 1, row, getBlockHitCount(currentLevel, 2), 'normal', '#FFFF00'));
                        blocks.push(createBlock(center11, row, getBlockHitCount(currentLevel, 2), 'normal', '#FFFF00'));
                    }
                    break;
                    
                case 12:
                    // Filled diamond with gradient
                    createDiamond('sunset', currentLevel, true, 1);
                    break;
                    
                case 13:
                    // Star pattern (pixel art)
                    const star = [
                        [0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,1,2,1,1,2,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,2,3,2,2,3,2,1,0,0,0,0,0,0],
                        [1,1,1,1,1,1,2,3,3,3,3,3,2,1,1,1,1,1,1,0],
                        [0,1,2,2,2,2,3,3,3,3,3,3,3,2,2,2,2,2,1,0],
                        [0,0,1,2,2,2,2,3,3,3,3,3,2,2,2,2,2,1,0,0],
                        [0,0,0,1,1,1,1,2,2,2,2,2,1,1,1,1,1,0,0,0],
                        [0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0]
                    ];
                    createPixelArt(star, 'neon', currentLevel, 1);
                    break;
                    
                case 14:
                    // Complex wave interference pattern
                    createWavePattern('ocean', currentLevel, 2, 0.4, 1);
                    createWavePattern('space', currentLevel, 1.5, 0.3, 1);
                    break;
                    
                case 15:
                    // Maze-like pattern with 2-hit blocks introduced
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if ((row % 3 === 0 && col % 2 === 0) || (row % 2 === 0 && col % 3 === 0)) {
                                const hits = getBlockHitCount(currentLevel, (row < 2 || row > blockRows - 3) ? 2 : 1);
                                const colorIdx = (row + col) % colorThemes.nature.length;
                                blocks.push(createBlock(col, row, hits, 'normal', colorThemes.nature[colorIdx]));
                            }
                        }
                    }
                    break;
                    
                case 16:
                    // Butterfly pattern (pixel art)
                    const butterfly = [
                        [1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0],
                        [2,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,2,0],
                        [2,3,3,2,1,0,0,0,0,0,0,0,0,0,1,2,3,3,2,0],
                        [1,2,3,3,2,1,0,0,1,1,1,0,0,1,2,3,3,2,1,0],
                        [0,1,2,3,3,2,1,1,2,2,2,1,1,2,3,3,2,1,0,0],
                        [0,0,1,2,3,3,2,2,2,2,2,2,2,3,3,2,1,0,0,0],
                        [0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0],
                        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0]
                    ];
                    createPixelArt(butterfly, 'rainbow', currentLevel, 1);
                    break;
                    
                case 17:
                    // Zigzag diamond
                    for (let row = 0; row < blockRows; row++) {
                        const zigzag = row % 2 === 0 ? 0 : 1;
                        const width = blockCols - Math.abs(row - blockRows/2) * 3;
                        const start = Math.floor((blockCols - width) / 2) + zigzag;
                        
                        for (let col = start; col < start + width; col += 2) {
                            if (col >= 0 && col < blockCols) {
                                const hits = getBlockHitCount(currentLevel, row < 3 ? 2 : 1);
                                const colorIdx = row % colorThemes.pastel.length;
                                blocks.push(createBlock(col, row, hits, 'normal', colorThemes.pastel[colorIdx]));
                            }
                        }
                    }
                    break;
                    
                case 18:
                    // Concentric squares
                    for (let layer = 0; layer < 4; layer++) {
                        const color = colorThemes.space[layer % colorThemes.space.length];
                        const hits = getBlockHitCount(currentLevel, 2 - Math.floor(layer / 2));
                        
                        // Top and bottom
                        for (let col = layer; col < blockCols - layer; col++) {
                            if (layer < blockRows) {
                                blocks.push(createBlock(col, layer, hits, 'normal', color));
                            }
                            if (blockRows - 1 - layer >= 0 && blockRows - 1 - layer !== layer) {
                                blocks.push(createBlock(col, blockRows - 1 - layer, hits, 'normal', color));
                            }
                        }
                        
                        // Left and right
                        for (let row = layer + 1; row < blockRows - layer - 1; row++) {
                            blocks.push(createBlock(layer, row, hits, 'normal', color));
                            if (blockCols - 1 - layer !== layer) {
                                blocks.push(createBlock(blockCols - 1 - layer, row, hits, 'normal', color));
                            }
                        }
                    }
                    break;
                    
                case 19:
                    // Smile face (pixel art)
                    const smile = [
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                        [0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0],
                        [1,2,2,1,1,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1],
                        [1,2,1,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,2,1],
                        [1,2,2,1,1,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1],
                        [1,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1],
                        [0,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0]
                    ];
                    createPixelArt(smile, 'sunset', currentLevel, 1);
                    break;
                    
                case 20:
                    // Cross pattern with gradient
                    const centerRow20 = Math.floor(blockRows / 2);
                    const centerCol20 = Math.floor(blockCols / 2);
                    
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const isCenter = Math.abs(row - centerRow20) <= 1 || Math.abs(col - centerCol20) <= 1;
                            const distance = Math.abs(row - centerRow20) + Math.abs(col - centerCol20);
                            
                            if (isCenter) {
                                const colorIdx = distance % colorThemes.neon.length;
                                const hits = getBlockHitCount(currentLevel, distance < 3 ? 2 : 1);
                                blocks.push(createBlock(col, row, hits, 'normal', colorThemes.neon[colorIdx]));
                            }
                        }
                    }
                    break;
                    
                case 21:
                    // Hexagon pattern
                    const hexagonRows = [
                        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0],
                        [0,0,1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0,0],
                        [0,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0],
                        [0,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0],
                        [0,0,1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0,0],
                        [0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0],
                        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0]
                    ];
                    createPixelArt(hexagonRows, 'ocean', currentLevel, 1);
                    break;
                    
                case 22:
                    // Alternating wave layers
                    for (let layer = 0; layer < 3; layer++) {
                        const amplitude = 2 - layer * 0.5;
                        const offset = layer * 2;
                        const theme = layer % 2 === 0 ? 'sunset' : 'ocean';
                        
                        for (let col = 0; col < blockCols; col++) {
                            const wave = Math.sin((col + offset) * 0.4) * amplitude;
                            const baseRow = 1 + layer * 2;
                            const row = Math.round(baseRow + wave);
                            
                            if (row >= 0 && row < blockRows) {
                                const colorIdx = col % colorThemes[theme].length;
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, layer + 1), 'normal', colorThemes[theme][colorIdx]));
                            }
                        }
                    }
                    break;
                    
                case 23:
                    // Complex diamond lattice
                    for (let diamondY = 0; diamondY < 2; diamondY++) {
                        for (let diamondX = 0; diamondX < 3; diamondX++) {
                            const offsetY = diamondY * 4;
                            const offsetX = diamondX * 7 - (diamondY % 2) * 3;
                            
                            // Mini diamond
                            for (let dy = 0; dy < 4; dy++) {
                                const width = dy < 2 ? dy + 1 : 4 - dy;
                                const startX = 2 - width + offsetX;
                                
                                for (let dx = 0; dx < width * 2 - 1; dx++) {
                                    const row = offsetY + dy;
                                    const col = startX + dx;
                                    
                                    if (row < blockRows && col >= 0 && col < blockCols) {
                                        const colorIdx = (diamondX + diamondY) % colorThemes.nature.length;
                                        const hits = getBlockHitCount(currentLevel, dy === 0 || dy === 3 ? 2 : 1);
                                        blocks.push(createBlock(col, row, hits, 'normal', colorThemes.nature[colorIdx]));
                                    }
                                }
                            }
                        }
                    }
                    break;
                    
                case 24:
                    // Arrow pattern pointing up
                    const arrow = [
                        [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,2,3,3,3,3,2,1,0,0,0,0,0,0],
                        [0,0,0,0,0,1,2,3,3,3,3,3,3,2,1,0,0,0,0,0],
                        [0,0,0,0,1,2,3,3,3,3,3,3,3,3,2,1,0,0,0,0],
                        [0,0,0,0,0,0,0,2,3,3,3,3,2,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,2,3,3,3,3,2,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0]
                    ];
                    createPixelArt(arrow, 'neon', currentLevel, 1);
                    break;
                    
                case 25:
                    // Complex spiral with metal blocks
                    createSpiral('space', currentLevel, 1);
                    
                    // Add metal blocks at corners
                    if (currentLevel >= 25) {
                        blocks.push(createBlock(0, 0, getBlockHitCount(currentLevel, 4), 'metal'));
                        blocks.push(createBlock(blockCols - 1, 0, getBlockHitCount(currentLevel, 4), 'metal'));
                        blocks.push(createBlock(0, blockRows - 1, getBlockHitCount(currentLevel, 4), 'metal'));
                        blocks.push(createBlock(blockCols - 1, blockRows - 1, getBlockHitCount(currentLevel, 4), 'metal'));
                    }
                    break;
                    
                // Levels 26-40: Pixel Art Patterns
                case 26:
                    // Mushroom pixel art
                    const mushroom = [
                        [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0],
                        [0,0,1,2,3,3,1,3,3,1,1,3,3,1,3,3,2,1,0,0],
                        [0,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0],
                        [1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
                        [0,0,0,1,1,1,2,2,2,2,2,2,2,2,1,1,1,0,0,0],
                        [0,0,0,0,0,1,2,2,2,2,2,2,2,2,1,0,0,0,0,0],
                        [0,0,0,0,0,1,2,2,2,2,2,2,2,2,1,0,0,0,0,0]
                    ];
                    createPixelArt(mushroom, 'nature', currentLevel, 1);
                    // Add minimal lava blocks starting at level 7
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(1, Math.floor((currentLevel - 7) / 10) + 1);
                        blocks.push(createBlock(10, 7, 1, 'lava'));
                    }
                    break;

                case 27:
                    // Castle pixel art
                    const castle = [
                        [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0],
                        [2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1],
                        [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                        [2,2,1,1,2,2,2,1,1,1,1,2,2,2,1,1,2,2,2,2],
                        [2,2,1,1,2,2,2,1,1,1,1,2,2,2,1,1,2,2,2,2],
                        [2,2,1,1,2,2,2,1,1,1,1,2,2,2,1,1,2,2,2,2],
                        [2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2],
                        [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]
                    ];
                    createPixelArt(castle, 'space', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(2, Math.floor((currentLevel - 7) / 8) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(5 + i * 10, 6, 1, 'lava'));
                        }
                    }
                    break;

                case 28:
                    // Space invader pixel art
                    const spaceinvader = [
                        [0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],
                        [0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,1,1,2,1,1,1,1,1,1,1,1,2,1,1,0,0,0,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0],
                        [0,1,0,1,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0],
                        [0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0]
                    ];
                    createPixelArt(spaceinvader, 'neon', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(2, Math.floor((currentLevel - 7) / 7) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(3 + i * 14, 7, 1, 'lava'));
                        }
                    }
                    break;

                case 29:
                    // Flower pixel art
                    const flower = [
                        [0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,1,1,2,2,3,3,3,3,3,2,2,1,1,0,0,0,0],
                        [0,0,1,2,2,3,3,2,2,2,2,2,3,3,2,2,1,0,0,0],
                        [0,1,2,3,3,2,2,3,3,3,3,3,2,2,3,3,2,1,0,0],
                        [0,1,2,3,3,2,2,3,3,3,3,3,2,2,3,3,2,1,0,0],
                        [0,0,1,2,2,3,3,2,2,2,2,2,3,3,2,2,1,0,0,0],
                        [0,0,0,1,1,2,2,3,3,3,3,3,2,2,1,1,0,0,0,0],
                        [0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
                    ];
                    createPixelArt(flower, 'sunset', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(2, Math.floor((currentLevel - 7) / 6) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(8 + i * 4, 4, 1, 'lava'));
                        }
                    }
                    break;

                case 30:
                    // Tree pixel art
                    const tree = [
                        [0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0],
                        [0,0,0,1,1,2,2,3,3,3,3,3,2,2,1,1,0,0,0,0],
                        [0,1,1,2,2,3,3,3,3,3,3,3,3,3,2,2,1,1,0,0],
                        [1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1,0],
                        [0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,0,0]
                    ];
                    createPixelArt(tree, 'nature', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(3, Math.floor((currentLevel - 7) / 5) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(4 + i * 6, 7, 1, 'lava'));
                        }
                    }
                    break;

                case 31:
                    // Fish pixel art
                    const fish = [
                        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,1,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0],
                        [0,1,1,2,2,2,3,3,2,2,2,3,3,2,2,2,1,1,0,0],
                        [1,2,2,3,1,3,3,3,3,3,3,3,3,3,3,2,2,1,1,0],
                        [1,2,2,3,3,3,3,3,3,3,3,3,3,3,2,2,1,1,0,0],
                        [0,1,1,2,2,2,3,3,2,2,2,3,3,2,2,2,1,1,0,0],
                        [0,0,0,1,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
                    ];
                    createPixelArt(fish, 'ocean', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(3, Math.floor((currentLevel - 7) / 4) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(2 + i * 8, 5, 1, 'lava'));
                        }
                    }
                    break;

                case 32:
                    // Car pixel art
                    const car = [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0],
                        [1,2,3,3,1,3,3,3,3,3,3,3,3,1,3,3,3,2,1,0],
                        [1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0],
                        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0],
                        [0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ];
                    createPixelArt(car, 'space', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(3, Math.floor((currentLevel - 7) / 3) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(6 + i * 4, 6, 1, 'lava'));
                        }
                    }
                    break;

                case 33:
                    // Cake pixel art
                    const cake = [
                        [0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,2,1,2,0,0,0,0,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,0,1,2,3,2,3,2,3,2,3,2,3,2,3,2,1,0,0,0],
                        [0,1,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,1,0,0],
                        [1,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,1,0],
                        [2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,1],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]
                    ];
                    createPixelArt(cake, 'sunset', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(4, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(3 + i * 5, 6, 1, 'lava'));
                        }
                    }
                    break;

                case 34:
                    // Robot pixel art
                    const robot = [
                        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0],
                        [0,1,2,3,1,3,2,2,2,2,2,2,3,1,3,2,2,1,0,0],
                        [1,2,3,3,3,3,2,2,2,2,2,2,3,3,3,3,2,2,1,0],
                        [1,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,1,0],
                        [1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,0],
                        [0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0]
                    ];
                    createPixelArt(robot, 'neon', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(4, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(2 + i * 5, 4, 1, 'lava'));
                        }
                    }
                    break;

                case 35:
                    // Rocket pixel art
                    const rocket = [
                        [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,1,2,3,2,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,2,3,3,3,2,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0],
                        [0,0,0,0,1,2,3,3,1,1,1,3,3,2,1,0,0,0,0,0],
                        [0,0,0,1,2,3,3,3,1,1,1,3,3,3,2,1,0,0,0,0],
                        [0,0,1,2,3,3,3,3,1,1,1,3,3,3,3,2,1,0,0,0],
                        [0,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0]
                    ];
                    createPixelArt(rocket, 'space', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(4, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(1 + i * 6, 7, 1, 'lava'));
                        }
                    }
                    break;

                case 36:
                    // Crown pixel art
                    const crown = [
                        [0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0],
                        [1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,0,0],
                        [2,3,2,2,3,2,2,3,2,2,3,2,2,3,2,2,3,2,1,0],
                        [2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1],
                        [2,3,3,1,3,3,1,3,3,1,3,3,1,3,3,1,3,3,2,1],
                        [2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
                        [1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0],
                        [0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0]
                    ];
                    createPixelArt(crown, 'sunset', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(5, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(2 + i * 4, 7, 1, 'lava'));
                        }
                    }
                    break;

                case 37:
                    // House pixel art
                    const house = [
                        [0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0],
                        [0,0,0,1,1,2,2,3,3,3,3,3,2,2,1,1,0,0,0,0],
                        [0,1,1,2,2,3,3,3,3,3,3,3,3,3,2,2,1,1,0,0],
                        [1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1,0],
                        [1,2,1,1,3,3,1,1,3,3,3,3,1,1,3,3,1,2,1,0],
                        [1,2,1,1,3,3,1,1,3,3,3,3,1,1,3,3,1,2,1,0],
                        [1,2,2,2,3,3,2,2,2,1,1,2,2,2,3,3,2,2,1,0]
                    ];
                    createPixelArt(house, 'nature', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(5, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(3 + i * 3, 6, 1, 'lava'));
                        }
                    }
                    break;

                case 38:
                    // Diamond pixel art
                    const diamond = [
                        [0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0],
                        [0,0,0,1,1,2,2,3,3,3,3,3,2,2,1,1,0,0,0,0],
                        [0,1,1,2,2,3,3,3,3,3,3,3,3,3,2,2,1,1,0,0],
                        [1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1,0],
                        [0,1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1,0,0,0],
                        [0,0,1,2,3,3,3,3,3,3,3,3,3,3,2,1,0,0,0,0],
                        [0,0,0,1,2,2,3,3,3,3,3,3,2,2,1,0,0,0,0,0]
                    ];
                    createPixelArt(diamond, 'neon', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(6, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(1 + i * 3, 5, 1, 'lava'));
                        }
                    }
                    break;

                case 39:
                    // Lightning pixel art
                    const lightning = [
                        [0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,2,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0],
                        [1,2,3,3,3,3,3,3,2,1,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,1,2,3,3,3,2,2,2,2,1,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,1,2,3,3,3,3,2,1,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0]
                    ];
                    createPixelArt(lightning, 'space', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(6, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(2 + i * 3, 4, 1, 'lava'));
                        }
                    }
                    break;

                case 40:
                    // Peace sign pixel art
                    const peace = [
                        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0],
                        [1,2,2,3,3,3,3,3,1,1,3,3,3,3,3,3,2,2,1,0],
                        [1,2,3,3,3,3,3,1,2,2,1,3,3,3,3,3,3,2,1,0],
                        [1,2,3,3,3,3,1,2,3,3,2,1,3,3,3,3,3,2,1,0],
                        [1,2,3,3,3,1,2,3,3,3,3,2,1,3,3,3,3,2,1,0],
                        [0,1,2,3,1,2,3,3,3,3,3,3,2,1,3,3,2,1,0,0],
                        [0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0]
                    ];
                    createPixelArt(peace, 'rainbow', currentLevel, 1);
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(7, Math.floor((currentLevel - 7) / 2) + 1);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(1 + i * 3, 3, 1, 'lava'));
                        }
                    }
                    break;

                // Levels 41-55: Abstract Art + Metal Blocks
                case 41:
                    // Concentric spirals with metal blocks
                    createSpiral('ocean', currentLevel, 2);
                    createSpiral('sunset', currentLevel, 1);
                    // Introduce metal blocks at 10% density
                    const metalCount41 = Math.floor(blockRows * blockCols * 0.1);
                    for (let i = 0; i < metalCount41; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    // Enhanced lava placement for chain reactions
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(8, Math.floor((currentLevel - 7) / 2) + 2);
                        for (let i = 0; i < lavaCount; i++) {
                            const row = 2 + (i % 4);
                            const col = 3 + i * 2;
                            if (col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;

                case 42:
                    // Wave interference with metal grid
                    createWavePattern('neon', currentLevel, 2.5, 0.4, 2);
                    createWavePattern('space', currentLevel, 1.8, 0.6, 1);
                    // Metal grid pattern at 12% density
                    for (let row = 0; row < blockRows; row += 3) {
                        for (let col = 0; col < blockCols; col += 4) {
                            if (Math.random() < 0.12) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(9, Math.floor((currentLevel - 7) / 2) + 2);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(2 + i * 2, 1 + i % 3, 1, 'lava'));
                        }
                    }
                    break;

                case 43:
                    // Radial diamond lattice with metal reinforcements
                    createDiamond('rainbow', currentLevel, true, 2);
                    createDiamond('pastel', currentLevel, false, 1);
                    // Strategic metal placement at diamond intersections
                    const centerRow43 = Math.floor(blockRows / 2);
                    const centerCol43 = Math.floor(blockCols / 2);
                    for (let radius = 1; radius <= 3; radius++) {
                        for (let angle = 0; angle < 8; angle++) {
                            const row = centerRow43 + Math.round(radius * Math.sin(angle * Math.PI / 4));
                            const col = centerCol43 + Math.round(radius * Math.cos(angle * Math.PI / 4));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols && Math.random() < 0.15) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(10, Math.floor((currentLevel - 7) / 2) + 3);
                        for (let i = 0; i < lavaCount; i++) {
                            const angle = (i / lavaCount) * 2 * Math.PI;
                            const row = centerRow43 + Math.round(2 * Math.sin(angle));
                            const col = centerCol43 + Math.round(2 * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;

                case 44:
                    // Gradient maze with metal barriers
                    createGradientPattern('nature', currentLevel, 'diagonal', 2);
                    createCheckerboard('space', currentLevel, 3, 1);
                    // Metal barrier walls at 15% density
                    for (let row = 1; row < blockRows; row += 2) {
                        for (let col = 0; col < blockCols; col += 3) {
                            if (Math.random() < 0.15) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                                if (col + 1 < blockCols) {
                                    blocks.push(createBlock(col + 1, row, getBlockHitCount(currentLevel, 4), 'metal'));
                                }
                            }
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(11, Math.floor((currentLevel - 7) / 2) + 3);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(1 + i * 2, 6 - (i % 4), 1, 'lava'));
                        }
                    }
                    break;

                case 45:
                    // Fibonacci spiral with metal nodes
                    let fibX = 0, fibY = 0, fibDir = 0;
                    const fibColors = colorThemes.sunset;
                    for (let i = 0; i < 40; i++) {
                        const fib = i < 2 ? 1 : Math.floor(1.618 ** i / Math.sqrt(5) + 0.5);
                        for (let j = 0; j < Math.min(fib, 3); j++) {
                            const row = Math.floor(fibY + j) % blockRows;
                            const col = Math.floor(fibX + j) % blockCols;
                            if (row >= 0 && col >= 0) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 2), 'normal', fibColors[i % fibColors.length]));
                            }
                        }
                        // Move in spiral
                        fibX += Math.cos(fibDir) * fib * 0.5;
                        fibY += Math.sin(fibDir) * fib * 0.5;
                        fibDir += Math.PI / 2;
                    }
                    // Metal nodes at key fibonacci points - 17% density
                    for (let i = 0; i < 8; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(12, Math.floor((currentLevel - 7) / 2) + 3);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(3 + i, 2 + (i % 3), 1, 'lava'));
                        }
                    }
                    break;

                case 46:
                    // Crystalline structure with metal supports
                    for (let crystal = 0; crystal < 3; crystal++) {
                        const centerX = 3 + crystal * 6;
                        const centerY = 2 + crystal;
                        const crystalColors = colorThemes.neon;
                        
                        for (let layer = 0; layer < 3; layer++) {
                            for (let side = 0; side < 6; side++) {
                                const angle = (side * Math.PI) / 3;
                                const radius = layer + 1;
                                const row = centerY + Math.round(radius * Math.sin(angle));
                                const col = centerX + Math.round(radius * Math.cos(angle));
                                
                                if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, layer + 1), 'normal', crystalColors[side % crystalColors.length]));
                                }
                            }
                        }
                    }
                    // Metal support structure at 18% density
                    for (let i = 0; i < 9; i++) {
                        const row = i % 3;
                        const col = 1 + i * 2;
                        if (col < blockCols) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(13, Math.floor((currentLevel - 7) / 2) + 4);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(4 + i, 5 - (i % 4), 1, 'lava'));
                        }
                    }
                    break;

                case 47:
                    // Mandala pattern with metal framework
                    const mandalaCenterX = Math.floor(blockCols / 2);
                    const mandalaCenterY = Math.floor(blockRows / 2);
                    const mandalaColors = colorThemes.rainbow;
                    
                    for (let ring = 1; ring <= 4; ring++) {
                        const points = ring * 8;
                        for (let point = 0; point < points; point++) {
                            const angle = (point * 2 * Math.PI) / points;
                            const radius = ring * 1.5;
                            const row = mandalaCenterY + Math.round(radius * Math.sin(angle));
                            const col = mandalaCenterX + Math.round(radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, ring > 2 ? 3 : 2), 'normal', mandalaColors[point % mandalaColors.length]));
                            }
                        }
                    }
                    // Metal framework at cardinal points - 20% density
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI) / 2;
                        for (let radius = 2; radius <= 4; radius++) {
                            const row = mandalaCenterY + Math.round(radius * Math.sin(angle));
                            const col = mandalaCenterX + Math.round(radius * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(14, Math.floor((currentLevel - 7) / 2) + 4);
                        for (let i = 0; i < lavaCount; i++) {
                            const angle = (i / lavaCount) * 2 * Math.PI;
                            const row = mandalaCenterY + Math.round(3 * Math.sin(angle));
                            const col = mandalaCenterX + Math.round(3 * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;

                case 48:
                    // Fractal tree with metal branches
                    function drawFractalBranch(startX, startY, length, angle, depth, colors) {
                        if (depth <= 0 || length < 1) return;
                        
                        const endX = startX + length * Math.cos(angle);
                        const endY = startY + length * Math.sin(angle);
                        
                        // Draw branch segments
                        const segments = Math.max(1, Math.floor(length));
                        for (let i = 0; i <= segments; i++) {
                            const x = startX + (endX - startX) * (i / segments);
                            const y = startY + (endY - startY) * (i / segments);
                            const row = Math.floor(y);
                            const col = Math.floor(x);
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                const colorIdx = depth % colors.length;
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, Math.max(1, depth)), 'normal', colors[colorIdx]));
                            }
                        }
                        
                        // Recursive branches
                        drawFractalBranch(endX, endY, length * 0.7, angle - Math.PI / 6, depth - 1, colors);
                        drawFractalBranch(endX, endY, length * 0.7, angle + Math.PI / 6, depth - 1, colors);
                    }
                    
                    drawFractalBranch(blockCols / 2, blockRows - 1, 4, -Math.PI / 2, 4, colorThemes.nature);
                    
                    // Metal reinforcement branches at 22% density
                    for (let i = 0; i < 11; i++) {
                        const row = blockRows - 2 - (i % 5);
                        const col = (blockCols / 2) + (i % 2 === 0 ? -i : i);
                        if (col >= 0 && col < blockCols && row >= 0) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(15, Math.floor((currentLevel - 7) / 2) + 5);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(2 + i, 7 - (i % 5), 1, 'lava'));
                        }
                    }
                    break;

                case 49:
                    // Tessellation pattern with metal joints
                    for (let tessY = 0; tessY < 2; tessY++) {
                        for (let tessX = 0; tessX < 3; tessX++) {
                            const offsetX = tessX * 6 + (tessY % 2) * 3;
                            const offsetY = tessY * 4;
                            const tessColors = colorThemes.ocean;
                            
                            // Hexagonal tessellation
                            for (let hex = 0; hex < 6; hex++) {
                                const angle = (hex * Math.PI) / 3;
                                const radius = 2;
                                const row = offsetY + 2 + Math.round(radius * Math.sin(angle));
                                const col = offsetX + 3 + Math.round(radius * Math.cos(angle));
                                
                                if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 2), 'normal', tessColors[hex % tessColors.length]));
                                }
                            }
                            // Center block
                            if (offsetY + 2 < blockRows && offsetX + 3 < blockCols) {
                                blocks.push(createBlock(offsetX + 3, offsetY + 2, getBlockHitCount(currentLevel, 3), 'normal', tessColors[0]));
                            }
                        }
                    }
                    // Metal joints at tessellation intersections - 23% density
                    for (let i = 0; i < 12; i++) {
                        const row = 1 + (i % 6);
                        const col = 1 + i * 1.5;
                        if (col < blockCols && Math.floor(col) >= 0) {
                            blocks.push(createBlock(Math.floor(col), row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(16, Math.floor((currentLevel - 7) / 2) + 5);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(3 + i, 1 + (i % 6), 1, 'lava'));
                        }
                    }
                    break;

                case 50:
                    // Vortex pattern with metal stabilizers
                    const vortexCenterX = blockCols / 2;
                    const vortexCenterY = blockRows / 2;
                    const vortexColors = colorThemes.space;
                    
                    for (let i = 0; i < 80; i++) {
                        const angle = i * 0.3;
                        const radius = Math.sqrt(i) * 0.8;
                        const row = Math.floor(vortexCenterY + radius * Math.sin(angle));
                        const col = Math.floor(vortexCenterX + radius * Math.cos(angle));
                        
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            const intensity = Math.floor(radius / 2) + 1;
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, Math.min(intensity, 3)), 'normal', vortexColors[i % vortexColors.length]));
                        }
                    }
                    // Metal stabilizers at key vortex points - 24% density
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI) / 4;
                        const radius = 3;
                        const row = Math.floor(vortexCenterY + radius * Math.sin(angle));
                        const col = Math.floor(vortexCenterX + radius * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(17, Math.floor((currentLevel - 7) / 2) + 6);
                        for (let i = 0; i < lavaCount; i++) {
                            const angle = (i / lavaCount) * 2 * Math.PI;
                            const row = Math.floor(vortexCenterY + 2.5 * Math.sin(angle));
                            const col = Math.floor(vortexCenterX + 2.5 * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;

                case 51:
                    // DNA double helix with metal base pairs
                    const helixColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
                    for (let i = 0; i < blockCols; i++) {
                        const angle = i * 0.8;
                        const amplitude = 2.5;
                        
                        // First helix strand
                        const row1 = Math.floor(blockRows / 2 + amplitude * Math.sin(angle));
                        if (row1 >= 0 && row1 < blockRows) {
                            blocks.push(createBlock(i, row1, getBlockHitCount(currentLevel, 2), 'normal', helixColors[0]));
                        }
                        
                        // Second helix strand
                        const row2 = Math.floor(blockRows / 2 + amplitude * Math.sin(angle + Math.PI));
                        if (row2 >= 0 && row2 < blockRows) {
                            blocks.push(createBlock(i, row2, getBlockHitCount(currentLevel, 2), 'normal', helixColors[1]));
                        }
                        
                        // Cross-links (base pairs) every 3 columns
                        if (i % 3 === 0) {
                            const centerRow = Math.floor(blockRows / 2);
                            for (let link = Math.min(row1, row2, centerRow); link <= Math.max(row1, row2, centerRow); link++) {
                                if (link >= 0 && link < blockRows) {
                                    blocks.push(createBlock(i, link, getBlockHitCount(currentLevel, 1), 'normal', helixColors[(i % 4)]));
                                }
                            }
                        }
                    }
                    // Metal base pairs at critical junctions - 25% density
                    for (let i = 0; i < blockCols; i += 6) {
                        for (let j = 0; j < 3; j++) {
                            const row = Math.floor(blockRows / 2) + j - 1;
                            if (row >= 0 && row < blockRows) {
                                blocks.push(createBlock(i, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(18, Math.floor((currentLevel - 7) / 2) + 6);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(i * 1, Math.floor(blockRows / 2), 1, 'lava'));
                        }
                    }
                    break;

                case 52:
                    // Kaleidoscope pattern with metal mirrors
                    const kaleidoColors = colorThemes.rainbow;
                    const kaleidoCenterX = blockCols / 2;
                    const kaleidoCenterY = blockRows / 2;
                    
                    // Create 6-fold symmetry
                    for (let sector = 0; sector < 6; sector++) {
                        const baseAngle = (sector * Math.PI) / 3;
                        for (let i = 0; i < 15; i++) {
                            const radius = 1 + i * 0.3;
                            const angle = baseAngle + (i * 0.2);
                            const row = Math.floor(kaleidoCenterY + radius * Math.sin(angle));
                            const col = Math.floor(kaleidoCenterX + radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 2), 'normal', kaleidoColors[i % kaleidoColors.length]));
                            }
                            
                            // Mirror reflection
                            const mirrorAngle = baseAngle - (i * 0.2);
                            const mirrorRow = Math.floor(kaleidoCenterY + radius * Math.sin(mirrorAngle));
                            const mirrorCol = Math.floor(kaleidoCenterX + radius * Math.cos(mirrorAngle));
                            
                            if (mirrorRow >= 0 && mirrorRow < blockRows && mirrorCol >= 0 && mirrorCol < blockCols) {
                                blocks.push(createBlock(mirrorCol, mirrorRow, getBlockHitCount(currentLevel, 2), 'normal', kaleidoColors[i % kaleidoColors.length]));
                            }
                        }
                    }
                    // Metal mirror boundaries - 25% density
                    for (let sector = 0; sector < 6; sector++) {
                        const angle = (sector * Math.PI) / 3;
                        for (let radius = 1; radius <= 4; radius++) {
                            const row = Math.floor(kaleidoCenterY + radius * Math.sin(angle));
                            const col = Math.floor(kaleidoCenterX + radius * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(19, Math.floor((currentLevel - 7) / 2) + 7);
                        for (let i = 0; i < lavaCount; i++) {
                            const angle = (i / lavaCount) * 2 * Math.PI;
                            const row = Math.floor(kaleidoCenterY + 2 * Math.sin(angle));
                            const col = Math.floor(kaleidoCenterX + 2 * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;

                case 53:
                    // Circuit board pattern with metal connectors
                    const circuitColors = colorThemes.neon;
                    
                    // Main circuit traces
                    for (let trace = 0; trace < 4; trace++) {
                        const traceY = 1 + trace * 2;
                        for (let col = 0; col < blockCols; col++) {
                            if (col % 3 !== 1) { // Leave gaps for components
                                blocks.push(createBlock(col, traceY, getBlockHitCount(currentLevel, 1), 'normal', circuitColors[trace % circuitColors.length]));
                            }
                        }
                    }
                    
                    // Vertical connections
                    for (let conn = 0; conn < blockCols; conn += 4) {
                        for (let row = 0; row < blockRows; row++) {
                            if (row % 2 === 0) {
                                blocks.push(createBlock(conn, row, getBlockHitCount(currentLevel, 2), 'normal', circuitColors[(conn / 4) % circuitColors.length]));
                            }
                        }
                    }
                    
                    // Circuit components (metal) - 25% density
                    for (let comp = 0; comp < 15; comp++) {
                        const row = 1 + (comp % 4) * 2;
                        const col = 1 + comp;
                        if (col < blockCols) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(20, Math.floor((currentLevel - 7) / 2) + 7);
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(2 + i, 0, 1, 'lava'));
                        }
                    }
                    break;

                case 54:
                    // Galaxy spiral with metal star cores
                    const galaxyCenterX = blockCols / 2;
                    const galaxyCenterY = blockRows / 2;
                    const galaxyColors = colorThemes.space;
                    
                    // Main spiral arms
                    for (let arm = 0; arm < 3; arm++) {
                        const armOffset = (arm * 2 * Math.PI) / 3;
                        for (let i = 0; i < 50; i++) {
                            const angle = armOffset + i * 0.3;
                            const radius = Math.sqrt(i) * 0.6;
                            const row = Math.floor(galaxyCenterY + radius * Math.sin(angle));
                            const col = Math.floor(galaxyCenterX + radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                const intensity = Math.max(1, 4 - Math.floor(radius / 2));
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, intensity), 'normal', galaxyColors[i % galaxyColors.length]));
                            }
                        }
                    }
                    
                    // Metal star cores at spiral nodes - 25% density
                    for (let star = 0; star < 12; star++) {
                        const angle = (star * 2 * Math.PI) / 12;
                        const radius = 1 + star * 0.4;
                        const row = Math.floor(galaxyCenterY + radius * Math.sin(angle));
                        const col = Math.floor(galaxyCenterX + radius * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(21, Math.floor((currentLevel - 7) / 2) + 8);
                        for (let i = 0; i < lavaCount; i++) {
                            const angle = (i / lavaCount) * 2 * Math.PI;
                            const row = Math.floor(galaxyCenterY + 3 * Math.sin(angle));
                            const col = Math.floor(galaxyCenterX + 3 * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;

                case 55:
                    // Ultimate challenge: Multi-layered fortress with maximum metal density
                    // Outer fortress walls
                    createGradientPattern('space', currentLevel, 'radial', 3);
                    createSpiral('neon', currentLevel, 2);
                    createDiamond('rainbow', currentLevel, true, 2);
                    
                    // Maximum metal fortress - 25% density
                    const fortressMetalCount = Math.floor(blockRows * blockCols * 0.25);
                    for (let i = 0; i < fortressMetalCount; i++) {
                        let row, col;
                        let attempts = 0;
                        do {
                            row = Math.floor(Math.random() * blockRows);
                            col = Math.floor(Math.random() * blockCols);
                            attempts++;
                        } while (attempts < 10 && blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding)));
                        
                        if (attempts < 10) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Maximum lava threat for epic chain reactions
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(25, Math.floor((currentLevel - 7) / 2) + 10);
                        for (let i = 0; i < lavaCount; i++) {
                            const row = 1 + (i % 6);
                            const col = 1 + Math.floor(i / 6) * 3;
                            if (col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;

                // Space/Cosmic themed levels 56-70
                case 56:
                    // Nebula clouds with scattered metal stars
                    const nebulaColors = ['#1F1147', '#4B0082', '#8B008B', '#9400D3', '#9932CC'];
                    const nebulaCenterX = blockCols / 2;
                    const nebulaCenterY = blockRows / 2;
                    
                    // Create nebula cloud formations
                    for (let cloud = 0; cloud < 3; cloud++) {
                        const cloudX = nebulaCenterX + (cloud - 1) * 4;
                        const cloudY = nebulaCenterY + Math.sin(cloud) * 2;
                        
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * 3 + 1;
                            const row = Math.floor(cloudY + radius * Math.sin(angle));
                            const col = Math.floor(cloudX + radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                // 60% single-hit, 40% multi-hit for level 56
                                const hits = Math.random() < 0.6 ? 1 : 2 + Math.floor(Math.random() * 2);
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', nebulaColors[i % nebulaColors.length]));
                            }
                        }
                    }
                    
                    // Metal stars - 25% density
                    const starCount56 = Math.floor(blockRows * blockCols * 0.25);
                    for (let i = 0; i < starCount56; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Reduced lava blocks - cosmic debris
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(8, 4 + Math.floor((currentLevel - 56) / 4));
                        for (let i = 0; i < lavaCount; i++) {
                            const row = 1 + Math.floor(i / 2);
                            const col = 2 + (i % 4) * 3;
                            if (col < blockCols && row < blockRows) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;
                    
                case 57:
                    // Asteroid field with metal cores
                    const asteroidColors = ['#696969', '#808080', '#A9A9A9', '#C0C0C0', '#D3D3D3'];
                    
                    // Create asteroid clusters
                    for (let cluster = 0; cluster < 5; cluster++) {
                        const clusterX = 2 + cluster * 2;
                        const clusterY = 1 + (cluster % 3) * 2;
                        
                        // Asteroid shape
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (Math.abs(dx) + Math.abs(dy) <= 1) { // Diamond shape
                                    const row = clusterY + dy;
                                    const col = clusterX + dx;
                                    if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                        // 58% single-hit, 42% multi-hit
                                        const hits = Math.random() < 0.58 ? 1 : 2 + Math.floor(Math.random() * 2);
                                        blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', asteroidColors[cluster % asteroidColors.length]));
                                    }
                                }
                            }
                        }
                        
                        // Metal core in center of some asteroids
                        if (cluster % 2 === 0) {
                            blocks.push(createBlock(clusterX, clusterY, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Additional metal asteroids
                    const metalAsteroidCount = Math.floor(blockRows * blockCols * 0.15);
                    for (let i = 0; i < metalAsteroidCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava blocks
                    if (currentLevel >= 7) {
                        const lavaCount = Math.min(6, 3 + Math.floor((currentLevel - 57) / 5));
                        for (let i = 0; i < lavaCount; i++) {
                            blocks.push(createBlock(1 + i * 2, 0, 1, 'lava'));
                        }
                    }
                    break;
                    
                case 58:
                    // Pulsar waves emanating from center
                    const pulsarColors = ['#FF1493', '#FF69B4', '#FFB6C1', '#FFC0CB', '#FFE4E1'];
                    const pulsarCenterX = blockCols / 2;
                    const pulsarCenterY = blockRows / 2;
                    
                    // Create pulsing waves
                    for (let wave = 0; wave < 4; wave++) {
                        const waveRadius = wave + 1;
                        const waveBlocks = wave * 8 + 8;
                        
                        for (let i = 0; i < waveBlocks; i++) {
                            const angle = (i / waveBlocks) * Math.PI * 2;
                            const row = Math.floor(pulsarCenterY + waveRadius * Math.sin(angle));
                            const col = Math.floor(pulsarCenterX + waveRadius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                // 56% single-hit, 44% multi-hit
                                const hits = Math.random() < 0.56 ? 1 : 2 + Math.floor(Math.random() * 3);
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', pulsarColors[wave % pulsarColors.length]));
                            }
                        }
                    }
                    
                    // Metal pulsar core
                    blocks.push(createBlock(Math.floor(pulsarCenterX), Math.floor(pulsarCenterY), getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // Metal wave stabilizers - 26% total metal density
                    const stabilizerCount = Math.floor(blockRows * blockCols * 0.20);
                    for (let i = 0; i < stabilizerCount; i++) {
                        const angle = (i / stabilizerCount) * Math.PI * 2;
                        const radius = 2 + (i % 3);
                        const row = Math.floor(pulsarCenterY + radius * Math.sin(angle));
                        const col = Math.floor(pulsarCenterX + radius * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols &&
                            !blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava
                    if (currentLevel >= 7) {
                        for (let i = 0; i < 5; i++) {
                            blocks.push(createBlock(i * 3, blockRows - 1, 1, 'lava'));
                        }
                    }
                    break;
                    
                case 59:
                    // Comet tail pattern
                    const cometColors = ['#87CEEB', '#87CEFA', '#00BFFF', '#1E90FF', '#4169E1'];
                    
                    // Comet heads
                    for (let comet = 0; comet < 3; comet++) {
                        const startCol = comet * 4 + 1;
                        const startRow = comet + 1;
                        
                        // Comet head - metal
                        blocks.push(createBlock(startCol, startRow, getBlockHitCount(currentLevel, 4), 'metal'));
                        
                        // Comet tail
                        for (let i = 1; i < 6; i++) {
                            const tailCol = startCol + i;
                            const tailRow = startRow + Math.floor(i / 2);
                            if (tailCol < blockCols && tailRow < blockRows) {
                                // 54% single-hit, 46% multi-hit
                                const hits = Math.random() < 0.54 ? 1 : 2 + Math.floor(Math.random() * 2);
                                const colorIntensity = 5 - i;
                                blocks.push(createBlock(tailCol, tailRow, getBlockHitCount(currentLevel, hits), 'normal', cometColors[colorIntensity - 1]));
                            }
                        }
                    }
                    
                    // Additional cosmic debris - mixed hits
                    const debrisCount = 15;
                    for (let i = 0; i < debrisCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            // 52% single-hit, 48% multi-hit
                            const hits = Math.random() < 0.52 ? 1 : 2 + Math.floor(Math.random() * 3);
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', cometColors[i % cometColors.length]));
                        }
                    }
                    
                    // Metal space stations - 26% total metal
                    const stationCount = Math.floor(blockRows * blockCols * 0.15);
                    for (let i = 0; i < stationCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava
                    if (currentLevel >= 7) {
                        for (let i = 0; i < 4; i++) {
                            blocks.push(createBlock(blockCols - 1 - i * 2, 0, 1, 'lava'));
                        }
                    }
                    break;
                    
                case 60:
                    // Special level - Cosmic vortex (map clearing)
                    const vortexColors60 = ['#4B0082', '#8A2BE2', '#9400D3', '#9932CC', '#BA55D3'];
                    const vortexCenter60X = blockCols / 2;
                    const vortexCenter60Y = blockRows / 2;
                    
                    // Create a clearing vortex pattern - easier to clear
                    for (let ring = 0; ring < 3; ring++) {
                        const radius = ring + 2;
                        const segments = 6 + ring * 2;
                        
                        for (let i = 0; i < segments; i++) {
                            const angle = (i / segments) * Math.PI * 2;
                            const row = Math.floor(vortexCenter60Y + radius * Math.sin(angle));
                            const col = Math.floor(vortexCenter60X + radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                // 50% single-hit for easier clearing
                                const hits = Math.random() < 0.5 ? 1 : 2;
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', vortexColors60[ring % vortexColors60.length]));
                            }
                        }
                    }
                    
                    // Central metal vortex core
                    blocks.push(createBlock(Math.floor(vortexCenter60X), Math.floor(vortexCenter60Y), getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // Minimal additional blocks for clearing bonus
                    const clearingBlocks = 10;
                    for (let i = 0; i < clearingBlocks; i++) {
                        const angle = (i / clearingBlocks) * Math.PI * 2;
                        const row = Math.floor(vortexCenter60Y + 4 * Math.sin(angle));
                        const col = Math.floor(vortexCenter60X + 4 * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            blocks.push(createBlock(col, row, 1, 'normal', vortexColors60[i % vortexColors60.length]));
                        }
                    }
                    
                    // No lava on special clearing levels
                    break;
                    
                case 61:
                    // Binary star system
                    const starColors = ['#FFD700', '#FFA500', '#FF8C00', '#FF6347', '#FF4500'];
                    
                    // Two star centers
                    const star1X = Math.floor(blockCols * 0.3);
                    const star1Y = Math.floor(blockRows * 0.4);
                    const star2X = Math.floor(blockCols * 0.7);
                    const star2Y = Math.floor(blockRows * 0.6);
                    
                    // Create stars with radiation
                    for (let star = 0; star < 2; star++) {
                        const starX = star === 0 ? star1X : star2X;
                        const starY = star === 0 ? star1Y : star2Y;
                        
                        // Star core - metal
                        blocks.push(createBlock(starX, starY, getBlockHitCount(currentLevel, 4), 'metal'));
                        
                        // Star radiation
                        for (let r = 1; r <= 2; r++) {
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                                const row = Math.floor(starY + r * Math.sin(angle));
                                const col = Math.floor(starX + r * Math.cos(angle));
                                if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                    // 48% single-hit, 52% multi-hit
                                    const hits = Math.random() < 0.48 ? 1 : 2 + Math.floor(Math.random() * 2);
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', starColors[(r + star) % starColors.length]));
                                }
                            }
                        }
                    }
                    
                    // Orbital debris between stars
                    for (let i = 0; i < 12; i++) {
                        const t = i / 12;
                        const col = Math.floor(star1X + (star2X - star1X) * t);
                        const row = Math.floor(star1Y + (star2Y - star1Y) * t + Math.sin(i) * 2);
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            // 46% single-hit, 54% multi-hit
                            const hits = Math.random() < 0.46 ? 1 : 2 + Math.floor(Math.random() * 3);
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', starColors[i % starColors.length]));
                        }
                    }
                    
                    // Additional metal debris - 27% total metal
                    const metalDebrisCount = Math.floor(blockRows * blockCols * 0.20);
                    for (let i = 0; i < metalDebrisCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava
                    if (currentLevel >= 7) {
                        for (let i = 0; i < 3; i++) {
                            blocks.push(createBlock(3 + i * 4, blockRows - 2, 1, 'lava'));
                        }
                    }
                    break;
                    
                case 62:
                    // Saturn rings pattern
                    const ringColors = ['#F4A460', '#DEB887', '#D2691E', '#BC8F8F', '#F5DEB3'];
                    const saturnX = blockCols / 2;
                    const saturnY = blockRows / 2;
                    
                    // Planet core - large metal structure
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (Math.abs(dx) + Math.abs(dy) <= 1) {
                                const row = Math.floor(saturnY + dy);
                                const col = Math.floor(saturnX + dx);
                                if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                                }
                            }
                        }
                    }
                    
                    // Ring system
                    for (let ring = 0; ring < 3; ring++) {
                        const innerRadius = 3 + ring;
                        const outerRadius = innerRadius + 0.8;
                        const ringDensity = 16 + ring * 4;
                        
                        for (let i = 0; i < ringDensity; i++) {
                            const angle = (i / ringDensity) * Math.PI * 2;
                            const radius = innerRadius + (Math.random() * (outerRadius - innerRadius));
                            const row = Math.floor(saturnY + radius * Math.sin(angle) * 0.4); // Flatten for ring effect
                            const col = Math.floor(saturnX + radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                // 44% single-hit, 56% multi-hit
                                const hits = Math.random() < 0.44 ? 1 : 2 + Math.floor(Math.random() * 2);
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', ringColors[ring % ringColors.length]));
                            }
                        }
                    }
                    
                    // Metal moons - 28% total metal
                    const moonCount = 4;
                    for (let i = 0; i < moonCount; i++) {
                        const angle = (i / moonCount) * Math.PI * 2;
                        const row = Math.floor(saturnY + 5 * Math.sin(angle));
                        const col = Math.floor(saturnX + 5 * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava
                    if (currentLevel >= 7) {
                        for (let i = 0; i < 3; i++) {
                            blocks.push(createBlock(1 + i * 5, 0, 1, 'lava'));
                        }
                    }
                    break;
                    
                case 63:
                    // Constellation map
                    const starfieldColors = ['#FFFFFF', '#FFFACD', '#F0E68C', '#FFD700', '#FFA500'];
                    
                    // Create constellation points
                    const constellations = [
                        // Big Dipper shape
                        [[2, 2], [3, 1], [4, 1], [5, 2], [5, 3], [4, 4], [3, 3]],
                        // Orion's belt
                        [[8, 3], [9, 3], [10, 3]],
                        // Small triangle
                        [[2, 6], [3, 7], [4, 6]]
                    ];
                    
                    for (let c = 0; c < constellations.length; c++) {
                        const constellation = constellations[c];
                        for (let i = 0; i < constellation.length; i++) {
                            const [col, row] = constellation[i];
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                // Constellation stars are metal
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                            
                            // Connect stars with regular blocks
                            if (i > 0) {
                                const [prevCol, prevRow] = constellation[i - 1];
                                const steps = 3;
                                for (let s = 1; s < steps; s++) {
                                    const t = s / steps;
                                    const linkCol = Math.floor(prevCol + (col - prevCol) * t);
                                    const linkRow = Math.floor(prevRow + (row - prevRow) * t);
                                    if (linkRow >= 0 && linkRow < blockRows && linkCol >= 0 && linkCol < blockCols) {
                                        // 42% single-hit, 58% multi-hit
                                        const hits = Math.random() < 0.42 ? 1 : 2 + Math.floor(Math.random() * 2);
                                        blocks.push(createBlock(linkCol, linkRow, getBlockHitCount(currentLevel, hits), 'normal', starfieldColors[c % starfieldColors.length]));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Background stars
                    const bgStarCount = 20;
                    for (let i = 0; i < bgStarCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            // 40% single-hit, 60% multi-hit
                            const hits = Math.random() < 0.40 ? 1 : 2 + Math.floor(Math.random() * 3);
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', starfieldColors[i % starfieldColors.length]));
                        }
                    }
                    
                    // Minimal lava
                    if (currentLevel >= 7) {
                        for (let i = 0; i < 2; i++) {
                            blocks.push(createBlock(5 + i * 3, blockRows - 1, 1, 'lava'));
                        }
                    }
                    break;
                    
                case 64:
                    // Quasar jets
                    const quasarColors = ['#FF00FF', '#FF1493', '#FF69B4', '#FFB6C1', '#FFC0CB'];
                    const quasarCenterX = blockCols / 2;
                    const quasarCenterY = blockRows / 2;
                    
                    // Central quasar - metal core
                    blocks.push(createBlock(Math.floor(quasarCenterX), Math.floor(quasarCenterY), getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // Jet streams - vertical
                    for (let jet = 0; jet < 2; jet++) {
                        const direction = jet === 0 ? -1 : 1;
                        for (let i = 1; i < 5; i++) {
                            const row = Math.floor(quasarCenterY + direction * i);
                            if (row >= 0 && row < blockRows) {
                                const width = Math.max(1, 3 - Math.floor(i / 2));
                                for (let w = -width; w <= width; w++) {
                                    const col = Math.floor(quasarCenterX + w);
                                    if (col >= 0 && col < blockCols) {
                                        // 38% single-hit, 62% multi-hit
                                        const hits = Math.random() < 0.38 ? 1 : 2 + Math.floor(Math.random() * 3);
                                        blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', quasarColors[i % quasarColors.length]));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Accretion disk - horizontal
                    for (let i = -4; i <= 4; i++) {
                        if (i !== 0) {
                            const col = Math.floor(quasarCenterX + i);
                            if (col >= 0 && col < blockCols) {
                                // 36% single-hit, 64% multi-hit
                                const hits = Math.random() < 0.36 ? 1 : 2 + Math.floor(Math.random() * 3);
                                blocks.push(createBlock(col, Math.floor(quasarCenterY), getBlockHitCount(currentLevel, hits), 'normal', quasarColors[Math.abs(i) % quasarColors.length]));
                            }
                        }
                    }
                    
                    // Metal particle accelerators - 29% total metal
                    const acceleratorCount = Math.floor(blockRows * blockCols * 0.20);
                    for (let i = 0; i < acceleratorCount; i++) {
                        const angle = (i / acceleratorCount) * Math.PI * 2;
                        const radius = 3 + (i % 2);
                        const row = Math.floor(quasarCenterY + radius * Math.sin(angle));
                        const col = Math.floor(quasarCenterX + radius * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols &&
                            !blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava
                    if (currentLevel >= 7) {
                        blocks.push(createBlock(0, 0, 1, 'lava'));
                        blocks.push(createBlock(blockCols - 1, 0, 1, 'lava'));
                    }
                    break;
                    
                case 65:
                    // Special level - Space station (map clearing)
                    const stationColors = ['#708090', '#778899', '#B0C4DE', '#C0C0C0', '#D3D3D3'];
                    
                    // Station framework - easier pattern
                    // Outer ring
                    for (let col = 2; col < blockCols - 2; col++) {
                        // Top and bottom with gaps
                        if (col % 3 !== 1) {
                            blocks.push(createBlock(col, 1, 1, 'normal', stationColors[0]));
                            blocks.push(createBlock(col, blockRows - 2, 1, 'normal', stationColors[0]));
                        }
                    }
                    
                    for (let row = 2; row < blockRows - 2; row++) {
                        // Left and right with gaps
                        if (row % 3 !== 1) {
                            blocks.push(createBlock(2, row, 1, 'normal', stationColors[1]));
                            blocks.push(createBlock(blockCols - 3, row, 1, 'normal', stationColors[1]));
                        }
                    }
                    
                    // Central docking bay - mostly single-hit
                    const bayX = blockCols / 2;
                    const bayY = blockRows / 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const row = Math.floor(bayY + 2 * Math.sin(angle));
                        const col = Math.floor(bayX + 2 * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            blocks.push(createBlock(col, row, 1, 'normal', stationColors[2]));
                        }
                    }
                    
                    // Metal support beams - just a few
                    blocks.push(createBlock(Math.floor(bayX), Math.floor(bayY), getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(2, 1, getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(blockCols - 3, 1, getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(2, blockRows - 2, getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(blockCols - 3, blockRows - 2, getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // No lava on special clearing levels
                    break;
                    
                case 66:
                    // Wormhole spiral
                    const wormholeColors = ['#4B0082', '#6A0DAD', '#7B68EE', '#8A2BE2', '#9370DB'];
                    const wormholeCenterX = blockCols / 2;
                    const wormholeCenterY = blockRows / 2;
                    
                    // Create spiral wormhole
                    for (let i = 0; i < 60; i++) {
                        const angle = i * 0.3;
                        const radius = i * 0.15;
                        const row = Math.floor(wormholeCenterY + radius * Math.sin(angle));
                        const col = Math.floor(wormholeCenterX + radius * Math.cos(angle));
                        
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            // 34% single-hit, 66% multi-hit
                            const hits = Math.random() < 0.34 ? 1 : 2 + Math.floor(Math.random() * 3);
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', wormholeColors[i % wormholeColors.length]));
                        }
                    }
                    
                    // Event horizon ring - metal
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const row = Math.floor(wormholeCenterY + 3 * Math.sin(angle));
                        const col = Math.floor(wormholeCenterX + 3 * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Spacetime distortions - 30% total metal
                    const distortionCount = Math.floor(blockRows * blockCols * 0.15);
                    for (let i = 0; i < distortionCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava - singularity debris
                    if (currentLevel >= 7) {
                        blocks.push(createBlock(0, Math.floor(blockRows / 2), 1, 'lava'));
                        blocks.push(createBlock(blockCols - 1, Math.floor(blockRows / 2), 1, 'lava'));
                    }
                    break;
                    
                case 67:
                    // Meteor shower
                    const meteorColors = ['#8B4513', '#A0522D', '#CD853F', '#DEB887', '#F4A460'];
                    
                    // Create meteor trails
                    for (let meteor = 0; meteor < 6; meteor++) {
                        const startCol = meteor * 2;
                        const startRow = 0;
                        const angle = Math.PI / 4 + (Math.random() - 0.5) * 0.3;
                        
                        for (let i = 0; i < 5; i++) {
                            const col = Math.floor(startCol + i * Math.cos(angle));
                            const row = Math.floor(startRow + i * Math.sin(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                if (i === 0) {
                                    // Meteor head - metal
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                                } else {
                                    // Meteor trail - 32% single-hit, 68% multi-hit
                                    const hits = Math.random() < 0.32 ? 1 : 2 + Math.floor(Math.random() * 3);
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', meteorColors[(i - 1) % meteorColors.length]));
                                }
                            }
                        }
                    }
                    
                    // Impact craters
                    for (let crater = 0; crater < 3; crater++) {
                        const craterX = 3 + crater * 4;
                        const craterY = blockRows - 3;
                        
                        for (let r = 0; r < 2; r++) {
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 3) {
                                const row = Math.floor(craterY + r * Math.sin(angle));
                                const col = Math.floor(craterX + r * Math.cos(angle));
                                if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                    // 30% single-hit, 70% multi-hit
                                    const hits = Math.random() < 0.30 ? 1 : 2 + Math.floor(Math.random() * 3);
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', meteorColors[crater % meteorColors.length]));
                                }
                            }
                        }
                    }
                    
                    // No additional lava - meteors provide enough chaos
                    break;
                    
                case 68:
                    // Galactic collision
                    const galaxy1Colors = ['#FF6347', '#FF7F50', '#FFA07A', '#FFB6C1', '#FFC0CB'];
                    const galaxy2Colors = ['#4169E1', '#4682B4', '#5F9EA0', '#87CEEB', '#87CEFA'];
                    
                    // Two colliding galaxies
                    const g1X = blockCols * 0.3;
                    const g1Y = blockRows * 0.3;
                    const g2X = blockCols * 0.7;
                    const g2Y = blockRows * 0.7;
                    
                    // Galaxy 1 spiral
                    for (let i = 0; i < 30; i++) {
                        const angle = i * 0.4;
                        const radius = Math.sqrt(i) * 0.6;
                        const row = Math.floor(g1Y + radius * Math.sin(angle));
                        const col = Math.floor(g1X + radius * Math.cos(angle));
                        
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            // 28% single-hit, 72% multi-hit
                            const hits = Math.random() < 0.28 ? 1 : 2 + Math.floor(Math.random() * 3);
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', galaxy1Colors[i % galaxy1Colors.length]));
                        }
                    }
                    
                    // Galaxy 2 spiral
                    for (let i = 0; i < 30; i++) {
                        const angle = -i * 0.4;
                        const radius = Math.sqrt(i) * 0.6;
                        const row = Math.floor(g2Y + radius * Math.sin(angle));
                        const col = Math.floor(g2X + radius * Math.cos(angle));
                        
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            // 26% single-hit, 74% multi-hit
                            const hits = Math.random() < 0.26 ? 1 : 2 + Math.floor(Math.random() * 3);
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', galaxy2Colors[i % galaxy2Colors.length]));
                        }
                    }
                    
                    // Metal galactic cores
                    blocks.push(createBlock(Math.floor(g1X), Math.floor(g1Y), getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(Math.floor(g2X), Math.floor(g2Y), getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // Collision zone - mixed blocks
                    const collisionX = (g1X + g2X) / 2;
                    const collisionY = (g1Y + g2Y) / 2;
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * 2 + 1;
                        const row = Math.floor(collisionY + radius * Math.sin(angle));
                        const col = Math.floor(collisionX + radius * Math.cos(angle));
                        
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            if (i % 3 === 0) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            } else {
                                // 24% single-hit, 76% multi-hit
                                const hits = Math.random() < 0.24 ? 1 : 3 + Math.floor(Math.random() * 2);
                                const colors = i % 2 === 0 ? galaxy1Colors : galaxy2Colors;
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', colors[i % colors.length]));
                            }
                        }
                    }
                    break;
                    
                case 69:
                    // Dark matter web
                    const darkMatterColors = ['#191970', '#000080', '#00008B', '#0000CD', '#0000FF'];
                    
                    // Create interconnected web nodes
                    const webNodes = [];
                    for (let i = 0; i < 8; i++) {
                        const row = 1 + Math.floor(Math.random() * (blockRows - 2));
                        const col = 1 + Math.floor(Math.random() * (blockCols - 2));
                        webNodes.push({row, col});
                        
                        // Metal nodes
                        blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                    }
                    
                    // Connect nodes with dark matter strands
                    for (let i = 0; i < webNodes.length; i++) {
                        for (let j = i + 1; j < webNodes.length; j++) {
                            if (Math.random() < 0.6) { // 60% chance to connect
                                const node1 = webNodes[i];
                                const node2 = webNodes[j];
                                const steps = 5;
                                
                                for (let s = 1; s < steps; s++) {
                                    const t = s / steps;
                                    const col = Math.floor(node1.col + (node2.col - node1.col) * t);
                                    const row = Math.floor(node1.row + (node2.row - node1.row) * t);
                                    
                                    if (row >= 0 && row < blockRows && col >= 0 && col < blockCols &&
                                        !blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                                        // 22% single-hit, 78% multi-hit
                                        const hits = Math.random() < 0.22 ? 1 : 2 + Math.floor(Math.random() * 3);
                                        blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', darkMatterColors[s % darkMatterColors.length]));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Dark matter halos around nodes
                    for (let node of webNodes) {
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 3) {
                            const row = Math.floor(node.row + Math.sin(angle));
                            const col = Math.floor(node.col + Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols &&
                                !blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                                // 20% single-hit, 80% multi-hit
                                const hits = Math.random() < 0.20 ? 1 : 3;
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', darkMatterColors[0]));
                            }
                        }
                    }
                    break;
                    
                case 70:
                    // Special level - Cosmic finale (map clearing)
                    const cosmicFinaleColors = colorThemes.space;
                    
                    // Create a beautiful but easy-to-clear cosmic pattern
                    // Central star burst
                    const burstX = blockCols / 2;
                    const burstY = blockRows / 2;
                    
                    // Star rays - mostly single-hit for easy clearing
                    for (let ray = 0; ray < 8; ray++) {
                        const angle = (ray / 8) * Math.PI * 2;
                        for (let r = 1; r < 4; r++) {
                            const row = Math.floor(burstY + r * Math.sin(angle));
                            const col = Math.floor(burstX + r * Math.cos(angle));
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                // 30% single-hit at level 70
                                const hits = Math.random() < 0.30 ? 1 : 2;
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', cosmicFinaleColors[ray % cosmicFinaleColors.length]));
                            }
                        }
                    }
                    
                    // Corner constellations - single hit
                    const corners = [[1, 1], [blockCols - 2, 1], [1, blockRows - 2], [blockCols - 2, blockRows - 2]];
                    for (let corner of corners) {
                        blocks.push(createBlock(corner[0], corner[1], 1, 'normal', cosmicFinaleColors[0]));
                    }
                    
                    // Central metal star
                    blocks.push(createBlock(Math.floor(burstX), Math.floor(burstY), getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // No lava on special clearing levels
                    break;
                    
                // Energy/Light/Crystal themed levels 71-85
                case 71:
                    // Crystal cavern entrance
                    const crystalColors = ['#E6E6FA', '#DDA0DD', '#DA70D6', '#BA55D3', '#9370DB'];
                    
                    // Crystal formations
                    for (let formation = 0; formation < 5; formation++) {
                        const baseCol = 2 + formation * 2;
                        const baseRow = blockRows - 2;
                        
                        // Crystal growth pattern
                        for (let height = 0; height < 4 - (formation % 2); height++) {
                            const row = baseRow - height;
                            if (row >= 0) {
                                // Tip of crystal - less hits
                                const hits = height === 3 - (formation % 2) ? 2 : 3;
                                blocks.push(createBlock(baseCol, row, getBlockHitCount(currentLevel, hits), 'normal', crystalColors[height % crystalColors.length]));
                            }
                        }
                    }
                    
                    // Metal crystal bases - 30% metal density
                    for (let i = 0; i < 5; i++) {
                        blocks.push(createBlock(2 + i * 2, blockRows - 1, getBlockHitCount(currentLevel, 4), 'metal'));
                    }
                    
                    // Floating crystal shards
                    for (let i = 0; i < 15; i++) {
                        const row = Math.floor(Math.random() * (blockRows - 3));
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            // 18% single-hit, 82% multi-hit
                            const hits = Math.random() < 0.18 ? 1 : 2 + Math.floor(Math.random() * 3);
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', crystalColors[i % crystalColors.length]));
                        }
                    }
                    
                    // Additional metal deposits
                    const metalDepositCount = Math.floor(blockRows * blockCols * 0.15);
                    for (let i = 0; i < metalDepositCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // Minimal lava - volcanic crystals
                    if (currentLevel >= 7) {
                        blocks.push(createBlock(0, 0, 1, 'lava'));
                        blocks.push(createBlock(blockCols - 1, 0, 1, 'lava'));
                    }
                    break;
                    
                case 72:
                    // Light prism refraction
                    const prismColors = colorThemes.rainbow;
                    const prismX = 2;
                    const prismY = blockRows / 2;
                    
                    // Create prism shape - metal
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j <= i; j++) {
                            const row = Math.floor(prismY - i / 2 + j);
                            if (row >= 0 && row < blockRows) {
                                blocks.push(createBlock(prismX + i, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    
                    // Light beam entering prism
                    for (let i = 0; i < prismX; i++) {
                        blocks.push(createBlock(i, Math.floor(prismY), 2, 'normal', '#FFFFFF'));
                    }
                    
                    // Refracted rainbow beams
                    for (let color = 0; color < prismColors.length; color++) {
                        const angle = (color - 3) * 0.15;
                        const startCol = prismX + 3;
                        
                        for (let i = 0; i < 8; i++) {
                            const col = startCol + i;
                            const row = Math.floor(prismY + angle * i);
                            if (row >= 0 && row < blockRows && col < blockCols) {
                                // 16% single-hit, 84% multi-hit
                                const hits = Math.random() < 0.16 ? 1 : 2 + Math.floor(Math.random() * 3);
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', prismColors[color]));
                            }
                        }
                    }
                    
                    // Additional metal mirrors - 31% total metal
                    const mirrorCount = Math.floor(blockRows * blockCols * 0.20);
                    for (let i = 0; i < mirrorCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = 5 + Math.floor(Math.random() * (blockCols - 5));
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    break;
                    
                case 73:
                    // Energy field grid
                    const energyColors = ['#00FFFF', '#00CCFF', '#0099FF', '#0066FF', '#0033FF'];
                    
                    // Create energy grid nodes
                    for (let row = 1; row < blockRows - 1; row += 2) {
                        for (let col = 1; col < blockCols - 1; col += 2) {
                            // Node points - metal
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            
                            // Horizontal energy connections
                            if (col < blockCols - 3) {
                                // 14% single-hit, 86% multi-hit
                                const hits = Math.random() < 0.14 ? 1 : 2 + Math.floor(Math.random() * 3);
                                blocks.push(createBlock(col + 1, row, getBlockHitCount(currentLevel, hits), 'normal', energyColors[(row + col) % energyColors.length]));
                            }
                            
                            // Vertical energy connections
                            if (row < blockRows - 3) {
                                // 12% single-hit, 88% multi-hit
                                const hits = Math.random() < 0.12 ? 1 : 2 + Math.floor(Math.random() * 3);
                                blocks.push(createBlock(col, row + 1, getBlockHitCount(currentLevel, hits), 'normal', energyColors[(row + col) % energyColors.length]));
                            }
                        }
                    }
                    break;
                    
                case 74:
                    // Plasma core reactor
                    const plasmaColors = ['#FF1493', '#FF69B4', '#FFB6C1', '#FF00FF', '#DA70D6'];
                    const reactorX = blockCols / 2;
                    const reactorY = blockRows / 2;
                    
                    // Reactor core - metal center
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const row = Math.floor(reactorY + dy);
                            const col = Math.floor(reactorX + dx);
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    
                    // Plasma containment rings
                    for (let ring = 0; ring < 3; ring++) {
                        const radius = 2 + ring;
                        const segments = 8 + ring * 4;
                        
                        for (let i = 0; i < segments; i++) {
                            const angle = (i / segments) * Math.PI * 2;
                            const row = Math.floor(reactorY + radius * Math.sin(angle));
                            const col = Math.floor(reactorX + radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                if (i % 3 === 0) {
                                    // Containment field generators - metal
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                                } else {
                                    // 10% single-hit, 90% multi-hit
                                    const hits = Math.random() < 0.10 ? 1 : 3 + Math.floor(Math.random() * 2);
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', plasmaColors[ring % plasmaColors.length]));
                                }
                            }
                        }
                    }
                    break;
                    
                case 75:
                    // Special level - Crystal palace (map clearing)
                    const palaceColors = ['#E6E6FA', '#D8BFD8', '#DDA0DD', '#DA70D6', '#BA55D3'];
                    
                    // Palace outline - easy to clear
                    // Towers in corners
                    const towerPositions = [[1, 1], [blockCols - 2, 1], [1, blockRows - 2], [blockCols - 2, blockRows - 2]];
                    for (let pos of towerPositions) {
                        blocks.push(createBlock(pos[0], pos[1], 1, 'normal', palaceColors[0]));
                        blocks.push(createBlock(pos[0], pos[1] + (pos[1] === 1 ? 1 : -1), 1, 'normal', palaceColors[1]));
                    }
                    
                    // Palace walls - single hit
                    for (let col = 2; col < blockCols - 2; col++) {
                        if (col % 2 === 0) {
                            blocks.push(createBlock(col, 2, 1, 'normal', palaceColors[2]));
                            blocks.push(createBlock(col, blockRows - 3, 1, 'normal', palaceColors[2]));
                        }
                    }
                    
                    // Crystal throne in center
                    const throneX = Math.floor(blockCols / 2);
                    const throneY = Math.floor(blockRows / 2);
                    blocks.push(createBlock(throneX, throneY, 2, 'normal', palaceColors[4]));
                    blocks.push(createBlock(throneX - 1, throneY, 1, 'normal', palaceColors[3]));
                    blocks.push(createBlock(throneX + 1, throneY, 1, 'normal', palaceColors[3]));
                    
                    // Metal crown jewels
                    blocks.push(createBlock(throneX, throneY - 1, getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // No lava on special clearing levels
                    break;
                    
                case 76:
                    // Lightning storm pattern
                    const lightningColors = ['#FFFF00', '#FFFF33', '#FFFF66', '#FFFF99', '#FFFFCC'];
                    
                    // Create lightning bolts
                    for (let bolt = 0; bolt < 4; bolt++) {
                        const startCol = 2 + bolt * 3;
                        let currentCol = startCol;
                        
                        for (let row = 0; row < blockRows; row++) {
                            // Lightning zigzag
                            if (row > 0 && Math.random() < 0.4) {
                                currentCol += Math.random() < 0.5 ? -1 : 1;
                                currentCol = Math.max(0, Math.min(blockCols - 1, currentCol));
                            }
                            
                            // 8% single-hit, 92% multi-hit
                            const hits = Math.random() < 0.08 ? 1 : 3 + Math.floor(Math.random() * 2);
                            blocks.push(createBlock(currentCol, row, getBlockHitCount(currentLevel, hits), 'normal', lightningColors[row % lightningColors.length]));
                            
                            // Branch lightning
                            if (row % 3 === 0 && Math.random() < 0.3) {
                                const branchDir = Math.random() < 0.5 ? -1 : 1;
                                const branchCol = currentCol + branchDir;
                                if (branchCol >= 0 && branchCol < blockCols) {
                                    blocks.push(createBlock(branchCol, row, getBlockHitCount(currentLevel, 2), 'normal', lightningColors[2]));
                                }
                            }
                        }
                    }
                    
                    // Metal lightning rods - 33% total metal
                    const rodCount = Math.floor(blockRows * blockCols * 0.25);
                    for (let i = 0; i < rodCount; i++) {
                        const col = Math.floor(Math.random() * blockCols);
                        const row = blockRows - 1 - Math.floor(Math.random() * 3);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    break;
                    
                case 77:
                    // Holographic matrix
                    const holoColors = ['#00FF00', '#00FF33', '#00FF66', '#00FF99', '#00FFCC'];
                    
                    // Create holographic grid layers
                    for (let layer = 0; layer < 3; layer++) {
                        const offset = layer * 2;
                        
                        for (let row = offset; row < blockRows - offset; row += 3) {
                            for (let col = offset; col < blockCols - offset; col += 3) {
                                if ((row + col) % 2 === layer % 2) {
                                    // 6% single-hit, 94% multi-hit
                                    const hits = Math.random() < 0.06 ? 1 : 3 + Math.floor(Math.random() * 2);
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', holoColors[layer % holoColors.length]));
                                    
                                    // Holographic connectors
                                    if (col < blockCols - offset - 3) {
                                        blocks.push(createBlock(col + 1, row, getBlockHitCount(currentLevel, 2), 'normal', holoColors[(layer + 1) % holoColors.length]));
                                    }
                                    if (row < blockRows - offset - 3) {
                                        blocks.push(createBlock(col, row + 1, getBlockHitCount(currentLevel, 2), 'normal', holoColors[(layer + 2) % holoColors.length]));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Metal projector nodes - 34% total metal
                    const projectorCount = Math.floor(blockRows * blockCols * 0.30);
                    for (let i = 0; i < projectorCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    break;
                    
                case 78:
                    // Quantum entanglement
                    const quantumColors = ['#9370DB', '#8B7ADD', '#7B68EE', '#6A5ACD', '#5949B0'];
                    
                    // Create entangled particle pairs
                    const particlePairs = 8;
                    for (let pair = 0; pair < particlePairs; pair++) {
                        // Generate two entangled positions
                        const pos1Row = 1 + Math.floor(Math.random() * (blockRows - 2));
                        const pos1Col = 1 + Math.floor(Math.random() * (blockCols - 2));
                        const pos2Row = blockRows - 1 - pos1Row;
                        const pos2Col = blockCols - 1 - pos1Col;
                        
                        // Entangled particles - metal
                        blocks.push(createBlock(pos1Col, pos1Row, getBlockHitCount(currentLevel, 4), 'metal'));
                        blocks.push(createBlock(pos2Col, pos2Row, getBlockHitCount(currentLevel, 4), 'metal'));
                        
                        // Quantum field around particles
                        for (let d = -1; d <= 1; d++) {
                            for (let e = -1; e <= 1; e++) {
                                if (d !== 0 || e !== 0) {
                                    const row1 = pos1Row + d;
                                    const col1 = pos1Col + e;
                                    const row2 = pos2Row - d;
                                    const col2 = pos2Col - e;
                                    
                                    if (row1 >= 0 && row1 < blockRows && col1 >= 0 && col1 < blockCols) {
                                        // 4% single-hit, 96% multi-hit
                                        const hits = Math.random() < 0.04 ? 1 : 3 + Math.floor(Math.random() * 2);
                                        blocks.push(createBlock(col1, row1, getBlockHitCount(currentLevel, hits), 'normal', quantumColors[pair % quantumColors.length]));
                                    }
                                    if (row2 >= 0 && row2 < blockRows && col2 >= 0 && col2 < blockCols) {
                                        // 4% single-hit, 96% multi-hit
                                        const hits = Math.random() < 0.04 ? 1 : 3 + Math.floor(Math.random() * 2);
                                        blocks.push(createBlock(col2, row2, getBlockHitCount(currentLevel, hits), 'normal', quantumColors[pair % quantumColors.length]));
                                    }
                                }
                            }
                        }
                    }
                    break;
                    
                case 79:
                    // Solar flare eruption
                    const flareColors = ['#FF0000', '#FF3300', '#FF6600', '#FF9900', '#FFCC00'];
                    const solarX = blockCols / 2;
                    const solarY = blockRows - 1;
                    
                    // Solar surface - metal base
                    for (let col = 0; col < blockCols; col++) {
                        blocks.push(createBlock(col, blockRows - 1, getBlockHitCount(currentLevel, 4), 'metal'));
                    }
                    
                    // Flare eruptions
                    for (let flare = 0; flare < 5; flare++) {
                        const flareBase = 2 + flare * 2;
                        const flareHeight = 5 + Math.floor(Math.random() * 3);
                        const flareAngle = (Math.random() - 0.5) * 0.5;
                        
                        for (let h = 1; h < flareHeight; h++) {
                            const col = Math.floor(flareBase + h * flareAngle);
                            const row = blockRows - 1 - h;
                            
                            if (row >= 0 && col >= 0 && col < blockCols) {
                                // 2% single-hit, 98% multi-hit
                                const hits = Math.random() < 0.02 ? 1 : 3 + Math.floor(Math.random() * 2);
                                const colorIndex = Math.min(h - 1, flareColors.length - 1);
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', flareColors[colorIndex]));
                                
                                // Flare spread
                                if (h > 2 && Math.random() < 0.5) {
                                    const spreadCol = col + (Math.random() < 0.5 ? -1 : 1);
                                    if (spreadCol >= 0 && spreadCol < blockCols) {
                                        blocks.push(createBlock(spreadCol, row, getBlockHitCount(currentLevel, 2), 'normal', flareColors[colorIndex]));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Additional metal sunspots - 36% total metal
                    const sunspotCount = Math.floor(blockRows * blockCols * 0.15);
                    for (let i = 0; i < sunspotCount; i++) {
                        const row = blockRows - 2 - Math.floor(Math.random() * 3);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    break;
                    
                case 80:
                    // Special level - Energy nexus (map clearing)
                    const nexusColors = ['#00FFFF', '#00CCFF', '#0099FF', '#0066FF', '#0033FF'];
                    
                    // Central nexus - easy pattern
                    const nexusX = blockCols / 2;
                    const nexusY = blockRows / 2;
                    
                    // Energy ring - mostly single/double hit
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const row = Math.floor(nexusY + 3 * Math.sin(angle));
                        const col = Math.floor(nexusX + 3 * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                            blocks.push(createBlock(col, row, 1, 'normal', nexusColors[i % nexusColors.length]));
                        }
                    }
                    
                    // Inner energy core
                    blocks.push(createBlock(Math.floor(nexusX), Math.floor(nexusY), 2, 'normal', nexusColors[4]));
                    
                    // Energy conduits - easy to clear
                    const conduits = [[nexusX, 0], [0, nexusY], [blockCols - 1, nexusY], [nexusX, blockRows - 1]];
                    for (let conduit of conduits) {
                        const targetCol = Math.floor(conduit[0]);
                        const targetRow = Math.floor(conduit[1]);
                        
                        // Draw line from center to target
                        const steps = 5;
                        for (let s = 1; s < steps; s++) {
                            const t = s / steps;
                            const col = Math.floor(nexusX + (targetCol - nexusX) * t);
                            const row = Math.floor(nexusY + (targetRow - nexusY) * t);
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, 1, 'normal', nexusColors[2]));
                            }
                        }
                    }
                    
                    // Metal stabilizers at endpoints
                    blocks.push(createBlock(Math.floor(nexusX), 0, getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(0, Math.floor(nexusY), getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(blockCols - 1, Math.floor(nexusY), getBlockHitCount(currentLevel, 4), 'metal'));
                    blocks.push(createBlock(Math.floor(nexusX), blockRows - 1, getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // No lava on special clearing levels
                    break;
                    
                case 81:
                    // Laser grid security system
                    const laserColors = ['#FF0000', '#FF0066', '#FF00CC', '#CC00FF', '#6600FF'];
                    
                    // Horizontal laser beams
                    for (let row = 1; row < blockRows; row += 2) {
                        for (let col = 0; col < blockCols; col++) {
                            if (col === 0 || col === blockCols - 1) {
                                // Laser emitters - metal
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            } else {
                                // 0% single-hit at level 81+
                                const hits = 3 + Math.floor(Math.random() * 2);
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', laserColors[row % laserColors.length]));
                            }
                        }
                    }
                    
                    // Vertical laser beams
                    for (let col = 2; col < blockCols - 2; col += 3) {
                        for (let row = 0; row < blockRows; row++) {
                            if (row % 2 === 0 && !blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                                if (row === 0 || row === blockRows - 1) {
                                    // More laser emitters
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                                } else {
                                    // All multi-hit blocks
                                    const hits = 3 + Math.floor(Math.random() * 2);
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', laserColors[col % laserColors.length]));
                                }
                            }
                        }
                    }
                    break;
                    
                case 82:
                    // Aurora borealis waves
                    const auroraColors = ['#00FF00', '#00FF7F', '#00FFFF', '#007FFF', '#0000FF'];
                    
                    // Create flowing aurora waves
                    for (let wave = 0; wave < 4; wave++) {
                        const waveOffset = wave * 2;
                        const amplitude = 2;
                        const frequency = 0.5;
                        
                        for (let col = 0; col < blockCols; col++) {
                            const row = Math.floor(blockRows / 2 + amplitude * Math.sin(frequency * col + waveOffset));
                            
                            if (row >= 0 && row < blockRows) {
                                // Wave crest - all multi-hit
                                const hits = 3 + Math.floor(Math.random() * 2);
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', auroraColors[wave % auroraColors.length]));
                                
                                // Aurora curtain effect
                                for (let curtain = 1; curtain <= 2; curtain++) {
                                    const curtainRow = row + curtain * (wave % 2 === 0 ? 1 : -1);
                                    if (curtainRow >= 0 && curtainRow < blockRows) {
                                        const curtainHits = 2 + Math.floor(Math.random() * 2);
                                        blocks.push(createBlock(col, curtainRow, getBlockHitCount(currentLevel, curtainHits), 'normal', auroraColors[(wave + curtain) % auroraColors.length]));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Metal magnetic poles - 38% total metal
                    const poleCount = Math.floor(blockRows * blockCols * 0.38);
                    for (let i = 0; i < poleCount; i++) {
                        const row = i < poleCount / 2 ? 0 : blockRows - 1;
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    break;
                    
                case 83:
                    // Crystalline matrix final form
                    const matrixColors = ['#E6E6FA', '#DDA0DD', '#DA70D6', '#BA55D3', '#9370DB'];
                    
                    // Create interconnected crystal lattice
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if ((row + col) % 2 === 0) {
                                if ((row % 4 === 0 && col % 4 === 0)) {
                                    // Major crystal nodes - metal
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                                } else {
                                    // Crystal lattice - all multi-hit
                                    const hits = 3 + Math.floor(Math.random() * 2);
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, hits), 'normal', matrixColors[(row + col) % matrixColors.length]));
                                }
                            }
                        }
                    }
                    
                    // Additional metal reinforcement - 39% total metal
                    const reinforceCount = Math.floor(blockRows * blockCols * 0.20);
                    for (let i = 0; i < reinforceCount; i++) {
                        const row = Math.floor(Math.random() * blockRows);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    break;
                    
                case 84:
                    // Photon cascade finale
                    const photonColors = ['#FFFF00', '#FFFF33', '#FFFF66', '#FFFF99', '#FFFFCC'];
                    
                    // Create cascading photon streams
                    for (let stream = 0; stream < blockCols; stream++) {
                        const startRow = Math.floor(Math.random() * 3);
                        let intensity = 4;
                        
                        for (let row = startRow; row < blockRows && intensity > 0; row++) {
                            // All multi-hit blocks
                            const hits = intensity;
                            blocks.push(createBlock(stream, row, getBlockHitCount(currentLevel, hits), 'normal', photonColors[4 - intensity]));
                            
                            // Photon spread
                            if (Math.random() < 0.3 && intensity > 1) {
                                intensity--;
                                
                                // Spread to adjacent columns
                                if (stream > 0 && Math.random() < 0.5) {
                                    blocks.push(createBlock(stream - 1, row, getBlockHitCount(currentLevel, intensity), 'normal', photonColors[4 - intensity]));
                                }
                                if (stream < blockCols - 1 && Math.random() < 0.5) {
                                    blocks.push(createBlock(stream + 1, row, getBlockHitCount(currentLevel, intensity), 'normal', photonColors[4 - intensity]));
                                }
                            }
                        }
                    }
                    
                    // Metal photon collectors - 40% total metal
                    const collectorCount = Math.floor(blockRows * blockCols * 0.40);
                    for (let i = 0; i < collectorCount; i++) {
                        const row = blockRows - 1 - Math.floor(Math.random() * 3);
                        const col = Math.floor(Math.random() * blockCols);
                        if (!blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    break;
                    
                case 85:
                    // Special level - Ultimate energy convergence (map clearing + final challenge)
                    const convergenceColors = colorThemes.rainbow;
                    
                    // Create the ultimate pattern - challenging but fair
                    const convergenceX = blockCols / 2;
                    const convergenceY = blockRows / 2;
                    
                    // Energy convergence rings - 0% single-hit blocks
                    for (let ring = 0; ring < 4; ring++) {
                        const radius = ring + 1;
                        const segments = 6 + ring * 2;
                        
                        for (let i = 0; i < segments; i++) {
                            const angle = (i / segments) * Math.PI * 2;
                            const row = Math.floor(convergenceY + radius * Math.sin(angle));
                            const col = Math.floor(convergenceX + radius * Math.cos(angle));
                            
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols) {
                                if (ring < 2) {
                                    // Inner rings - harder
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 3), 'normal', convergenceColors[ring % convergenceColors.length]));
                                } else {
                                    // Outer rings - slightly easier
                                    blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 2), 'normal', convergenceColors[ring % convergenceColors.length]));
                                }
                            }
                        }
                    }
                    
                    // Ultimate metal core - 40% metal blocks
                    blocks.push(createBlock(Math.floor(convergenceX), Math.floor(convergenceY), getBlockHitCount(currentLevel, 4), 'metal'));
                    
                    // Cardinal metal anchors
                    const anchors = [
                        [convergenceX, 0],
                        [0, convergenceY],
                        [blockCols - 1, convergenceY],
                        [convergenceX, blockRows - 1]
                    ];
                    
                    for (let anchor of anchors) {
                        blocks.push(createBlock(Math.floor(anchor[0]), Math.floor(anchor[1]), getBlockHitCount(currentLevel, 4), 'metal'));
                    }
                    
                    // Energy beams connecting to center - multi-hit only
                    for (let anchor of anchors) {
                        const steps = 4;
                        for (let s = 1; s < steps; s++) {
                            const t = s / steps;
                            const col = Math.floor(convergenceX + (anchor[0] - convergenceX) * t);
                            const row = Math.floor(convergenceY + (anchor[1] - convergenceY) * t);
                            if (row >= 0 && row < blockRows && col >= 0 && col < blockCols &&
                                !blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 2), 'normal', convergenceColors[s % convergenceColors.length]));
                            }
                        }
                    }
                    
                    // Final metal framework - reaching 40% total
                    const frameworkCount = Math.floor(blockRows * blockCols * 0.30);
                    for (let i = 0; i < frameworkCount; i++) {
                        const angle = (i / frameworkCount) * Math.PI * 2;
                        const radius = 4 + Math.sin(angle * 3);
                        const row = Math.floor(convergenceY + radius * Math.sin(angle));
                        const col = Math.floor(convergenceX + radius * Math.cos(angle));
                        if (row >= 0 && row < blockRows && col >= 0 && col < blockCols &&
                            !blocks.some(b => b.x === col * (blockWidth + blockPadding) && b.y === row * (blockHeight + blockPadding))) {
                            blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                        }
                    }
                    
                    // No lava on final special level
                    break;
                    
                // SHADOW REALM LEVELS 86-100 - Dark endgame with void barriers
                case 86:
                    // "Barrier Genesis" - First void blocks, simple cross pattern
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if (col === Math.floor(blockCols / 2) || row === Math.floor(blockRows / 2)) {
                                // Create void barriers in cross formation
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if ((row + col) % 3 === 0) {
                                // Regular blocks with dark theme
                                const darkColor = getDarkThemeColor(col, row, 86);
                                blocks.push(createBlock(col, row, getBlockHitCount(86, 2), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 87:
                    // "Void Corridors" - Horizontal void lanes
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if (row === 2 || row === 5 || row === 8) {
                                // Void barrier rows
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (col % 2 === 0) {
                                const darkColor = getDarkThemeColor(col, row, 87);
                                blocks.push(createBlock(col, row, getBlockHitCount(87, 2), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 88:
                    // "Shadow Maze" - Simple maze pattern with void walls
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if (col === 0 || col === blockCols - 1 || 
                               (row % 4 === 0 && col % 3 !== 1) ||
                               (col % 6 === 3 && row % 3 !== 0)) {
                                // Void maze walls
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if ((row + col) % 2 === 0) {
                                const darkColor = getDarkThemeColor(col, row, 88);
                                blocks.push(createBlock(col, row, getBlockHitCount(88, 3), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 89:
                    // "Diagonal Shadows" - Diagonal void barriers
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if (Math.abs(row - col) === 3 || Math.abs(row + col - blockCols) === 3) {
                                // Diagonal void barriers
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if ((row * col) % 5 === 0) {
                                const darkColor = getDarkThemeColor(col, row, 89);
                                blocks.push(createBlock(col, row, getBlockHitCount(89, 3), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 90:
                    // "Void Fortress" - Fortress pattern with void walls
                    const centerX = Math.floor(blockCols / 2);
                    const centerY = Math.floor(blockRows / 2);
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const distance = Math.max(Math.abs(col - centerX), Math.abs(row - centerY));
                            if (distance === 2 || distance === 5) {
                                // Void fortress walls
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (distance % 2 === 1 && distance < 6) {
                                const darkColor = getDarkThemeColor(col, row, 90);
                                blocks.push(createBlock(col, row, getBlockHitCount(90, 3), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 91:
                    // "Abyss Gates" - Strategic void placement requiring skill
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if ((col === 2 || col === blockCols - 3) && row >= 2 && row <= 7) {
                                // Vertical void gates
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if ((row === 2 || row === 7) && col >= 3 && col <= blockCols - 4) {
                                // Horizontal void gates
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (Math.random() < 0.6) {
                                const darkColor = getDarkThemeColor(col, row, 91);
                                blocks.push(createBlock(col, row, getBlockHitCount(91, 4), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 92:
                    // "Spiral Void" - Spiral void pattern
                    const spiralCenterX = Math.floor(blockCols / 2);
                    const spiralCenterY = Math.floor(blockRows / 2);
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const dx = col - spiralCenterX;
                            const dy = row - spiralCenterY;
                            const angle = Math.atan2(dy, dx);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const spiralArm = Math.floor((angle + Math.PI) / (Math.PI / 3)) % 6;
                            
                            if (Math.floor(distance - spiralArm) === 2) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (distance > 1 && distance < 5 && spiralArm % 2 === 0) {
                                const darkColor = getDarkThemeColor(col, row, 92);
                                blocks.push(createBlock(col, row, getBlockHitCount(92, 4), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 93:
                    // "Shadow Prison" - Complex void maze
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if ((col % 4 === 0 && row % 2 === 1) || 
                                (row % 4 === 0 && col % 2 === 1) ||
                                (col === Math.floor(blockCols / 2) && row < 3)) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if ((row + col) % 3 === 0) {
                                const darkColor = getDarkThemeColor(col, row, 93);
                                blocks.push(createBlock(col, row, getBlockHitCount(93, 4), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 94:
                    // "Void Cathedral" - Gothic arch patterns
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const archDistance = Math.min(
                                Math.sqrt(Math.pow(col - 3, 2) + Math.pow(row - 8, 2)),
                                Math.sqrt(Math.pow(col - (blockCols - 4), 2) + Math.pow(row - 8, 2))
                            );
                            
                            if (Math.abs(archDistance - 4) < 0.8 || 
                                (col === Math.floor(blockCols / 2) && row >= 5)) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (archDistance < 5 && row < 8) {
                                const darkColor = getDarkThemeColor(col, row, 94);
                                blocks.push(createBlock(col, row, getBlockHitCount(94, 5), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 95:
                    // "Darkness Rising" - Complex void barriers with limited paths
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const isVoidBarrier = 
                                (row === 1 && col % 3 !== 1) ||
                                (row === 4 && col % 4 === 0) ||
                                (row === 7 && col % 3 !== 2) ||
                                (col === 1 && row % 3 === 0) ||
                                (col === blockCols - 2 && row % 3 === 0);
                            
                            if (isVoidBarrier) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if ((row * col) % 4 === 0) {
                                const darkColor = getDarkThemeColor(col, row, 95);
                                blocks.push(createBlock(col, row, getBlockHitCount(95, 5), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 96:
                    // "Event Horizon" - Near-endgame challenge
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const ringDistance = Math.sqrt(
                                Math.pow(col - blockCols/2, 2) + Math.pow(row - blockRows/2, 2)
                            );
                            
                            if (Math.abs(ringDistance - 3) < 0.5 || Math.abs(ringDistance - 5.5) < 0.5) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (ringDistance < 6 && ringDistance > 1) {
                                const darkColor = getDarkThemeColor(col, row, 96);
                                blocks.push(createBlock(col, row, getBlockHitCount(96, 5), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 97:
                    // "Final Approach" - Extremely challenging void patterns
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if ((col + row) % 7 === 0 || 
                                (col - row) % 5 === 0 ||
                                (col === 0 || col === blockCols - 1) && row % 2 === 0) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if ((row * col) % 6 !== 0) {
                                const darkColor = getDarkThemeColor(col, row, 97);
                                blocks.push(createBlock(col, row, getBlockHitCount(97, 6), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 98:
                    // "Penultimate Shadow" - Master-level void manipulation
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const pattern = (col * 3 + row * 5) % 13;
                            if (pattern < 3 || (pattern > 6 && pattern < 10)) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (pattern !== 5) {
                                const darkColor = getDarkThemeColor(col, row, 98);
                                blocks.push(createBlock(col, row, getBlockHitCount(98, 6), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 99:
                    // "Edge of Oblivion" - Nearly impossible challenge
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const complexity = (col * row + col + row) % 11;
                            if (complexity < 4 || complexity === 7 || complexity === 9) {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (complexity !== 5 && complexity !== 8) {
                                const darkColor = getDarkThemeColor(col, row, 99);
                                blocks.push(createBlock(col, row, getBlockHitCount(99, 7), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                    
                case 100:
                    // "ULTIMATE VOID" - The final challenge
                    // Create the most challenging pattern with strategic void placement
                    const ultimatePattern = [
                        "VVVVVVVVVV",
                        "V.V...V.VV",  
                        "V..VVV..VV",
                        "VV.V.V.VVV",
                        "..VV.VV...",
                        "VV.V.V.VVV", 
                        "V..VVV..VV",
                        "V.V...V.VV",
                        "VVVVVVVVVV"
                    ];
                    
                    for (let row = 0; row < Math.min(ultimatePattern.length, blockRows); row++) {
                        for (let col = 0; col < Math.min(ultimatePattern[row].length, blockCols); col++) {
                            const char = ultimatePattern[row][col];
                            if (char === 'V') {
                                blocks.push(createBlock(col, row, 1, 'void'));
                            } else if (char === '.') {
                                const darkColor = getDarkThemeColor(col, row, 100);
                                blocks.push(createBlock(col, row, getBlockHitCount(100, 10), 'normal', darkColor));
                            }
                        }
                    }
                    break;
                default:
                    // For levels beyond 55, use enhanced combinations with progressive difficulty
                    const patternType = currentLevel % 10;
                    const themeIndex = currentLevel % Object.keys(colorThemes).length;
                    const themeName = Object.keys(colorThemes)[themeIndex];
                    
                    switch(patternType) {
                        case 0:
                            createSpiral(themeName, currentLevel, Math.ceil(currentLevel / 25));
                            break;
                        case 1:
                            createDiamond(themeName, currentLevel, true, Math.ceil(currentLevel / 25));
                            break;
                        case 2:
                            createCheckerboard(themeName, currentLevel, 2, Math.ceil(currentLevel / 25));
                            break;
                        case 3:
                            createWavePattern(themeName, currentLevel, 2, 0.3 + (currentLevel / 100), Math.ceil(currentLevel / 25));
                            break;
                        case 4:
                            createGradientPattern(themeName, currentLevel, 'radial', Math.ceil(currentLevel / 25));
                            break;
                        case 5:
                            createDiamond(themeName, currentLevel, false, Math.ceil(currentLevel / 25));
                            break;
                        case 6:
                            createGradientPattern(themeName, currentLevel, 'diagonal', Math.ceil(currentLevel / 25));
                            break;
                        case 7:
                            createCheckerboard(themeName, currentLevel, 3, Math.ceil(currentLevel / 25));
                            break;
                        case 8:
                            createWavePattern(themeName, currentLevel, 3, 0.5, Math.ceil(currentLevel / 25));
                            break;
                        case 9:
                            createSpiral(themeName, currentLevel, Math.ceil(currentLevel / 25));
                            createDiamond(themeName, currentLevel, false, Math.ceil(currentLevel / 25));
                            break;
                    }
                    
                    // Enhanced special blocks for higher levels
                    if (currentLevel >= 25) {
                        const metalCount = Math.min(8, Math.floor((currentLevel - 25) / 5));
                        for (let i = 0; i < metalCount; i++) {
                            const row = i % 2 === 0 ? 0 : blockRows - 1;
                            const col = Math.floor(i / 2) === 0 ? i * 2 : blockCols - 1 - (i * 2);
                            if (col >= 0 && col < blockCols) {
                                blocks.push(createBlock(col, row, getBlockHitCount(currentLevel, 4), 'metal'));
                            }
                        }
                    }
                    
                    // Enhanced lava block system starting at level 7 with progressive increase
                    if (currentLevel >= 7) {
                        const baseLavaCount = Math.floor((currentLevel - 7) / 3) + 1;
                        const lavaCount = Math.min(15, baseLavaCount + Math.floor(currentLevel / 20));
                        
                        for (let i = 0; i < lavaCount; i++) {
                            const row = Math.floor(blockRows / 3) + (i % 3);
                            const col = Math.floor(blockCols / 5) * (i % 4 + 1);
                            if (col < blockCols && row < blockRows) {
                                blocks.push(createBlock(col, row, 1, 'lava'));
                            }
                        }
                    }
                    break;
            }
            
            console.log(`Level ${currentLevel}: Generated ${blocks.length} blocks`);
        }

        // Determine block hit count based on level and progression
        function getBlockHitCount(currentLevel, requestedHits = 1) {
            // Apply level progression rules to requested hit count
            if (currentLevel < 15) {
                // Levels 1-14: Only single hit blocks
                return 1;
            } else if (currentLevel < 25) {
                // Levels 15-24: Introduce double hit blocks
                return Math.min(requestedHits, 2);
            } else if (currentLevel < 75) {
                // Levels 25-74: Up to 4-hit blocks (including metal)
                return Math.min(requestedHits, 4);
            } else if (currentLevel < 90) {
                // Levels 75-89: Up to 5-hit blocks
                return Math.min(requestedHits, 5);
            } else if (currentLevel < 95) {
                // Levels 90-94: Up to 6-hit blocks
                return Math.min(requestedHits, 6);
            } else if (currentLevel < 100) {
                // Levels 95-99: Up to 7-hit blocks
                return Math.min(requestedHits, 7);
            } else {
                // Level 100: Up to 10-hit blocks (ultimate challenge)
                return Math.min(requestedHits, 10);
            }
        }

        // Function to generate dark theme colors for levels 86-100
        function getDarkThemeColor(col, row, level) {
            // Progressive darkness - each level gets 6% darker
            const darknessMultiplier = 1.0 - ((level - 85) * 0.06);
            
            // Base color selection with some variety
            const colorIndex = (col + row * 2 + level) % blockColors.length;
            const baseColor = blockColors[colorIndex];
            
            // Parse hex color and apply darkness
            const hex = baseColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Apply darkness but maintain some color variety
            const darkR = Math.max(20, Math.floor(r * darknessMultiplier));
            const darkG = Math.max(20, Math.floor(g * darknessMultiplier));
            const darkB = Math.max(20, Math.floor(b * darknessMultiplier));
            
            // Add subtle purple tint for void theme
            const purpleTint = Math.min(50, (level - 85) * 3);
            const finalR = Math.min(255, darkR + purpleTint * 0.2);
            const finalG = Math.min(255, darkG);
            const finalB = Math.min(255, darkB + purpleTint * 0.4);
            
            return `#${Math.floor(finalR).toString(16).padStart(2, '0')}${Math.floor(finalG).toString(16).padStart(2, '0')}${Math.floor(finalB).toString(16).padStart(2, '0')}`;
        }

        // Calculate progressive treasure rewards based on level and hits
        function calculateTreasureReward(hits) {
            const baseReward = [100, 250, 500, 1000, 2500][Math.min(hits - 1, 4)];
            const levelMultiplier = Math.max(1, Math.floor(level / 5)); // Scales every 5 levels
            return baseReward * levelMultiplier;
        }

        function createBlock(col, row, hits = 1, type = 'normal', color = null) {
            const isMetalBrick = type === 'metal';
            const isLavaBrick = type === 'lava';
            const isVoidBrick = type === 'void';
            const isTreasureBrick = type === 'treasure';
            const isShieldBrick = type === 'shield';
            const isMagneticBrick = type === 'magnetic_attract' || type === 'magnetic_repel';
            
            let blockColor;
            if (color) {
                blockColor = color; // Use specific color for pixel art
            } else if (isMetalBrick) {
                blockColor = '#666666';
            } else if (isLavaBrick) {
                blockColor = '#FF4500'; // Lava orange-red color
            } else if (isVoidBrick) {
                blockColor = '#1a0d26'; // Deep dark purple for void blocks
            } else if (isTreasureBrick) {
                blockColor = '#FFD700'; // Golden treasure chest color
            } else if (isShieldBrick) {
                blockColor = '#4169E1'; // Royal blue for shield blocks
            } else if (isMagneticBrick) {
                blockColor = type === 'magnetic_attract' ? '#DC143C' : '#00CED1'; // Red for attract, cyan for repel
            } else if (hits === 5) {
                // Special ultra-hard block color - diamond-like appearance
                blockColor = '#E6E6FA'; // Lavender for diamond/crystal appearance
            } else {
                blockColor = blockColors[row % blockColors.length];
            }
            
            const blockX = col * (blockWidth + blockPadding) + blockPadding;
            const blockY = row * (blockHeight + blockPadding) + 63;
            
            return {
                id: Date.now() + Math.random(), // Unique ID for tracking elemental effects
                x: blockX,
                y: blockY,
                width: blockWidth,
                height: blockHeight,
                color: blockColor,
                destroyed: false,
                hits: hits,
                maxHits: hits,
                type: type,
                exploded: false, // Track if this lava block already exploded to prevent infinite loops
                treasureReward: isTreasureBrick ? calculateTreasureReward(hits) : null, // Progressive treasure rewards
                treasureOpening: false, // Animation state for treasure chest opening
                shieldStrength: isShieldBrick ? 8 : null, // Shield blocks start with 8 hits (degradation system)
                maxShieldStrength: isShieldBrick ? 8 : null, // For calculating damage percentage
                magneticPolarity: isMagneticBrick ? (type === 'magnetic_attract' ? 'attract' : 'repel') : null,
                magneticStrength: isMagneticBrick ? 150 : null, // Base magnetic force strength
                magneticRadius: isMagneticBrick ? 60 : null, // 60-pixel radius as specified
                
                // Store original position and grid coordinates for scaling
                originalPosition: { x: blockX, y: blockY },
                gridPosition: { col: col, row: row }
            };
        }

        // Enhanced lava block explosion system with advanced chain reactions (Enhanced for levels 60+)
        function explodeLavaBlock(centerBlock, explosionQueue = new Set(), chainDepth = 0) {
            if (explosionQueue.has(centerBlock)) return; // Prevent infinite loops
            explosionQueue.add(centerBlock);
            
            // Enhanced features for levels 60+
            const isEnhancedLevel = level >= 60;
            const baseDelay = isEnhancedLevel ? 150 : 50; // Longer delays for enhanced levels
            const variableDamage = isEnhancedLevel ? true : false; // Variable damage for enhanced levels
            
            // Find all blocks in the 8 surrounding positions
            const surroundingBlocks = blocks.filter(block => {
                if (block.destroyed || block === centerBlock) return false;
                
                // Check if block is in the 8 surrounding positions
                const deltaX = Math.abs(block.x - centerBlock.x);
                const deltaY = Math.abs(block.y - centerBlock.y);
                
                return deltaX <= blockWidth + blockPadding && 
                       deltaY <= blockHeight + blockPadding &&
                       (deltaX > 0 || deltaY > 0); // Exclude the center block itself
            });
            
            // Enhanced chain reaction visual effect for levels 60+
            if (isEnhancedLevel && chainDepth > 0) {
                // Create cascading explosion wave effect
                createExplosionWave(centerBlock.x + centerBlock.width / 2, centerBlock.y + centerBlock.height / 2, chainDepth);
                gameState.screenShake = Math.min(15, 5 + chainDepth * 2); // Increasing screen shake
            }
            
            // Damage surrounding blocks with enhanced staggered timing for visual spectacle
            surroundingBlocks.forEach((block, index) => {
                const delay = baseDelay + (index * (baseDelay / 3)); // More dramatic timing for enhanced levels
                
                setTimeout(() => {
                    if (!block.destroyed) {
                        // Variable damage system for enhanced levels (2-3 damage as specified)
                        let damage = 3;
                        if (variableDamage) {
                            damage = Math.random() < 0.5 ? 2 : 3; // Random 2-3 damage
                            
                            // Shield blocks take reduced damage from explosions
                            if (block.type === 'shield') {
                                // Check for shield overcharge event
                                if (isShieldOvercharged()) {
                                    // Shield is invulnerable during overcharge event
                                    damage = 0;
                                    
                                    // Visual feedback for overcharged shield
                                    gameState.feedbackMessages.push({
                                        text: "🛡 OVERCHARGED!",
                                        x: block.x + block.width / 2,
                                        y: block.y + block.height / 2,
                                        life: 60,
                                        color: '#00CED1',
                                        fontSize: 12,
                                        outline: true
                                    });
                                } else {
                                    damage = Math.ceil(damage * 0.7); // 30% damage reduction
                                    block.shieldStrength -= damage;
                                    if (block.shieldStrength <= 0) {
                                        block.hits = 0; // Trigger destruction
                                    }
                                }
                            } else {
                                block.hits -= damage;
                            }
                        } else {
                            block.hits -= damage;
                        }
                        
                        // Enhanced particle effects for levels 60+
                        const particleCount = isEnhancedLevel ? 12 + chainDepth * 2 : 8;
                        const particleColor = isEnhancedLevel ? getExplosionColor(chainDepth) : '#FF6500';
                        createParticles(block.x + block.width / 2, block.y + block.height / 2, particleColor, particleCount);
                        
                        // Only destroy if hits drop to 0 or below
                        if (block.hits <= 0) {
                            block.destroyed = true;
                            sessionStats.blocksDestroyed++;
                            
                            // Enhanced scoring for chain reactions
                            const chainBonus = isEnhancedLevel ? (1 + chainDepth * 0.5) : 1;
                            const basePoints = 15 * gameState.multiplier * chainBonus;
                            const comboMultiplier = Math.min(gameState.combo, 500);
                            const tempMultiplier = gameState.tempComboMultiplier || 1;
                            const points = Math.floor(basePoints * comboMultiplier * tempMultiplier);
                            updateScore(points);
                            
                            // Enhanced visual feedback for chain explosions
                            if (isEnhancedLevel && chainDepth > 0) {
                                createScorePopup(block.x + block.width / 2, block.y + block.height / 2, `CHAIN +${points}`, gameState.combo, getExplosionColor(chainDepth));
                            } else {
                                createScorePopup(block.x + block.width / 2, block.y + block.height / 2, points, gameState.combo);
                            }
                            
                            createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color, particleCount + 4);
                            
                            // Recursive chaining: explosives can trigger other explosives
                            if (block.type === 'lava') {
                                // Enhanced levels have recursive chaining with increasing chain depth
                                const nextChainDepth = isEnhancedLevel ? chainDepth + 1 : 0;
                                
                                // Phase 3: Track chain reaction depth for achievements
                                if (nextChainDepth > 0) {
                                    trackChainReaction(nextChainDepth);
                                }
                                
                                explodeLavaBlock(block, explosionQueue, nextChainDepth);
                            }
                            
                            // Play enhanced explosion sound effect
                            playSound('powerup'); // Use powerup sound for dramatic effect
                        } else {
                            // Block survived the damage - enhanced feedback
                            playSound('block');
                            const damageText = variableDamage ? `-${damage}` : '-3';
                            createScorePopup(block.x + block.width / 2, block.y + block.height / 2 - 15, damageText, 1);
                        }
                    }
                }, delay);
            });
        }
        
        // Enhanced explosion wave effect for levels 60+
        function createExplosionWave(centerX, centerY, chainDepth) {
            const waveRadius = 30 + chainDepth * 15;
            const waveColor = getExplosionColor(chainDepth);
            
            // Create expanding wave particles
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const particleX = centerX + Math.cos(angle) * waveRadius;
                const particleY = centerY + Math.sin(angle) * waveRadius;
                
                setTimeout(() => {
                    createParticles(particleX, particleY, waveColor, 3);
                }, i * 25); // Staggered wave effect
            }
        }
        
        // Get explosion color based on chain depth
        function getExplosionColor(chainDepth) {
            const colors = ['#FF6500', '#FF4500', '#FF0000', '#FF1493', '#8A2BE2', '#4B0082'];
            return colors[Math.min(chainDepth, colors.length - 1)];
        }

        async function resetGame() {
            console.log('RESET: Starting resetGame function');
            gameRunning = false;
            gamePaused = false;
            gameStarted = false;
            
            // Release pointer lock when resetting game
            if (pointerLocked && document.exitPointerLock) {
                document.exitPointerLock();
            }
            score = 0;
            lives = 3;
            level = 1;
            console.log('RESET: Basic variables set - lives:', lives, 'level:', level, 'score:', score);
            // Preserve logged-in user's name during reset
            if (typeof currentUser !== 'undefined' && currentUser && currentUser.username) {
                playerName = currentUser.username;
            } else {
                playerName = ''; // Reset player name to prompt again for anonymous users
            }
            scoreSubmitted = false; // Reset score submission flag
            scoreSubmissionInProgress = false; // Reset submission progress flag
            completionistRecorded = false; // Reset completionist record flag
            legitGameCompleted = false; // Reset legitimate game completion flag
            lastFrameTime = 0; // Reset frame timing for accurate delta calculation
            
            // Reset session tracking (but don't reinitialize during reset to avoid errors)
            gameSessionId = null;
            gameSessionToken = null;
            console.log('RESET: Session tracking cleared');
            sessionStats = {
                blocksDestroyed: 0,
                livesLost: 0,
                powerupsCollected: 0
            };
            
            // Reset mystical powers system
            mysticalPowers.mysticalEnergy = 0;
            mysticalPowers.activeEnchantments = [];
            mysticalPowers.selectedElement = 'normal';
            mysticalPowers.menuOpen = false;
            mysticalPowers.wasGameRunning = false;
            
            // Reset achievement gallery
            achievementGallery.galleryOpen = false;
            achievementGallery.wasGameRunning = false;
            
            // Reset upgrade shop
            upgradeShop.shopOpen = false;
            upgradeShop.wasGameRunning = false;
            mysticalPowers.unlockedElements = ['normal']; // Reset unlocked elements
            // Reset all elemental balls to locked except normal
            Object.keys(mysticalPowers.elementalBalls).forEach(element => {
                if (element !== 'normal') {
                    mysticalPowers.elementalBalls[element].unlocked = false;
                }
            });
            // Reset elemental effects
            mysticalPowers.elementalEffects.burningBlocks.clear();
            mysticalPowers.elementalEffects.frozenBlocks.clear();
            mysticalPowers.elementalEffects.chainTargets = [];
            mysticalPowers.elementalEffects.voidTears = [];
            // Reset world map system
            worldMapSystem.currentWorld = 1;
            worldMapSystem.currentZone = 1;
            worldMapSystem.unlockedWorlds = [1];
            worldMapSystem.worldProgress = {
                1: { completed: 0, total: 20, unlocked: true },
                2: { completed: 0, total: 20, unlocked: false },
                3: { completed: 0, total: 20, unlocked: false },
                4: { completed: 0, total: 20, unlocked: false },
                5: { completed: 0, total: 20, unlocked: false }
            };
            worldMapSystem.mapOpen = false;
            
            // Clear all game progress from localStorage
            localStorage.removeItem('mystical_progress');
            localStorage.removeItem('world_progress');
            localStorage.removeItem('player_profile');
            localStorage.removeItem('game_replays');
            localStorage.removeItem('speedrun_best_time');
            // Clear daily challenge completions (they use date-based keys)
            const today = new Date().toISOString().split('T')[0];
            localStorage.removeItem(`daily_challenge_${today}`);
            localStorage.removeItem(`daily_best_time_${today}`);
            // Note: keeping breakout-highscore and player_id as they're more persistent
            console.log('RESET: All game progress reset, localStorage cleared');
            
            // Secure session already initialized above
            
            if (!canvas) return;
            
            // Reset paddle
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.width = paddle.originalWidth;
            paddle.laser = false;
            paddle.sticky = false;
            paddle.powerUpTimer = 0;
            paddle.lastX = paddle.x; // Initialize lastX to prevent velocity glitch
            paddle.velocity = 0; // Reset velocity
            
            // Reset game state
            gameState.balls = [];
            gameState.powerUps = [];
            gameState.particles = [];
            gameState.feedbackMessages = [];
            gameState.scorePopups = [];
            gameState.screenShake = 0;
            gameState.multiplier = 1;
            gameState.combo = 0;
            // Reset temp combo multiplier
            gameState.tempComboMultiplier = 1;
            gameState.tempComboTimer = 0;
            gameState.tempComboDuration = 0;
            gameState.tempComboStartTime = 0;
            
            // Initialize first ball
            const firstBall = {
                x: canvas.width / 2,
                y: paddle.y - 20,
                radius: ballTemplate.radius,
                dx: 0,
                dy: 0,
                speed: 5, // Hard-coded to base speed - NO level increases
                launched: false,
                trail: []
            };
            console.log(`Game reset at level ${level}: Ball speed set to ${firstBall.speed} (base: 5)`);
            gameState.balls = [firstBall];
            
            // Reset blocks - force clear and regenerate
            blocks.length = 0; // Clear the blocks array completely
            console.log('Blocks cleared, count:', blocks.length);
            await initBlocks();
            console.log('Blocks regenerated, count:', blocks.length);
            console.log('Reset complete - Lives:', lives, 'Level:', level, 'Score:', score);
            
            // Update UI
            updateUI();
            
            // Clear any active overlays
            gameOverlay.active = false;
            removeOverlayKeyHandler();
            
            // Reset buttons
            if (pauseBtn) pauseBtn.disabled = true;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Ensure we show the start screen by drawing once and starting game loop
            draw();
            
            // Restart the game loop to show the start screen (not started, not running)
            if (!animationId) {
                gameLoop();
            }
            
            console.log('RESET: Function completed successfully!');
        }

        function startGame() {
            if (!gameStarted && canvas) {
                // Request pointer lock when starting game
                if (!pointerLocked && canvas.requestPointerLock) {
                    canvas.requestPointerLock();
                }
                
                // Prevent starting new game if player completed game but didn't use reset button
                if (legitGameCompleted) {
                    console.log("Game start blocked - use reset button to start new game");
                    return;
                }
                
                // Cancel any existing animation frames before starting
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                
                // Set player name - Default to Anonymous, allow override at end of game
                if (typeof currentUser !== 'undefined' && currentUser && currentUser.username) {
                    playerName = currentUser.username;
                } else {
                    // Default to Anonymous - player can change name at end of game
                    playerName = "Anonymous";
                }
                
                console.log("Player name set to:", playerName); // Debug log
                
                gameStarted = true;
                gameRunning = true;
                scoreSubmitted = false; // Ensure score can be submitted for this new game
                
                // Phase 4: Track game start for analytics
                if (analyticsSystem.active) {
                    trackGameStart();
                }
                
                // Apply all upgrade effects at game start
                applyAllUpgrades();
                
                // Phase 4: Apply challenge mode modifiers
                applyChallengeModeModifiers();
                
                // Phase 4: Initialize mystical powers system
                initializeMysticalPowers();
                
                // Phase 4: Initialize world map system
                initializeWorldMapSystem();
                
                // Phase 4: Apply world effects for current zone
                applyWorldEffects();
                
                // Phase 4: Initialize analytics system
                initializeAnalyticsSystem();
                
                // Phase 3: Initialize difficulty tracking for new game
                initializeDifficultyTracking();
                scoreSubmissionInProgress = false; // Reset submission progress for new game
                completionistRecorded = false; // Ensure completionist can be recorded for this new game
                lastFrameTime = 0; // Reset frame timing for accurate delta calculation
                if (pauseBtn) pauseBtn.disabled = false;
                gameLoop();
            }
        }

        function togglePause() {
            if (gameRunning) {
                gamePaused = !gamePaused;
                if (pauseBtn) pauseBtn.textContent = gamePaused ? 'Resume' : 'Pause';
                
                // Release pointer lock when pausing, re-acquire when resuming
                if (gamePaused && pointerLocked && document.exitPointerLock) {
                    document.exitPointerLock();
                } else if (!gamePaused && !pointerLocked && canvas.requestPointerLock) {
                    canvas.requestPointerLock();
                }
                
                if (gamePaused) {
                    // Show pause overlay
                    gameOverlay = {
                        active: true,
                        type: 'paused',
                        title: 'GAME PAUSED',
                        message: 'Press ESC, P, or SPACE to resume',
                        instruction: 'Click or press any key to continue'
                    };
                } else {
                    // Hide pause overlay - game loop will automatically resume
                    // since it continues running but only updates when not paused
                    gameOverlay.active = false;
                    // Don't call gameLoop() again - it's already running
                }
            }
        }

        // ============================
        // FULLSCREEN SCALING SYSTEM
        // ============================
        
        // Fullscreen state management
        let isFullscreen = false;
        let originalCanvasStyle = {};
        let originalCanvasDimensions = {};
        let originalGameDimensions = {};
        
        // Scaling infrastructure
        let gameScale = {
            x: 1,
            y: 1,
            uniform: 1,
            canvas: {
                original: { width: 800, height: 600 },
                current: { width: 800, height: 600 }
            }
        };
        
        // Game element dimensions (will scale proportionally)
        let baseDimensions = {
            blockWidth: 38,
            blockHeight: 20,
            blockPadding: 2,
            paddleWidth: 120,
            paddleHeight: 15,
            ballRadius: 8
        };
        
        // ============================
        // SCALING FUNCTIONS
        // ============================
        
        function calculateOptimalCanvasSize(targetWidth, targetHeight) {
            const originalAspectRatio = gameScale.canvas.original.width / gameScale.canvas.original.height;
            const targetAspectRatio = targetWidth / targetHeight;
            
            let optimalWidth, optimalHeight;
            
            if (targetAspectRatio > originalAspectRatio) {
                // Screen is wider than game - fit to height
                optimalHeight = targetHeight;
                optimalWidth = optimalHeight * originalAspectRatio;
            } else {
                // Screen is taller than game - fit to width
                optimalWidth = targetWidth;
                optimalHeight = optimalWidth / originalAspectRatio;
            }
            
            return {
                width: Math.floor(optimalWidth),
                height: Math.floor(optimalHeight),
                scaleX: optimalWidth / gameScale.canvas.original.width,
                scaleY: optimalHeight / gameScale.canvas.original.height
            };
        }
        
        function updateGameScale(canvasWidth, canvasHeight) {
            gameScale.canvas.current.width = canvasWidth;
            gameScale.canvas.current.height = canvasHeight;
            
            gameScale.x = canvasWidth / gameScale.canvas.original.width;
            gameScale.y = canvasHeight / gameScale.canvas.original.height;
            gameScale.uniform = Math.min(gameScale.x, gameScale.y);
            
            // Update scaled dimensions
            blockWidth = Math.floor(baseDimensions.blockWidth * gameScale.x);
            blockHeight = Math.floor(baseDimensions.blockHeight * gameScale.y);
            blockPadding = Math.floor(baseDimensions.blockPadding * gameScale.x);
            paddleWidth = Math.floor(baseDimensions.paddleWidth * gameScale.x);
            paddleHeight = Math.floor(baseDimensions.paddleHeight * gameScale.y);
            ballRadius = Math.floor(baseDimensions.ballRadius * gameScale.uniform);
            
            console.log(`Game scale updated: ${gameScale.x.toFixed(3)}x${gameScale.y.toFixed(3)} (uniform: ${gameScale.uniform.toFixed(3)})`);
        }
        
        function saveGameState() {
            if (!paddle || !gameState || !blocks) {
                console.log('Skipping save - game not fully initialized yet');
                return;
            }
            
            originalGameDimensions = {
                paddle: { x: paddle.x, y: paddle.y, width: paddle.width, height: paddle.height },
                balls: (gameState.balls || []).map(ball => ({ 
                    x: ball.x, 
                    y: ball.y, 
                    dx: ball.dx, 
                    dy: ball.dy,
                    radius: ball.radius 
                })),
                blocks: blocks.map(block => ({
                    x: block.x,
                    y: block.y,
                    width: block.width,
                    height: block.height
                }))
            };
        }
        
        function restoreGameState() {
            if (!originalGameDimensions.paddle) return;
            
            // Restore paddle with scaling
            paddle.x = originalGameDimensions.paddle.x * gameScale.x;
            paddle.y = originalGameDimensions.paddle.y * gameScale.y;
            paddle.width = paddleWidth;
            paddle.height = paddleHeight;
            
            // Restore balls with scaling
            if (gameState.balls) {
                gameState.balls.forEach((ball, index) => {
                    if (originalGameDimensions.balls[index]) {
                        const original = originalGameDimensions.balls[index];
                        ball.x = original.x * gameScale.x;
                        ball.y = original.y * gameScale.y;
                        ball.dx = original.dx * gameScale.x;
                        ball.dy = original.dy * gameScale.y;
                        ball.radius = ballRadius;
                    }
                });
            }
            
            // Restore blocks with scaling
            blocks.forEach((block, index) => {
                if (originalGameDimensions.blocks[index]) {
                    const original = originalGameDimensions.blocks[index];
                    block.x = original.x * gameScale.x;
                    block.y = original.y * gameScale.y;
                    block.width = blockWidth;
                    block.height = blockHeight;
                }
            });
        }
        
        function scaleGameElements() {
            // Scale paddle
            paddle.width = paddleWidth;
            paddle.height = paddleHeight;
            
            // Keep paddle centered horizontally and at bottom
            if (originalGameDimensions.paddle) {
                const relativeX = originalGameDimensions.paddle.x / gameScale.canvas.original.width;
                paddle.x = relativeX * canvas.width;
            } else {
                paddle.x = canvas.width / 2 - paddle.width / 2;
            }
            paddle.y = canvas.height - paddle.height - 20 * gameScale.y;
            
            // Scale balls
            gameState.balls.forEach((ball, index) => {
                ball.radius = ballRadius;
                // Preserve relative position if we have saved state
                if (originalGameDimensions.balls && originalGameDimensions.balls[index]) {
                    const originalBall = originalGameDimensions.balls[index];
                    ball.x = originalBall.x * gameScale.x;
                    ball.y = originalBall.y * gameScale.y;
                    ball.dx = originalBall.dx * gameScale.x;
                    ball.dy = originalBall.dy * gameScale.y;
                } else {
                    // Default positioning for new balls
                    ball.x = paddle.x + paddle.width / 2;
                    ball.y = paddle.y - ball.radius - 5;
                }
            });
            
            // Scale blocks using grid position
            blocks.forEach(block => {
                if (block.gridPosition) {
                    // Use stored grid position for accurate scaling
                    block.x = block.gridPosition.col * (blockWidth + blockPadding) + blockPadding;
                    block.y = block.gridPosition.row * (blockHeight + blockPadding) + 63 * gameScale.y;
                    block.width = blockWidth;
                    block.height = blockHeight;
                } else if (block.originalPosition) {
                    // Fallback: calculate from original position
                    const gridCol = Math.floor(block.originalPosition.x / (baseDimensions.blockWidth + baseDimensions.blockPadding));
                    const gridRow = Math.floor((block.originalPosition.y - 63) / (baseDimensions.blockHeight + baseDimensions.blockPadding));
                    
                    block.x = gridCol * (blockWidth + blockPadding) + blockPadding;
                    block.y = gridRow * (blockHeight + blockPadding) + 63 * gameScale.y;
                    block.width = blockWidth;
                    block.height = blockHeight;
                }
            });
        }
        
        function initializeGameElements() {
            // Initialize paddle dimensions and position
            paddle.width = paddleWidth;
            paddle.height = paddleHeight;
            paddle.originalWidth = paddleWidth;
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.y = canvas.height - paddle.height - 20;
            
            // Update ball template radius
            ballTemplate.radius = ballRadius;
            
            // Initialize any existing balls
            if (gameState && gameState.balls) {
                gameState.balls.forEach(ball => {
                    ball.radius = ballRadius;
                    if (!ball.launched) {
                        ball.x = paddle.x + paddle.width / 2;
                        ball.y = paddle.y - ball.radius - 5;
                    }
                });
            }
        }

        // Error display system
        function showError(message, duration = 5000) {
            // Remove any existing error messages
            const existingError = document.querySelector('.error-message');
            if (existingError) {
                existingError.remove();
            }
            
            // Create new error message element
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            
            // Add to document
            document.body.appendChild(errorDiv);
            
            // Auto-remove after duration
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.remove();
                }
            }, duration);
            
            // Allow manual dismissal by clicking
            errorDiv.addEventListener('click', () => {
                if (errorDiv.parentNode) {
                    errorDiv.remove();
                }
            });
        }

        async function toggleFullscreen() {
            // Secure context validation
            if (!window.isSecureContext) {
                showError('Fullscreen requires HTTPS. Please use a secure connection.');
                return;
            }
            
            // Canvas existence check
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                showError('Game canvas not found. Please refresh the page.');
                return;
            }
            
            try {
                if (!isFullscreen) {
                    await enterFullscreen();
                } else {
                    await exitFullscreen();
                }
            } catch (error) {
                console.error('Fullscreen toggle error:', error);
                showError('Fullscreen failed: ' + (error.message || 'Unknown error'));
            }
        }

        async function enterFullscreen() {
            console.log('Entering fullscreen mode...');
            
            // Canvas existence check
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                throw new Error('Game canvas not found');
            }
            
            // Secure context check
            if (!window.isSecureContext) {
                throw new Error('Fullscreen requires HTTPS connection');
            }
            
            try {
                // Save current game state before any changes
                saveGameState();
                
                // Setup fullscreen canvas with hybrid resizing
                setupHybridFullscreenCanvas();

                // Use the canvas element directly for fullscreen
                const targetElement = canvas || document.body;
                
                // Request fullscreen with proper browser compatibility and error handling
                let fullscreenPromise = null;
                if (targetElement.requestFullscreen) {
                    fullscreenPromise = targetElement.requestFullscreen();
                } else if (targetElement.webkitRequestFullscreen) {
                    fullscreenPromise = targetElement.webkitRequestFullscreen();
                } else if (targetElement.mozRequestFullScreen) {
                    fullscreenPromise = targetElement.mozRequestFullScreen();
                } else if (targetElement.msRequestFullscreen) {
                    fullscreenPromise = targetElement.msRequestFullscreen();
                } else {
                    console.log('Fullscreen API not supported, using canvas resize only');
                    return; // Still successful, just no browser fullscreen
                }
                
                // Handle fullscreen promise if it exists
                if (fullscreenPromise && fullscreenPromise.catch) {
                    await fullscreenPromise.catch(err => {
                        console.warn('Browser fullscreen request failed:', err.message);
                        // Don't throw - canvas is still resized for fullscreen effect
                    });
                }
            } catch (error) {
                console.error('Error in enterFullscreen:', error);
                // Clean up any partial state
                if (isFullscreen) {
                    await exitFullscreen().catch(cleanupError => {
                        console.error('Error during fullscreen cleanup:', cleanupError);
                    });
                }
                throw error;
            }
        }

        function setupHybridFullscreenCanvas() {
            isFullscreen = true;
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            if (fullscreenBtn) fullscreenBtn.textContent = '🚪 Exit Fullscreen';

            // Save original canvas dimensions and styles
            originalCanvasDimensions = {
                width: canvas.width,
                height: canvas.height
            };

            if (!originalCanvasStyle.position) {
                originalCanvasStyle = {
                    width: canvas.style.width,
                    height: canvas.style.height,
                    position: canvas.style.position,
                    top: canvas.style.top,
                    left: canvas.style.left,
                    zIndex: canvas.style.zIndex,
                    transform: canvas.style.transform
                };
            }

            // Get screen dimensions for fullscreen
            let screenWidth, screenHeight;
            try {
                if (window.parent && window.parent !== window) {
                    screenWidth = window.parent.screen.width || window.parent.innerWidth;
                    screenHeight = window.parent.screen.height || window.parent.innerHeight;
                    console.log('Using parent window dimensions:', screenWidth, 'x', screenHeight);
                } else {
                    screenWidth = window.innerWidth;
                    screenHeight = window.innerHeight;
                }
            } catch (e) {
                screenWidth = window.innerWidth;
                screenHeight = window.innerHeight;
                console.log('Fallback to current window dimensions');
            }

            // Calculate optimal display size maintaining 4:3 aspect ratio (800:600)
            const gameAspectRatio = 800 / 600; // 4:3 aspect ratio
            const screenAspectRatio = screenWidth / screenHeight;
            
            let displayWidth, displayHeight;
            
            if (screenAspectRatio > gameAspectRatio) {
                // Screen is wider - add black bars on sides
                displayHeight = screenHeight * 0.95;
                displayWidth = displayHeight * gameAspectRatio;
            } else {
                // Screen is taller - add black bars on top/bottom
                displayWidth = screenWidth * 0.95;
                displayHeight = displayWidth / gameAspectRatio;
            }

            // Keep internal canvas resolution at 800x600 for consistency
            canvas.width = 800;
            canvas.height = 600;

            // Update game scaling (should stay at 1.0 since we're keeping 800x600)
            updateGameScale(canvas.width, canvas.height);

            // Scale all game elements to fit new canvas
            scaleGameElements();

            // Position canvas in center of screen with CSS scaling
            canvas.style.position = 'fixed';
            canvas.style.top = '50%';
            canvas.style.left = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
            canvas.style.width = `${displayWidth}px`;
            canvas.style.height = `${displayHeight}px`;
            canvas.style.zIndex = '2147483647';
            canvas.style.background = '#000';
            canvas.style.margin = '0';
            canvas.style.padding = '0';
            canvas.style.border = 'none';
            canvas.style.outline = 'none';
            canvas.style.imageRendering = 'pixelated';
            canvas.style.imageRendering = 'crisp-edges';

            // Create black overlay with slightly different shade for boundaries
            const blackOverlay = document.createElement('div');
            blackOverlay.id = 'fullscreen-black-overlay';
            blackOverlay.style.position = 'fixed';
            blackOverlay.style.top = '0';
            blackOverlay.style.left = '0';
            blackOverlay.style.width = '100vw';
            blackOverlay.style.height = '100vh';
            blackOverlay.style.backgroundColor = '#0a0a0a'; // Slightly lighter than pure black for boundary visibility
            blackOverlay.style.zIndex = '2147483646';
            blackOverlay.style.margin = '0';
            blackOverlay.style.padding = '0';
            
            // Add left UI panel
            const leftUIPanel = document.createElement('div');
            leftUIPanel.id = 'fullscreen-left-ui';
            leftUIPanel.style.position = 'absolute';
            leftUIPanel.style.left = '10px';
            leftUIPanel.style.top = '20px';
            leftUIPanel.style.width = `${Math.max(200, (screenWidth - 800) / 2 - 20)}px`;
            leftUIPanel.style.height = 'calc(100vh - 40px)';
            leftUIPanel.style.color = '#fff';
            leftUIPanel.style.fontFamily = '"Press Start 2P", monospace';
            leftUIPanel.style.fontSize = '10px';
            leftUIPanel.style.lineHeight = '1.6';
            leftUIPanel.style.overflowY = 'auto';
            leftUIPanel.style.padding = '10px';
            leftUIPanel.innerHTML = `
                <div id="fs-level-display">Level: 1/100</div>
                <div id="fs-level-name">Starting Level</div>
                <div id="fs-lives-display" style="color: #FF6B6B;">♥ Lives: 3</div>
                <div id="fs-banking-display" style="display: none; color: #32CD32; margin-top: 10px;">
                    <div id="fs-banked-amount">💰 Banked: 0</div>
                    <div id="fs-interest-amount">📈 Interest: +0</div>
                    <div id="fs-banking-controls">B=Bank V=Withdraw</div>
                </div>
                <div id="fs-event-display" style="display: none; margin-top: 10px; color: #FFFF00;"></div>
                <div id="fs-mystical-display" style="display: none; margin-top: 10px; color: #9932CC;">
                    <div id="fs-mystical-energy-text">Energy: 100/100</div>
                    <div id="fs-mystical-energy-bar" style="background: #4B0082; height: 8px; border: 1px solid #9932CC; margin: 2px 0; position: relative;">
                        <div id="fs-mystical-energy-fill" style="background: #9932CC; height: 100%; width: 100%; transition: width 0.3s;"></div>
                    </div>
                    <div id="fs-mystical-element-text" style="font-size: 8px;"></div>
                </div>
                <div id="fs-world-display" style="display: none; margin-top: 10px;">
                    <div id="fs-world-name" style="font-size: 9px; font-weight: bold;"></div>
                    <div id="fs-world-zone" style="font-size: 8px;"></div>
                    <div id="fs-world-progress" style="font-size: 8px;"></div>
                </div>
            `;
            
            // Add right UI panel  
            const rightUIPanel = document.createElement('div');
            rightUIPanel.id = 'fullscreen-right-ui';
            rightUIPanel.style.position = 'absolute';
            rightUIPanel.style.right = '10px';
            rightUIPanel.style.top = '20px';
            rightUIPanel.style.width = `${Math.max(200, (screenWidth - 800) / 2 - 20)}px`;
            rightUIPanel.style.height = 'calc(100vh - 40px)';
            rightUIPanel.style.color = '#fff';
            rightUIPanel.style.fontFamily = '"Press Start 2P", monospace';
            rightUIPanel.style.fontSize = '10px';
            rightUIPanel.style.lineHeight = '1.6';
            rightUIPanel.style.textAlign = 'right';
            rightUIPanel.style.overflowY = 'auto';
            rightUIPanel.style.padding = '10px';
            rightUIPanel.innerHTML = `
                <div id="fs-score-display" style="color: #FFD700;">Score: 0</div>
                <div id="fs-combo-display" style="display: none; margin-top: 10px; color: #FF1493;"></div>
                <div id="fs-powerup-display" style="display: none; margin-top: 10px; color: #FF69B4;"></div>
                <div id="fs-boss-display" style="display: none; margin-top: 10px; color: #FF4500;"></div>
            `;
            
            blackOverlay.appendChild(leftUIPanel);
            blackOverlay.appendChild(rightUIPanel);
            
            document.body.appendChild(blackOverlay);

            // Hide UI elements except side panels
            try {
                const elementsToHide = document.querySelectorAll('.ui, .controls, .game-container > *:not(.game-layout), nav, header, .navigation-header');
                elementsToHide.forEach(el => {
                    if (el !== canvas && !el.classList.contains('game-layout')) {
                        el.style.display = 'none';
                    }
                });
                
                // Position side panels for fullscreen
                const leftPanel = document.getElementById('leftPanel');
                const rightPanel = document.getElementById('rightPanel');
                if (leftPanel) {
                    leftPanel.style.position = 'fixed';
                    leftPanel.style.left = '20px';
                    leftPanel.style.top = '20px';
                    leftPanel.style.zIndex = '999999';
                    leftPanel.style.width = '180px';
                    leftPanel.style.background = 'rgba(0, 0, 0, 0.9)';
                    leftPanel.style.border = '1px solid #444';
                    leftPanel.style.fontSize = '9px';
                    leftPanel.style.padding = '10px';
                }
                if (rightPanel) {
                    rightPanel.style.position = 'fixed';
                    rightPanel.style.right = '20px';
                    rightPanel.style.top = '20px';
                    rightPanel.style.zIndex = '999999';
                    rightPanel.style.width = '180px';
                    rightPanel.style.background = 'rgba(0, 0, 0, 0.9)';
                    rightPanel.style.border = '1px solid #444';
                    rightPanel.style.fontSize = '9px';
                    rightPanel.style.padding = '10px';
                }
            } catch (e) {
                console.log('Could not hide UI elements:', e);
            }

            // Force focus and prevent scrolling
            canvas.focus();
            document.body.style.overflow = 'hidden';
            document.documentElement.style.overflow = 'hidden';

            console.log(`Hybrid fullscreen setup complete: ${canvas.width}x${canvas.height} (scale: ${gameScale.x.toFixed(3)}x${gameScale.y.toFixed(3)})`);
        }

        async function exitFullscreen() {
            console.log('Exiting fullscreen mode...');
            
            // Defensive check for canvas existence
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.warn('Canvas not found during fullscreen exit');
                isFullscreen = false;
                return;
            }
            
            try {
                isFullscreen = false;
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                if (fullscreenBtn) fullscreenBtn.textContent = '📺 Fullscreen';

                // Exit browser fullscreen if active
                const exitFullscreenAPI = document.exitFullscreen || 
                                     document.webkitExitFullscreen || 
                                     document.mozCancelFullScreen || 
                                     document.msExitFullscreen;

                if (document.fullscreenElement || document.webkitFullscreenElement || 
                    document.mozFullScreenElement || document.msFullscreenElement) {
                    if (exitFullscreenAPI) {
                        try {
                            await exitFullscreenAPI.call(document);
                        } catch (err) {
                            console.warn('Browser fullscreen exit failed:', err.message);
                            // Continue with manual cleanup
                        }
                    }
                }

                // Restore original canvas dimensions
                if (originalCanvasDimensions && originalCanvasDimensions.width && originalCanvasDimensions.height) {
                    canvas.width = originalCanvasDimensions.width;
                    canvas.height = originalCanvasDimensions.height;
                } else {
                    // Fallback to default dimensions
                    canvas.width = 800;
                    canvas.height = 600;
                }

                // Reset game scale to original values
                updateGameScale(canvas.width, canvas.height);

                // Restore original canvas styles
                if (originalCanvasStyle && typeof originalCanvasStyle === 'object') {
                    Object.keys(originalCanvasStyle).forEach(prop => {
                        try {
                            canvas.style[prop] = originalCanvasStyle[prop] || '';
                        } catch (styleError) {
                            console.warn(`Error restoring canvas style ${prop}:`, styleError);
                        }
                    });
                }

                // Restore game elements to original positions and sizes
                try {
                    restoreGameState();
                } catch (restoreError) {
                    console.warn('Error restoring game state:', restoreError);
                }

                // Remove the black overlay
                const blackOverlay = document.getElementById('fullscreen-black-overlay');
                if (blackOverlay && blackOverlay.parentNode) {
                    blackOverlay.remove();
                }

                // Show the UI elements we hid and restore side panel positions
                try {
                    const elementsToShow = document.querySelectorAll('.ui, .controls, .game-container > *:not(.game-layout), nav, header, .navigation-header');
                    elementsToShow.forEach(el => {
                        if (el && el.style && el.style.display === 'none') {
                            el.style.display = '';
                        }
                    });
                    
                    // Restore side panels to normal positions
                    const leftPanel = document.getElementById('leftPanel');
                    const rightPanel = document.getElementById('rightPanel');
                    if (leftPanel) {
                        leftPanel.style.position = '';
                        leftPanel.style.left = '';
                        leftPanel.style.top = '';
                        leftPanel.style.zIndex = '';
                        leftPanel.style.width = '';
                        leftPanel.style.background = '';
                        leftPanel.style.border = '';
                        leftPanel.style.fontSize = '';
                        leftPanel.style.padding = '';
                    }
                    if (rightPanel) {
                        rightPanel.style.position = '';
                        rightPanel.style.right = '';
                        rightPanel.style.top = '';
                        rightPanel.style.zIndex = '';
                        rightPanel.style.width = '';
                        rightPanel.style.background = '';
                        rightPanel.style.border = '';
                        rightPanel.style.fontSize = '';
                        rightPanel.style.padding = '';
                    }
                } catch (e) {
                    console.warn('Could not restore UI elements:', e);
                }

                // Restore body styles
                try {
                    document.body.style.overflow = '';
                    document.documentElement.style.overflow = '';
                } catch (bodyStyleError) {
                    console.warn('Error restoring body styles:', bodyStyleError);
                }

                console.log(`Exited fullscreen mode: ${canvas.width}x${canvas.height} (scale: ${gameScale.x.toFixed(3)}x${gameScale.y.toFixed(3)})`);
            } catch (error) {
                console.error('Error in exitFullscreen:', error);
                // Force reset critical state even if there were errors
                isFullscreen = false;
                throw error;
            }
        }

        // Listen for fullscreen changes to update button state
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        // Also listen on parent document if in iframe
        try {
            if (window.parent && window.parent !== window) {
                window.parent.document.addEventListener('fullscreenchange', handleFullscreenChange);
                window.parent.document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                window.parent.document.addEventListener('mozfullscreenchange', handleFullscreenChange);
                window.parent.document.addEventListener('MSFullscreenChange', handleFullscreenChange);
                console.log('Added fullscreen listeners to parent document');
            }
        } catch (e) {
            console.log('Could not add parent fullscreen listeners due to cross-origin');
        }

        async function handleFullscreenChange() {
            let isInFullscreen = false;
            
            // Check both current document and parent document
            try {
                isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                                  document.mozFullScreenElement || document.msFullscreenElement);
                
                if (!isInFullscreen && window.parent && window.parent !== window) {
                    // Also check parent document
                    const parentDoc = window.parent.document;
                    isInFullscreen = !!(parentDoc.fullscreenElement || parentDoc.webkitFullscreenElement || 
                                      parentDoc.mozFullScreenElement || parentDoc.msFullscreenElement);
                }
            } catch (e) {
                // Fallback to current document only
                isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                                  document.mozFullScreenElement || document.msFullscreenElement);
            }
            
            if (!isInFullscreen && isFullscreen) {
                // User exited fullscreen via ESC key or browser controls
                try {
                    await exitFullscreen();
                } catch (error) {
                    console.error('Error handling fullscreen change:', error);
                    showError('Error exiting fullscreen: ' + (error.message || 'Unknown error'));
                }
            }
        }

        // Allow ESC key to exit fullscreen
        document.addEventListener('keydown', async function(e) {
            if (e.key === 'Escape' && isFullscreen) {
                try {
                    await exitFullscreen();
                } catch (error) {
                    console.error('Error with ESC key fullscreen exit:', error);
                    showError('Error exiting fullscreen: ' + (error.message || 'Unknown error'));
                }
            }
        });

        function launchBall(ball) {
            if (!ball) return;
            ball.launched = true;
            
            // Safety check: ensure ball has minimum speed
            if (!ball.speed || ball.speed <= 0) {
                console.warn('Ball speed was invalid:', ball.speed, 'setting to default 5');
                ball.speed = 5;
            }
            
            // Check for active element override enchantments when launching
            if (mysticalPowers.active) {
                const elementOverride = mysticalPowers.activeEnchantments.find(
                    e => e.effects && e.effects.elementOverride
                );
                if (elementOverride) {
                    const element = elementOverride.effects.elementOverride;
                    ball.element = element;
                    if (element !== 'normal' && mysticalPowers.elementalBalls[element]) {
                        const elementData = mysticalPowers.elementalBalls[element];
                        ball.color = elementData.color;
                        ball.trailColor = elementData.trailColor;
                        
                        // Set up elemental effects
                        ball.elementalEffects = {};
                        if (element === 'lightning') {
                            ball.elementalEffects.chainRange = elementData.effects.chainRange;
                            ball.elementalEffects.maxChains = elementData.effects.maxChains;
                        }
                    }
                }
            }
            
            // If ball was stuck to paddle, launch from its contact point with proper angle
            if (ball.stuckToPaddle && ball.stickOffset !== undefined) {
                // Calculate launch angle based on paddle velocity and contact point (like game start)
                const paddleVel = paddle.velocity || 0;
                const maxPaddleInfluence = 3; // Max additional speed from paddle movement
                const paddleInfluence = Math.max(-maxPaddleInfluence, Math.min(maxPaddleInfluence, paddleVel * 0.3));
                
                // Calculate launch angle based on contact point (same as bounce calculation)
                const hitPos = ball.stickOffset / paddle.width;
                const bounceAngle = (hitPos - 0.5) * Math.PI / 2.2; // Same steeper angle as bounce
                
                // Apply base speed with paddle influence
                const baseSpeedX = Math.sin(bounceAngle) * ball.speed;
                const baseSpeedY = -Math.cos(bounceAngle) * ball.speed;
                
                ball.dx = baseSpeedX + paddleInfluence;
                ball.dy = baseSpeedY;
                
                // Ensure minimum upward velocity to prevent horizontal-only launches
                if (Math.abs(ball.dy) < ball.speed * 0.3) {
                    ball.dy = -ball.speed * 0.3;
                }
                
                // Apply pending speed multiplier if any (from speedball powerups collected while stuck)
                if (ball.pendingSpeedMultiplier && ball.pendingSpeedMultiplier > 1) {
                    ball.dx *= ball.pendingSpeedMultiplier;
                    ball.dy *= ball.pendingSpeedMultiplier;
                    ball.pendingSpeedMultiplier = undefined; // Clear after applying
                }
            } else {
                // Default launch with paddle influence (like game start)
                const paddleVel = paddle.velocity || 0;
                const maxPaddleInfluence = 3; // Max additional speed from paddle movement
                const paddleInfluence = Math.max(-maxPaddleInfluence, Math.min(maxPaddleInfluence, paddleVel * 0.3));
                
                // Default launch for unlaunched balls (slight randomness)
                const angle = (Math.random() - 0.5) * Math.PI / 4; // Random angle between -45 and 45 degrees
                const baseSpeedX = Math.sin(angle) * ball.speed;
                const baseSpeedY = -Math.cos(angle) * ball.speed;
                
                ball.dx = baseSpeedX + paddleInfluence;
                ball.dy = baseSpeedY;
                
                // Apply pending speed multiplier if any (from speedball powerups collected while stuck)
                if (ball.pendingSpeedMultiplier && ball.pendingSpeedMultiplier > 1) {
                    ball.dx *= ball.pendingSpeedMultiplier;
                    ball.dy *= ball.pendingSpeedMultiplier;
                    ball.pendingSpeedMultiplier = undefined; // Clear after applying
                }
            }
            
            // Debug logging for ball launch
            const launchSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
            console.log(`Ball launched at level ${level}: dx=${ball.dx.toFixed(2)}, dy=${ball.dy.toFixed(2)}, speed=${launchSpeed.toFixed(2)}, base speed=${ball.speed}`);
            
            ball.trail = []; // Clear any existing trail when launching
        }
        
        function launchNextBall() {
            // Launch balls sequentially: first any unlaunched balls, then stuck balls in order
            let ballLaunched = false;
            
            // First priority: launch any unlaunched balls (game start)
            for (let ball of gameState.balls) {
                if (!ball.launched && !ball.stuckToPaddle) {
                    launchBall(ball);
                    ballLaunched = true;
                    break; // Only launch one at a time
                }
            }
            
            // Second priority: launch stuck balls in sequential order
            if (!ballLaunched) {
                const stuckBalls = gameState.balls
                    .filter(ball => ball.stuckToPaddle)
                    .sort((a, b) => (a.stickOrder || 0) - (b.stickOrder || 0));
                
                if (stuckBalls.length > 0) {
                    const nextBall = stuckBalls[0];
                    launchBall(nextBall);
                    nextBall.stuckToPaddle = false;
                    nextBall.stickOrder = undefined;
                    nextBall.stickOffset = undefined; // Clear the contact point
                    ballLaunched = true;
                }
            }
            
            return ballLaunched;
        }

        function fireLaser() {
            if (!paddle.laser) return;
            
            // Create laser beams with dynamic positioning
            let laserPositions = [];
            if (Math.abs(paddle.width - paddle.originalWidth) < 1) {
                // Default size - use original 25% and 75% positions
                laserPositions = [
                    paddle.x + paddle.width * 0.25,
                    paddle.x + paddle.width * 0.75
                ];
            } else {
                // Non-default size - position near edges
                laserPositions = [
                    paddle.x + 12,  // 12px from left edge
                    paddle.x + paddle.width - 12  // 12px from right edge
                ];
            }
            
            for (let i = 0; i < 2; i++) {
                gameState.powerUps.push({
                    x: laserPositions[i],
                    y: paddle.y,
                    type: 'laser_beam',
                    color: '#FFD700',
                    symbol: '|',
                    dy: -8,
                    isLaser: true
                });
            }
        }

        function updatePaddle(deltaMultiplier = 1) {
            // Store previous position for velocity calculation
            const prevX = paddle.x;
            let keyboardControl = false;
            
            // Keyboard controls - always take priority
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                paddle.x -= paddle.speed * deltaMultiplier;
                keyboardControl = true;
                // Clear mouse position when using keyboard to prevent snap-back
                mouseX = 0;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D'] || keys['w'] || keys['W']) {
                paddle.x += paddle.speed * deltaMultiplier;
                keyboardControl = true;
                // Clear mouse position when using keyboard to prevent snap-back
                mouseX = 0;
            }
            
            // Mouse/touch controls - only when no keyboard input
            if (!keyboardControl) {
                if (mouseX > 0) {
                    paddle.x = mouseX - paddle.width / 2;
                }
                if (touchX > 0) {
                    paddle.x = touchX - paddle.width / 2;
                }
            }
            
            // Keep paddle within bounds
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }
            
            // Calculate paddle velocity (current position - previous position)
            const rawVelocity = paddle.x - prevX;
            
            // Limit velocity to maximum achievable with arrow keys (paddle.speed)
            // This prevents mouse users from getting unfair advantage
            paddle.velocity = Math.max(-paddle.speed, Math.min(paddle.speed, rawVelocity));
            
            // Store current position for next frame
            paddle.lastX = paddle.x;
            
            // Update power-up timers
            if (paddle.powerUpTimer > 0) {
                paddle.powerUpTimer--;
                if (paddle.powerUpTimer <= 0) {
                    // When power-ups expire, reset paddle to original state
                    paddleSizeLevel = 0; // Reset size level to default
                    paddle.width = paddle.originalWidth;
                    paddle.laser = false;
                    
                    // CRITICAL FIX: Release all stuck balls before disabling sticky paddle
                    if (paddle.sticky) {
                        gameState.balls.forEach(ball => {
                            if (ball.stuckToPaddle) {
                                // Launch ball with proper trajectory based on contact point
                                ball.launched = true;
                                ball.stuckToPaddle = false;
                                
                                // Calculate launch angle based on contact point (same as launchBall function)
                                if (ball.stickOffset !== undefined) {
                                    const hitPos = ball.stickOffset / paddle.width;
                                    const bounceAngle = (hitPos - 0.5) * Math.PI / 2.2; // Same steeper angle as bounce
                                    
                                    ball.dx = Math.sin(bounceAngle) * ball.speed;
                                    ball.dy = -Math.cos(bounceAngle) * ball.speed;
                                    
                                    // Ensure minimum upward velocity to prevent horizontal-only launches
                                    if (Math.abs(ball.dy) < ball.speed * 0.3) {
                                        ball.dy = -ball.speed * 0.3;
                                    }
                                    
                                    // Apply pending speed multiplier if any (from speedball powerups collected while stuck)
                                    if (ball.pendingSpeedMultiplier && ball.pendingSpeedMultiplier > 1) {
                                        ball.dx *= ball.pendingSpeedMultiplier;
                                        ball.dy *= ball.pendingSpeedMultiplier;
                                        ball.pendingSpeedMultiplier = undefined; // Clear after applying
                                    }
                                } else {
                                    // Default launch with slight randomness if no contact point
                                    const angle = (Math.random() - 0.5) * Math.PI / 4; // Random angle between -45 and 45 degrees
                                    ball.dx = Math.sin(angle) * ball.speed;
                                    ball.dy = -Math.cos(angle) * ball.speed;
                                    
                                    // Apply pending speed multiplier if any (from speedball powerups collected while stuck)
                                    if (ball.pendingSpeedMultiplier && ball.pendingSpeedMultiplier > 1) {
                                        ball.dx *= ball.pendingSpeedMultiplier;
                                        ball.dy *= ball.pendingSpeedMultiplier;
                                        ball.pendingSpeedMultiplier = undefined; // Clear after applying
                                    }
                                }
                                
                                // Clean up sticky-related properties
                                ball.stickOrder = undefined;
                                ball.stickOffset = undefined;
                                ball.trail = []; // Clear trail to prevent ghost trails
                            }
                        });
                    }
                    
                    paddle.sticky = false;
                }
            }
            
            // Move unlaunched balls and balls stuck to paddle
            gameState.balls.forEach(ball => {
                if (!ball.launched) {
                    // Unlaunched balls stay centered
                    ball.x = paddle.x + paddle.width / 2;
                    ball.y = paddle.y - ball.radius;
                } else if (ball.stuckToPaddle) {
                    // Stuck balls maintain their contact point
                    ball.x = paddle.x + (ball.stickOffset || paddle.width / 2);
                    ball.y = paddle.y - ball.radius;
                    // Clamp to paddle bounds
                    ball.x = Math.max(paddle.x + ball.radius, Math.min(paddle.x + paddle.width - ball.radius, ball.x));
                }
            });
        }

        // Apply magnetic field physics to balls
        function applyMagneticFields(ball, deltaMultiplier) {
            // Find all magnetic blocks that aren't destroyed
            const magneticBlocks = blocks.filter(block => 
                !block.destroyed && 
                (block.type === 'magnetic_attract' || block.type === 'magnetic_repel')
            );
            
            magneticBlocks.forEach(magneticBlock => {
                // Calculate distance from ball to magnetic block center
                const blockCenterX = magneticBlock.x + magneticBlock.width / 2;
                const blockCenterY = magneticBlock.y + magneticBlock.height / 2;
                const deltaX = ball.x - blockCenterX;
                const deltaY = ball.y - blockCenterY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Only apply magnetic force within the specified radius
                if (distance < magneticBlock.magneticRadius && distance > 0) {
                    // Normalize the direction vector
                    const directionX = deltaX / distance;
                    const directionY = deltaY / distance;
                    
                    // Calculate magnetic force (stronger when closer, weaker when farther)
                    const forceMultiplier = (magneticBlock.magneticRadius - distance) / magneticBlock.magneticRadius;
                    const magneticForce = magneticBlock.magneticStrength * forceMultiplier * deltaMultiplier * 0.001; // Scale down for reasonable effect
                    
                    // Apply force based on polarity
                    if (magneticBlock.magneticPolarity === 'attract') {
                        // Attract: pull ball towards magnetic block
                        ball.dx -= directionX * magneticForce;
                        ball.dy -= directionY * magneticForce;
                    } else {
                        // Repel: push ball away from magnetic block
                        ball.dx += directionX * magneticForce;
                        ball.dy += directionY * magneticForce;
                    }
                    
                    // Limit maximum velocity to prevent balls from going too crazy
                    const maxVelocity = ball.speed * 3; // Allow up to 3x normal speed
                    const currentVelocity = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    if (currentVelocity > maxVelocity) {
                        const velocityScale = maxVelocity / currentVelocity;
                        ball.dx *= velocityScale;
                        ball.dy *= velocityScale;
                    }
                }
            });
        }

        function updateBalls(deltaMultiplier = 1) {
            gameState.balls = gameState.balls.filter(ball => {
                if (!ball.launched) return true;
                
                // Debug logging for ball velocity
                if (Math.random() < 0.01) { // Log occasionally to avoid spam
                    const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    console.log(`Level ${level}: Ball velocity dx=${ball.dx.toFixed(2)}, dy=${ball.dy.toFixed(2)}, speed=${currentSpeed.toFixed(2)}, base speed=${ball.speed}`);
                }
                
                // Update ball position with frame-rate independent physics (2.4x speed for 144 FPS feel)
                // Apply slow effect only when slow powerup is active
                let ballSpeedMultiplier = ball.slow ? (SPEED_MULTIPLIER * 0.5) : SPEED_MULTIPLIER;
                
                // Apply temporary event speed multiplier
                const eventSpeedMultiplier = getActiveSpeedMultiplier();
                ballSpeedMultiplier *= eventSpeedMultiplier;
                
                ball.x += ball.dx * deltaMultiplier * ballSpeedMultiplier;
                ball.y += ball.dy * deltaMultiplier * ballSpeedMultiplier;
                
                // Apply magnetic field effects from magnetic blocks
                applyMagneticFields(ball, deltaMultiplier);
                
                // Apply homing ball upgrade
                const homingLevel = getUpgradeEffect('ball_homing');
                if (homingLevel > 0 && ball.launched) {
                    applyHomingEffect(ball, homingLevel * 0.5, deltaMultiplier);
                }
                
                // Update ball trail
                ball.trail.push({ x: ball.x, y: ball.y });
                if (ball.trail.length > 5) ball.trail.shift();
                
                // Update mega ball timer (time-based, frame-rate independent)
                if (ball.mega && ball.megaStartTime) {
                    const elapsedTime = Date.now() - ball.megaStartTime;
                    if (elapsedTime >= ball.megaDuration) {
                        ball.mega = false;
                        ball.megaStartTime = undefined;
                        ball.megaDuration = undefined;
                    }
                }
                
                // Update rocket ball timer (time-based, frame-rate independent)
                if (ball.rocket && ball.rocketStartTime) {
                    const elapsedTime = Date.now() - ball.rocketStartTime;
                    if (elapsedTime >= ball.rocketDuration) {
                        ball.rocket = false;
                        ball.rocketStartTime = undefined;
                        ball.rocketDuration = undefined;
                    }
                }
                
                // Update slow ball timer (time-based, frame-rate independent)
                if (ball.slow && ball.slowStartTime) {
                    const elapsedTime = Date.now() - ball.slowStartTime;
                    if (elapsedTime >= ball.slowDuration) {
                        ball.slow = false;
                        ball.slowStartTime = undefined;
                        ball.slowDuration = undefined;
                        // Restore original speed
                        if (ball.originalSpeed) {
                            ball.speed = ball.originalSpeed;
                            const length = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                            ball.dx = (ball.dx / length) * ball.speed;
                            ball.dy = (ball.dy / length) * ball.speed;
                            ball.originalSpeed = undefined;
                        }
                    }
                }
                
                // Update speed ball timer (mirroring slow ball behavior)
                if (ball.speedUp && ball.speedUpStartTime) {
                    const elapsedTime = Date.now() - ball.speedUpStartTime;
                    if (elapsedTime >= ball.speedUpDuration) {
                        ball.speedUp = false;
                        ball.speedUpStartTime = undefined;
                        ball.speedUpDuration = undefined;
                        // Restore original speed
                        if (ball.originalSpeedForSpeedUp) {
                            ball.speed = ball.originalSpeedForSpeedUp;
                            const length = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                            if (length > 0) {
                                ball.dx = (ball.dx / length) * ball.speed;
                                ball.dy = (ball.dy / length) * ball.speed;
                            }
                            ball.originalSpeedForSpeedUp = undefined;
                        }
                    }
                }
                
                // Wall collisions with proper positioning to prevent getting stuck
                if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius; // Push ball back inside boundary
                    ball.dx = -Math.abs(ball.dx); // Ensure ball moves left
                    playSound('paddle');
                } else if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius; // Push ball back inside boundary
                    ball.dx = Math.abs(ball.dx); // Ensure ball moves right
                    playSound('paddle');
                }
                
                if (ball.y - ball.radius < 0) {
                    ball.y = ball.radius; // Push ball back inside boundary
                    ball.dy = Math.abs(ball.dy); // Ensure ball moves down
                    playSound('paddle');
                }
                
                // Enhanced paddle collision detection with better edge case handling
                if (ball.y + ball.radius >= paddle.y &&
                    ball.y - ball.radius < paddle.y + paddle.height &&
                    ball.x + ball.radius > paddle.x &&
                    ball.x - ball.radius < paddle.x + paddle.width &&
                    ball.dy > 0) {
                    
                    // Ensure ball is properly positioned above paddle
                    ball.y = paddle.y - ball.radius;
                    
                    // Prevent ball from getting stuck inside paddle
                    if (ball.y + ball.radius > paddle.y) {
                        ball.y = paddle.y - ball.radius;
                    }
                    
                    playSound('paddle');
                    
                    // Phase 3: Track successful paddle hit for difficulty adjustment
                    updateDifficultyMetrics(true);
                    
                    if (paddle.sticky && ball.launched && !ball.stuckToPaddle) {
                        // Only stick balls that are moving downward to prevent re-sticking during multiball release
                        if (ball.dy > 0) {
                            ball.stuckToPaddle = true; // Mark as stuck to paddle FIRST
                            ball.launched = false;      // Then set launched to false
                            ball.dx = 0;
                            ball.dy = 0;
                            ball.trail = []; // Clear trail when ball gets stuck to prevent ghost trails
                        
                        // Store the contact point relative to paddle for consistent positioning
                        ball.stickOffset = ball.x - paddle.x;
                        
                        // Clamp stick offset to prevent balls from appearing outside paddle bounds
                        ball.stickOffset = Math.max(ball.radius, Math.min(paddle.width - ball.radius, ball.stickOffset));
                        
                            // Assign a stick order number for sequential release
                            const maxStickOrder = Math.max(0, ...gameState.balls.filter(b => b.stuckToPaddle).map(b => b.stickOrder || 0));
                            ball.stickOrder = maxStickOrder + 1;
                        }
                        return true;
                    }
                    
                    // Calculate bounce angle based on where ball hits paddle (normalized positioning)
                    const hitPos = Math.max(0, Math.min(1, (ball.x - paddle.x) / paddle.width));
                    const bounceAngle = (hitPos - 0.5) * Math.PI / 2.2; // Consistent angle calculation
                    
                    // Base velocity from angle - normalized for consistency
                    const baseDx = Math.sin(bounceAngle) * ball.speed;
                    const baseDy = -Math.cos(bounceAngle) * ball.speed;
                    
                    // Enhanced "english" rules - paddle velocity affects ball speed up to speedball powerup level
                    const isReturningBall = ball.dy > 0;
                    const paddleVelocity = Math.abs(paddle.velocity || 0);
                    
                    // Scale velocity transfer based on paddle speed (faster paddle = more influence)
                    const velocityTransferX = isReturningBall ? paddle.velocity * 0.2 : 0; // Horizontal influence
                    const speedBonus = isReturningBall ? Math.min(paddleVelocity * 0.8, ball.speed * 0.3) : 0; // Speed boost from fast paddle movement
                    
                    ball.dx = baseDx + velocityTransferX;
                    ball.dy = baseDy;
                    
                    // Apply speed bonus by scaling the entire velocity vector
                    if (speedBonus > 0) {
                        const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        const targetSpeed = Math.min(currentSpeed + speedBonus, ball.speed * 1.3); // Cap at speedball powerup level (30% increase)
                        
                        if (currentSpeed > 0) {
                            const scale = targetSpeed / currentSpeed;
                            ball.dx *= scale;
                            ball.dy *= scale;
                        }
                    } else {
                        // Normal speed normalization when no speed bonus
                        const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        const targetSpeed = ball.speed * 1.1; // Normal max speed
                        
                        if (currentSpeed > targetSpeed) {
                            const scale = targetSpeed / currentSpeed;
                            ball.dx *= scale;
                            ball.dy *= scale;
                        } else if (currentSpeed < ball.speed * 0.8) {
                            // Ensure minimum speed to prevent slow balls
                            const scale = (ball.speed * 0.8) / currentSpeed;
                            ball.dx *= scale;
                            ball.dy *= scale;
                        }
                    }
                    
                    // Ensure consistent minimum vertical speed
                    const minVerticalSpeed = ball.speed * 0.4;
                    if (Math.abs(ball.dy) < minVerticalSpeed) {
                        ball.dy = ball.dy < 0 ? -minVerticalSpeed : minVerticalSpeed;
                        // Recalculate dx to maintain target speed
                        const remainingSpeed = Math.sqrt(Math.max(0, (ball.speed * ball.speed) - (ball.dy * ball.dy)));
                        ball.dx = ball.dx >= 0 ? remainingSpeed : -remainingSpeed;
                    }
                }
                
                // Strict boundary enforcement - prevent balls from going below paddle level
                if (ball.y + ball.radius > paddle.y + paddle.height + 5) {
                    // Phase 3: Track missed ball for difficulty adjustment
                    updateDifficultyMetrics(false);
                    
                    // Clear the trail before removing the ball
                    ball.trail = [];
                    return false; // Remove this ball
                }
                
                // Additional safety check - if ball somehow gets far below screen
                if (ball.y > canvas.height + ball.radius) {
                    ball.trail = [];
                    return false;
                }
                
                return true; // Keep this ball
            });
            
            // Check if all balls are gone
            if (gameState.balls.length === 0 && gameRunning) {
                lives--;
                sessionStats.livesLost++;
                console.log(`Lives decremented to: ${lives}`);
                
                // Phase 4: Track ball loss for challenge modes
                onBallLost();
                
                // Phase 3: Risk/reward - lose all unbanked progress and some banked score on death
                const unbankedLoss = score;
                if (unbankedLoss > 0) {
                    score = 0; // Lose all unbanked progress
                    
                    // Visual feedback for unbanked loss
                    gameState.feedbackMessages.push({
                        text: `💸 Lost ${unbankedLoss.toLocaleString()} unbanked points!`,
                        x: canvas.width / 2,
                        y: canvas.height / 2 + 20,
                        life: 240,
                        color: '#FFA500',
                        fontSize: 14,
                        outline: true
                    });
                }
                
                // Lose 25% of banked score as penalty (risk/reward)
                if (scoreBanking.bankedScore > 0) {
                    const bankingPenalty = Math.floor(scoreBanking.bankedScore * 0.25);
                    scoreBanking.bankedScore -= bankingPenalty;
                    
                    // Visual feedback for banking loss
                    gameState.feedbackMessages.push({
                        text: `💀 Lost ${bankingPenalty.toLocaleString()} banked points!`,
                        x: canvas.width / 2,
                        y: canvas.height / 2 + 50,
                        life: 240,
                        color: '#FF4444',
                        fontSize: 14,
                        outline: true
                    });
                    
                    console.log(`Banking penalty: Lost ${bankingPenalty} banked points. Remaining: ${scoreBanking.bankedScore}`);
                }
                
                updateUI();
                
                if (lives <= 0) {
                    console.log('Calling gameOver() - no lives left');
                    gameOver();
                } else {
                    console.log('Resetting balls for next life');
                    resetBalls();
                }
            }
        }

        function checkBlockCollisions() {
            gameState.balls.forEach(ball => {
                if (!ball.launched) return;
                
                for (let block of blocks) {
                    if (block.destroyed) continue;
                    
                    if (ball.x + ball.radius > block.x &&
                        ball.x - ball.radius < block.x + block.width &&
                        ball.y + ball.radius > block.y &&
                        ball.y - ball.radius < block.y + block.height) {
                        
                        // Check if this is a metal or void brick - special collision handling
                        const isMetalBrick = block.type === 'metal';
                        const isVoidBrick = block.type === 'void';
                        
                        if ((isMetalBrick && !ball.rocket && !ball.mega) || isVoidBrick) {
                            // Metal/Void brick - special handling (void is always indestructible)
                            const ballCenterX = ball.x;
                            const ballCenterY = ball.y;
                            const blockCenterX = block.x + block.width / 2;
                            const blockCenterY = block.y + block.height / 2;
                            
                            const deltaX = ballCenterX - blockCenterX;
                            const deltaY = ballCenterY - blockCenterY;
                            
                            // Determine collision side and bounce
                            if (Math.abs(deltaX / block.width) > Math.abs(deltaY / block.height)) {
                                ball.dx = -ball.dx; // Hit left or right side
                            } else {
                                ball.dy = -ball.dy; // Hit top or bottom
                            }
                            
                            // Different behavior for metal vs void blocks
                            if (isVoidBrick) {
                                // Void blocks never spawn powerups and have dark particles
                                createParticles(blockCenterX, blockCenterY, '#4A148C', 8); // Dark purple particles
                            } else if (isMetalBrick) {
                                // Metal blocks have a much higher chance of spawning powerups (80%)
                                if (Math.random() < 0.8) {
                                    spawnPowerUp(blockCenterX, blockCenterY, true);
                                    // Create visual feedback for powerup spawn from metal block
                                    createParticles(blockCenterX, blockCenterY, '#FFD700', 10); // Gold particles
                                } else {
                                    // Even if no powerup, still create some visual feedback
                                    createParticles(blockCenterX, blockCenterY, '#CCCCCC', 5); // Silver particles
                                }
                            }
                            
                            // Metal blocks create a bigger screen shake
                            playSound('block');
                            gameState.screenShake = 5;
                            break;
                        }
                        
                        // Rocket ball destroys block instantly but doesn't deflect (except metal bricks)
                        if (ball.rocket) {
                            // Shield blocks resist rocket balls - take 3 damage instead of instant destruction
                            if (block.type === 'shield') {
                                // Check for shield overcharge event
                                if (isShieldOvercharged()) {
                                    // Shield is invulnerable during overcharge event
                                    createScorePopup(block.x + block.width / 2, block.y + block.height / 2 - 10, "🛡 OVERCHARGED!", 1, '#00CED1');
                                    createParticles(block.x + block.width / 2, block.y + block.height / 2, '#00CED1', 8);
                                } else {
                                    block.shieldStrength -= 3;
                                }
                                
                                if (block.shieldStrength <= 0) {
                                    block.destroyed = true;
                                    sessionStats.blocksDestroyed++;
                                } else {
                                    // Shield survived rocket impact - show damage feedback
                                    createScorePopup(block.x + block.width / 2, block.y + block.height / 2 - 10, `-3 SHIELD`, 1, '#4169E1');
                                    createParticles(block.x + block.width / 2, block.y + block.height / 2, '#4169E1', 6);
                                    playSound('block');
                                    
                                    // Deflect rocket ball from surviving shield
                                    const ballCenterX = ball.x;
                                    const ballCenterY = ball.y;
                                    const blockCenterX = block.x + block.width / 2;
                                    const blockCenterY = block.y + block.height / 2;
                                    
                                    const deltaX = ballCenterX - blockCenterX;
                                    const deltaY = ballCenterY - blockCenterY;
                                    
                                    if (Math.abs(deltaX / block.width) > Math.abs(deltaY / block.height)) {
                                        ball.dx = -ball.dx;
                                    } else {
                                        ball.dy = -ball.dy;
                                    }
                                    continue; // Skip normal destruction logic
                                }
                            } else {
                                block.destroyed = true;
                                sessionStats.blocksDestroyed++;
                            }
                            
                            // Special treasure chest handling for rocket balls
                            if (block.type === 'treasure') {
                                // Trigger opening animation
                                block.treasureOpening = true;
                                
                                // Phase 3: Track treasure opened for achievements
                                trackTreasureOpened();
                                
                                // Award treasure reward in addition to normal points
                                const treasureReward = block.treasureReward;
                                updateScore(treasureReward);
                                
                                // Create special treasure popup
                                createScorePopup(block.x + block.width / 2, block.y + block.height / 2 - 20, `TREASURE! +${treasureReward}`, gameState.combo, '#FFD700');
                                
                                // Guarantee a rare powerup spawn from treasure chests
                                const rarePowerups = ['extralife', 'combo10x', 'combo5x', 'megaball'];
                                const randomRare = rarePowerups.length > 0 ? rarePowerups[Math.floor(Math.random() * rarePowerups.length)] : 'extralife';
                                spawnPowerUp(block.x + block.width / 2, block.y + block.height / 2, randomRare);
                                
                                // Create golden particles for treasure
                                createParticles(block.x + block.width / 2, block.y + block.height / 2, '#FFD700', 15);
                                
                                // Show feedback message
                                showPowerUpFeedback('TREASURE OPENED!', '#FFD700');
                            }
                            
                            // Phase 3: Track shield and magnetic block destruction for achievements
                            if (block.type === 'shield') {
                                trackShieldDestroyed();
                            } else if (block.type === 'magnetic_attract' || block.type === 'magnetic_repel') {
                                trackMagneticHit();
                            }
                            
                            // Scoring with combo system - combo multiplies points
                            gameState.combo++;
                            const basePoints = (block.type === 'treasure' ? 25 : 10) * gameState.multiplier; // Treasure gives more base points
                            const comboMultiplier = Math.min(gameState.combo, 500); // Allow up to 500x combo
                            const tempMultiplier = gameState.tempComboMultiplier || 1;
                            const points = basePoints * comboMultiplier * tempMultiplier;
                            updateScore(points);
                            
                            // Don't show regular score popup for treasure (already shown above)
                            if (block.type !== 'treasure') {
                                createScorePopup(block.x + block.width / 2, block.y + block.height / 2, points, gameState.combo);
                            }
                            
                            // Spawn power-up on destruction (skip for treasure chests as they already spawn guaranteed rare powerups)
                            if (block.type !== 'treasure') {
                                trySpawnPowerUpOnHit(block.x + block.width / 2, block.y + block.height / 2);
                            }
                            
                            // Create particles
                            createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color);
                            
                            // If this block is lava, trigger explosion
                            if (block.type === 'lava') {
                                explodeLavaBlock(block);
                            }
                            
                            // Rocket + Explosive combo: explode surrounding blocks too
                            if (ball.mega) {
                                const adjacentBlocks = blocks.filter(b => 
                                    !b.destroyed && 
                                    Math.abs(b.x - block.x) <= blockWidth + blockPadding &&
                                    Math.abs(b.y - block.y) <= blockHeight + blockPadding
                                );
                                
                                adjacentBlocks.forEach(adjBlock => {
                                    // Only destroy if not metal or void brick
                                    if (adjBlock.type !== 'metal' && adjBlock.type !== 'void') {
                                        adjBlock.destroyed = true;
                                        sessionStats.blocksDestroyed++;
                                        const comboPoints = 10 * gameState.multiplier * Math.min(gameState.combo, 500);
                                        updateScore(comboPoints);
                                        createParticles(adjBlock.x + adjBlock.width / 2, adjBlock.y + adjBlock.height / 2, adjBlock.color);
                                        // Consistent powerup chance for explosive destruction
                                        trySpawnPowerUpOnHit(adjBlock.x + adjBlock.width / 2, adjBlock.y + adjBlock.height / 2);
                                    }
                                });
                                
                                gameState.screenShake = 8; // Bigger shake for combo effect
                            }
                            
                            updateUI();
                            playSound('block');
                            if (!ball.mega) gameState.screenShake = 3;
                            
                            // Rocket ball continues through - no deflection for regular bricks
                            if (isMetalBrick) {
                                // Only deflect off metal bricks
                                const ballCenterX = ball.x;
                                const ballCenterY = ball.y;
                                const blockCenterX = block.x + block.width / 2;
                                const blockCenterY = block.y + block.height / 2;
                                
                                const deltaX = ballCenterX - blockCenterX;
                                const deltaY = ballCenterY - blockCenterY;
                                
                                if (Math.abs(deltaX / block.width) > Math.abs(deltaY / block.height)) {
                                    ball.dx = -ball.dx;
                                } else {
                                    ball.dy = -ball.dy;
                                }
                            }
                        } else {
                            // Regular ball collision - handle multi-hit blocks
                            if (block.type === 'shield') {
                                // Shield blocks use separate shield strength system
                                block.shieldStrength--;
                                if (block.shieldStrength <= 0) {
                                    block.hits = 0; // Trigger destruction
                                }
                            } else {
                                block.hits--;
                            }
                            
                            // Consistent powerup chance on any hit (but not for treasure chests, they have special handling)
                            if (block.type !== 'treasure') {
                                trySpawnPowerUpOnHit(block.x + block.width / 2, block.y + block.height / 2);
                            }
                            
                            if (block.hits <= 0) {
                                block.destroyed = true;
                                sessionStats.blocksDestroyed++;
                                
                                // Phase 4: Apply elemental ball effects
                                if (mysticalPowers.active && ball.element) {
                                    applyElementalBallEffect(ball, block);
                                }
                                
                                // Phase 4: Track block destruction for analytics
                                if (analyticsSystem.active) {
                                    trackBlockDestroyed(block.type, ball.element || 'normal');
                                }
                                
                                // Special treasure chest handling
                                if (block.type === 'treasure') {
                                    // Trigger opening animation
                                    block.treasureOpening = true;
                                    
                                    // Award treasure reward in addition to normal points
                                    const treasureReward = block.treasureReward;
                                    updateScore(treasureReward);
                                    
                                    // Create special treasure popup
                                    createScorePopup(block.x + block.width / 2, block.y + block.height / 2 - 20, `TREASURE! +${treasureReward}`, gameState.combo, '#FFD700');
                                    
                                    // Guarantee a rare powerup spawn from treasure chests
                                    const rarePowerups = ['extralife', 'combo10x', 'combo5x', 'megaball'];
                                    const randomRare = rarePowerups.length > 0 ? rarePowerups[Math.floor(Math.random() * rarePowerups.length)] : 'extralife';
                                    spawnPowerUp(block.x + block.width / 2, block.y + block.height / 2, randomRare);
                                    
                                    // Create golden particles for treasure
                                    createParticles(block.x + block.width / 2, block.y + block.height / 2, '#FFD700', 15);
                                    
                                    // Show feedback message
                                    showPowerUpFeedback('TREASURE OPENED!', '#FFD700');
                                }
                                
                                // Scoring with combo system - combo multiplies points
                                gameState.combo++;
                                const basePoints = (block.type === 'treasure' ? 25 : 10) * gameState.multiplier; // Treasure gives more base points
                                const comboMultiplier = Math.min(gameState.combo, 500); // Allow up to 500x combo
                                const tempMultiplier = gameState.tempComboMultiplier || 1;
                                const points = basePoints * comboMultiplier * tempMultiplier;
                                updateScore(points);
                                
                                // Don't show regular score popup for treasure (already shown above)
                                if (block.type !== 'treasure') {
                                    createScorePopup(block.x + block.width / 2, block.y + block.height / 2, points, gameState.combo);
                                }
                                
                                // Note: Powerup already attempted above for consistency
                                
                                // Create particles
                                createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color);
                                
                                // If this block is lava, trigger explosion
                                if (block.type === 'lava') {
                                    explodeLavaBlock(block);
                                }
                            }
                            
                            updateUI();
                            playSound('block');
                            gameState.screenShake = 3;
                            
                            // Ball collision response (improved physics)
                            const ballCenterX = ball.x;
                            const ballCenterY = ball.y;
                            const blockCenterX = block.x + block.width / 2;
                            const blockCenterY = block.y + block.height / 2;
                            
                            const deltaX = ballCenterX - blockCenterX;
                            const deltaY = ballCenterY - blockCenterY;
                            
                            // Determine collision side
                            if (Math.abs(deltaX / block.width) > Math.abs(deltaY / block.height)) {
                                ball.dx = -ball.dx; // Hit left or right side
                            } else {
                                ball.dy = -ball.dy; // Hit top or bottom
                            }
                            
                            // Mega ball destroys multiple blocks
                            if (ball.mega) {
                                const adjacentBlocks = blocks.filter(b => 
                                    !b.destroyed && 
                                    Math.abs(b.x - block.x) <= blockWidth + blockPadding &&
                                    Math.abs(b.y - block.y) <= blockHeight + blockPadding
                                );
                                
                                adjacentBlocks.forEach(adjBlock => {
                                    adjBlock.destroyed = true;
                                    sessionStats.blocksDestroyed++;
                                    const comboPoints = 10 * gameState.multiplier * Math.min(gameState.combo, 500);
                                    updateScore(comboPoints);
                                    createParticles(adjBlock.x + adjBlock.width / 2, adjBlock.y + adjBlock.height / 2, adjBlock.color);
                                });
                            }
                        }
                        
                        // Check win condition - exclude only void blocks from completion check (metal blocks must be destroyed)
                        if (blocks.every(block => block.destroyed || block.type === 'void')) {
                            nextLevel();
                        }
                        
                        break;
                    }
                }
                
            });
            
            // Handle laser beam collisions separately
            gameState.powerUps.forEach((laser, laserIndex) => {
                if (!laser.isLaser) return;
                
                for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {
                    const block = blocks[blockIndex];
                    if (block.destroyed) continue;
                    
                    if (laser.x >= block.x && laser.x <= block.x + block.width &&
                        laser.y >= block.y && laser.y <= block.y + block.height) {
                        
                        // Check if any ball currently has rocket powerup active
                        const anyBallHasRocket = gameState.balls.some(ball => ball.rocket);
                        
                        // Check if this is a metal or void brick - lasers cannot damage them
                        if (block.type === 'metal' || block.type === 'void') {
                            // Remove the laser beam but don't damage metal/void block
                            gameState.powerUps.splice(laserIndex, 1);
                            playSound('block'); // Still make sound for feedback
                            break;
                        }
                        
                        // Handle multi-hit blocks properly - reduce hits by 1
                        block.hits--;
                        
                        // Consistent powerup chance on laser hit
                        trySpawnPowerUpOnHit(block.x + block.width / 2, block.y + block.height / 2);
                        
                        if (block.hits <= 0) {
                            block.destroyed = true;
                            sessionStats.blocksDestroyed++;
                            // Create particles when block is destroyed
                            createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color);
                            
                            // If this block is lava, trigger explosion
                            if (block.type === 'lava') {
                                explodeLavaBlock(block);
                            }
                        }
                        
                        updateScore(5 * gameState.multiplier);
                        updateUI();
                        playSound('block');
                        
                        // Check if laser should pass through or be destroyed
                        let shouldDestroyLaser = true;
                        
                        // If rocket ball is active AND this was a single-hit block, let laser pass through
                        if (anyBallHasRocket && block.hits === 0) {
                            // Block had 1 hit point (now 0 after damage) and rocket is active
                            // Let the laser pass through instead of destroying it
                            shouldDestroyLaser = false;
                        } else if (anyBallHasRocket && block.hits > 0) {
                            // Block still has multiple hit points, destroy laser even with rocket
                            shouldDestroyLaser = true;
                        }
                        
                        // Remove the laser beam only if it should be destroyed
                        if (shouldDestroyLaser) {
                            gameState.powerUps.splice(laserIndex, 1);
                        }
                        
                        // Check win condition - exclude only void blocks from completion check (metal blocks must be destroyed)
                        if (blocks.every(block => block.destroyed || block.type === 'void')) {
                            nextLevel();
                        }
                        
                        // Only break out of block loop if laser was destroyed
                        if (shouldDestroyLaser) {
                            break;
                        }
                    }
                }
            });
        }

        function resetBalls() {
            // Clear all existing balls and their trails
            gameState.balls.forEach(ball => {
                if (ball.trail) ball.trail = [];
            });
            gameState.balls = [];
            
            // Re-acquire pointer lock after respawn (with delay)
            if (!pointerLocked && canvas.requestPointerLock) {
                setTimeout(() => {
                    if (gameRunning && !gamePaused && canvas.requestPointerLock) {
                        canvas.requestPointerLock();
                    }
                }, 500); // Small delay to avoid immediate lock after death
            }
            
            // Phase 3: Apply difficulty-adjusted speed
            const baseBallSpeed = 5;
            const difficultyAdjustedSpeed = getDifficultyAdjustedSpeed();
            
            const newBall = {
                x: canvas.width / 2,
                y: paddle.y - 20,
                radius: ballTemplate.radius,
                dx: 0,
                dy: 0,
                speed: difficultyAdjustedSpeed, // Difficulty-adjusted speed
                launched: false,
                trail: []
            };
            
            // Check for active element override enchantments
            if (mysticalPowers.active) {
                const elementOverride = mysticalPowers.activeEnchantments.find(
                    e => e.effects && e.effects.elementOverride
                );
                if (elementOverride) {
                    const element = elementOverride.effects.elementOverride;
                    newBall.element = element;
                    if (element !== 'normal' && mysticalPowers.elementalBalls[element]) {
                        const elementData = mysticalPowers.elementalBalls[element];
                        newBall.color = elementData.color;
                        newBall.trailColor = elementData.trailColor;
                        
                        // Set up elemental effects
                        newBall.elementalEffects = {};
                        if (element === 'lightning') {
                            newBall.elementalEffects.chainRange = elementData.effects.chainRange;
                            newBall.elementalEffects.maxChains = elementData.effects.maxChains;
                        }
                    }
                }
            }
            
            console.log(`After life lost at level ${level}: Ball speed set to ${newBall.speed} (base: ${baseBallSpeed}, difficulty: ${difficultyAdjustment.currentModifier.toFixed(2)}x)`);
            gameState.balls = [newBall];
            gameState.combo = 0;
            // Reset temp combo multiplier on life lost
            gameState.tempComboMultiplier = 1;
            gameState.tempComboTimer = 0;
            gameState.tempComboDuration = 0;
            gameState.tempComboStartTime = 0;
        }

        function nextLevel() {
            const completedLevel = level;
            level++;
            gameState.multiplier = 1; // Keep multiplier constant, no level-based increases
            
            // Track level completion for analytics
            trackLevelCompleted(completedLevel);
            
            // Phase 4: Track zone completion for world map system
            if (worldMapSystem.active) {
                completeCurrentZone();
                updateCurrentZone(); // Update to new world/zone after level increment
                applyWorldEffects(); // Apply effects for new zone
            }
            
            // DEBUG: Log all game variables at level transition
            console.log(`=== LEVEL TRANSITION FROM ${completedLevel} TO ${level} ===`);
            console.log('ballTemplate.speed:', ballTemplate.speed);
            console.log('paddle.speed:', paddle.speed);
            console.log('gameState:', JSON.stringify(gameState));
            console.log('Current balls:', gameState.balls.map(b => ({speed: b.speed, dx: b.dx, dy: b.dy})));
            
            // STEP 1: Stop all balls and game action
            gameState.balls = [];
            gameState.powerUps = gameState.powerUps.filter(p => p.isLaser);
            gameState.particles = [];
            gameState.feedbackMessages = [];
            gameState.combo = 0;
            // Reset temp combo multiplier on level complete
            gameState.tempComboMultiplier = 1;
            gameState.tempComboTimer = 0;
            gameState.tempComboDuration = 0;
            gameState.tempComboStartTime = 0;
            
            // STEP 2: Pause the game loop temporarily
            const wasRunning = gameRunning;
            gameRunning = false;
            
            playSound('win');
            
            // STEP 3: Show level completion overlay immediately
            setTimeout(async () => {
                gameOverlay = {
                    type: 'levelComplete',
                    completedLevel: completedLevel,
                    score: score.toLocaleString(),
                    nextLevel: level
                };
                
                // STEP 4: Set up next level immediately (don't wait for user input)
                await setupNextLevel();
                
                if (wasRunning) {
                    gameRunning = true;
                    // Don't call gameLoop() - it's already running and will resume automatically
                }
            }, 100); // Reduced from 300ms to 100ms
        }
        
        async function setupNextLevel() {
            // Initialize new level blocks
            await initBlocks();
            
            // Reset paddle position and properties
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.width = paddle.originalWidth;
            paddle.laser = false;
            paddle.sticky = false;
            paddle.powerUpTimer = 0;
            paddle.lastX = paddle.x; // Initialize lastX to prevent velocity glitch
            paddle.velocity = 0; // Reset velocity
            
            // Clear any remaining power-ups and particles completely
            gameState.powerUps = [];
            gameState.particles = []; // Clear all particles that could cause performance issues
            gameState.scorePopups = []; // Clear score popups
            gameState.feedbackMessages = [];
            gameState.combo = 0;
            gameState.screenShake = 0;
            // Reset temp combo multiplier
            gameState.tempComboMultiplier = 1;
            gameState.tempComboTimer = 0;
            gameState.tempComboDuration = 0;
            gameState.tempComboStartTime = 0;
            
            // Force garbage collection of any lingering objects
            if (window.gc) window.gc();
            
            // CRITICAL FIX: Clear all balls and their effects completely - don't modify existing balls
            // The old balls with their effects were causing frame rate issues
            gameState.balls = [];
            
            const newBall = {
                x: paddle.x + paddle.width / 2,
                y: paddle.y - 20,
                radius: ballTemplate.radius,
                dx: 0,
                dy: 0,
                speed: 5, // Hard-coded to base speed - NO level increases
                launched: false,
                trail: []
            };
            console.log(`Level ${level}: Ball speed set to ${newBall.speed} (base: 5, ballTemplate: ${ballTemplate.speed})`);
            gameState.balls = [newBall];
            
            // Update UI
            updateUI();
            
            // Draw the new state immediately
            draw();
            
            // Show instruction for launching
            setTimeout(() => {
                if (gameRunning) {
                    gameOverlay = {
                        active: true,
                        type: 'levelReady',
                        level: level,
                        title: `LEVEL ${level} READY!`,
                        message: 'PRESS SPACE TO LAUNCH',
                        instruction: 'CLICK OR PRESS SPACE TO CONTINUE'
                    };
                }
            }, 100);
        }

        async function gameOver() {
            // Prevent multiple calls
            console.log(`gameOver() called - gameRunning: ${gameRunning}, lives: ${lives}, score: ${score}`);
            if (!gameRunning) {
                console.log('gameOver() blocked - gameRunning is false');
                return;
            }
            
            // Release pointer lock when game ends
            if (pointerLocked && document.exitPointerLock) {
                document.exitPointerLock();
            }
            
            // Track game end for analytics
            trackGameEnd();
            
            gameRunning = false;
            legitGameCompleted = true; // Mark as legitimate game completion
            // Don't set gameStarted = false yet - wait until after hall of fame
            if (pauseBtn) pauseBtn.disabled = true;
            
            // Show the interactive hall of fame directly
            await showInteractiveHallOfFame();
            console.log('gameOver() - after showInteractiveHallOfFame, gameRunning:', gameRunning);
            console.log('gameOver() - overlay active:', gameOverlay.active, 'type:', gameOverlay.type);
        }
        
        async function showInteractiveHallOfFame() {
            console.log('showInteractiveHallOfFame() called');
            
            // Prevent duplicate entries - only allow after legitimate game completion
            if (!legitGameCompleted) {
                console.log('showInteractiveHallOfFame() blocked - not a legitimate game completion');
                return;
            }
            
            try {
                const scores = await getHighScores(10);
                console.log('Got scores:', scores);
                console.log('First score object:', scores[0]);
                
                // Calculate where the current player's score would rank
                console.log('Calculating player rank, current score:', score);
                let playerRank = scores.length + 1; // Default to last position
                let insertAtIndex = scores.length;
                
                try {
                    for (let i = 0; i < scores.length; i++) {
                        console.log(`Comparing score ${score} with ${scores[i].score} (${parseInt(scores[i].score)})`);
                        if (score > parseInt(scores[i].score)) {
                            playerRank = i + 1;
                            insertAtIndex = i;
                            console.log(`Player ranks at position ${playerRank}`);
                            break;
                        }
                    }
                    console.log(`Final player rank: ${playerRank}, insertAtIndex: ${insertAtIndex}`);
                } catch (rankError) {
                    console.error('Error calculating player rank:', rankError);
                    // Use default values if there's an error
                }
                
                // Show name input if player makes top 10 OR if there are fewer than 10 scores
                const allowNameInput = playerRank <= 10 || scores.length < 10;
                console.log(`Player rank: ${playerRank}, scores.length: ${scores.length}, allowNameInput: ${allowNameInput}`);
                
                if (allowNameInput) {
                    console.log('Setting up hall of fame for qualifying score');
                    
                    // Check if user is logged in (using already cached currentUser)
                    console.log('=== HALL OF FAME DECISION DEBUG ===');
                    console.log('currentUser type:', typeof currentUser);
                    console.log('currentUser value:', currentUser);
                    console.log('currentUser.username:', currentUser ? currentUser.username : 'N/A');
                    console.log('currentUser && currentUser.username check:', !!(currentUser && currentUser.username));
                    const defaultName = (typeof currentUser !== 'undefined' && currentUser && currentUser.username) ? currentUser.username : '';
                    console.log('defaultName result:', defaultName);
                    console.log('defaultName is truthy:', !!defaultName);
                    console.log('Window context:', window.parent === window ? 'Direct access' : 'Iframe');
                    console.log('===================================');
                    
                    // All users now get the same interactive experience
                    // Set pre-filled name for logged-in users, but still show interactive input
                    if (defaultName) {
                        console.log('🎯 LOGGED-IN USER - Pre-filling name for interactive input:', defaultName);
                    } else {
                        console.log('🎯 ANONYMOUS USER - Empty name field for interactive input');
                    }
                    
                    // Show interactive input for everyone (logged-in users get pre-filled name)
                    console.log('🟢 TAKING INTERACTIVE PATH - All users get same experience');
                    console.log('Showing interactive name input with pre-filled name:', defaultName || 'empty');
                        
                    gameOverlay = {
                        active: true,
                        type: 'hallOfFameInput',
                        title: '🏆 HALL OF FAME 🏆',
                        scores: scores,
                        playerScore: score,
                        playerLevel: Math.max(1, level),
                        playerRank: playerRank,
                        insertAtIndex: insertAtIndex,
                        inputName: defaultName || '', // Pre-fill name for logged-in users
                        cursorVisible: true,
                        cursorBlinkTime: Date.now(),
                        instruction: defaultName ? 
                            'Your name is pre-filled. Press ENTER to save your score' : 
                            'Type your name. Press ENTER to save your score'
                    };
                } else {
                    console.log('Player did not qualify for top 10, showing regular hall of fame');
                    // Score doesn't qualify for top 10, show hall of fame first, then game over
                    
                    // Check if user is logged in even for non-qualifying scores (using cached currentUser)
                    const playerName = (typeof currentUser !== 'undefined' && currentUser && currentUser.username) ? currentUser.username : 'Anonymous';
                    console.log('Non-qualifying - Detected user:', playerName);
                    console.log('Non-qualifying - currentUser object:', typeof currentUser !== 'undefined' ? currentUser : 'undefined');
                    
                    await submitScore(playerName, score, Math.max(1, level));
                    
                    // Show hall of fame with a message about not qualifying
                    gameOverlay = {
                        active: true,
                        type: 'hallOfFameNoQualify',
                        title: '🏆 HALL OF FAME 🏆',
                        scores: scores,
                        playerScore: score,
                        playerLevel: Math.max(1, level),
                        playerName: playerName,
                        instruction: "Your score didn't make the top 10. Press SPACE or CLICK to continue"
                    };
                }
                
                console.log('showInteractiveHallOfFame() completed, gameOverlay:', gameOverlay);
            } catch (error) {
                console.error('Error displaying interactive hall of fame:', error);
                // Fallback to regular game over on error
                const fallbackPlayerName = (typeof currentUser !== 'undefined' && currentUser && currentUser.username) ? currentUser.username : 'Anonymous';
                await submitScore(fallbackPlayerName, score, Math.max(1, level));
                
                gameStarted = false; // Now it's safe to return to start screen
                gameOverlay = {
                    active: true,
                    type: 'gameOver',
                    title: '🎮 GAME OVER 🎮',
                    message: `Final Score: ${score.toLocaleString()}\nLevel Reached: ${Math.max(1, level)}\nPlayer: ${fallbackPlayerName}`,
                    instruction: 'Press SPACE or CLICK to continue'
                };
            }
        }

        async function submitScore(playerName, score, levelReached) {
            try {
                console.log('submitScore called:', playerName, score, levelReached);
                // Session validation for score submission
                
                // Ensure we have a session ID for submission
                if (!gameSessionId) {
                    console.warn('No game session ID found, attempting to create session for score submission');
                    try {
                        // Try to create a session for score submission with retry
                        let emergencySession;
                        for (let attempt = 1; attempt <= 3; attempt++) {
                            console.log(`Emergency session creation attempt ${attempt}/3`);
                            emergencySession = await startGameSession(playerName);
                            if (emergencySession.success && gameSessionId) {
                                // Emergency session created successfully
                                break;
                            }
                            if (attempt < 3) {
                                console.warn(`Attempt ${attempt} failed, retrying...`);
                                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                            }
                        }
                        
                        if (!emergencySession.success || !gameSessionId) {
                            if (emergencySession.error === 'IP_BLOCKED') {
                                console.error('IP is blocked - cannot submit scores');
                                // Show special message for IP blocking
                                throw new Error('IP_BLOCKED');
                            }
                            throw new Error('Failed to create emergency session after 3 attempts: ' + (emergencySession.error || 'Unknown error'));
                        }
                    } catch (sessionError) {
                        console.error('Failed to create session for score submission:', sessionError);
                        throw new Error('No valid game session available for score submission');
                    }
                }
                
                // Create obfuscated submission payload for F12 protection
                const timestamp = Date.now();
                const nonce = Math.random().toString(36).substring(2, 15);
                
                // Create checksum from game data to prevent tampering (must match PHP SHA256 logic)
                const checksumInput = playerName + score + levelReached + timestamp + nonce;
                
                // Generate SHA256 hash and take first 12 bytes, then base64 encode (matching PHP logic)
                const encoder = new TextEncoder();
                const data = encoder.encode(checksumInput);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = new Uint8Array(hashBuffer).slice(0, 12); // First 12 bytes
                const gameChecksum = btoa(String.fromCharCode(...hashArray));
                
                // Obfuscate the actual values with decoy data
                const obfuscatedData = {
                    p_n: btoa(playerName).split('').reverse().join(''), // Obfuscated player name
                    s_v: (score ^ 0x1337) + timestamp, // XOR obfuscated score with smaller value to prevent overflow
                    l_r: levelReached * 7 + 13, // Mathematical obfuscation of level
                    s_id: gameSessionId,
                    tk: gameSessionToken,
                    ts: timestamp,
                    nc: nonce,
                    chk: gameChecksum,
                    // Add decoy fields to confuse F12 users
                    debug_mode: false,
                    admin_bypass: false,
                    cheat_enabled: false,
                    validation_skip: false,
                    score_multiplier: 1.0,
                    anti_cheat_bypass: null,
                    dev_mode: undefined
                };
                
                // Payload obfuscation completed - debug logging removed for security
                
                // TEMPORARY: Use simple endpoint for debugging
                const response = await fetch('simple_score_submit.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Game-Version': '2.1',
                        'X-Anti-Tamper': gameChecksum
                    },
                    body: JSON.stringify({
                        player_name: playerName,
                        score: score,
                        level_reached: level
                    })
                });
                
                console.log('Score submission response:', response.status, response.statusText);
                
                if (!response.ok) {
                    // Try to get the error message from the response
                    let errorMessage = `Failed to submit score: ${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error) {
                            errorMessage = errorData.error;
                            
                            // Check for name protection error and show specific UI
                            if (errorMessage.includes('reserved for registered users') || 
                                errorMessage.includes('choose a different name') ||
                                errorMessage.includes('must use their registered username')) {
                                showNameProtectionError(errorMessage);
                                return; // Don't throw, we handled it with UI
                            }
                        }
                    } catch (e) {
                        // Error response might not be JSON (like 504 timeout)
                        console.warn('Could not parse error response as JSON:', e);
                    }
                    throw new Error(errorMessage);
                }
                
                const result = await response.json();
                console.log('Score submission result:', result);
                return result;
            } catch (error) {
                console.error('Error submitting score:', error);
                throw error;
            }
        }

        function showNameProtectionError(errorMessage) {
            console.log('Showing name protection error:', errorMessage);
            
            // Check if we're in an interactive hall of fame context and can return to input
            const canReturnToInput = gameOverlay && gameOverlay.type === 'hallOfFameInput';
            
            gameOverlay = {
                active: true,
                type: 'nameError',
                title: '❌ NAME PROTECTION ❌',
                message: errorMessage,
                instruction: canReturnToInput ? 'Press SPACE to try again with a different name' : 'Press SPACE or CLICK to try again',
                returnToInput: canReturnToInput,
                originalData: canReturnToInput ? {
                    playerScore: gameOverlay.playerScore,
                    playerLevel: gameOverlay.playerLevel,
                    playerRank: gameOverlay.playerRank,
                    insertAtIndex: gameOverlay.insertAtIndex
                } : null
            };
        }

        async function recordCompletionist() {
            try {
                // Prevent duplicate completionist records
                if (completionistRecorded) {
                    console.log('Completionist already recorded for this session, skipping');
                    return;
                }
                
                console.log('Recording completionist achievement');
                completionistRecorded = true; // Mark as recorded immediately
                const playerName = currentUser ? currentUser.username : 'Anonymous Hero';
                
                const completionData = {
                    action: 'record_completion',
                    player_name: playerName,
                    score: score,
                    completion_date: new Date().toISOString(),
                    session_id: gameSessionId,
                    token: gameSessionToken
                };
                
                const response = await fetch('breakout_completionists.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(completionData)
                });
                
                if (!response.ok) {
                    console.warn('Failed to record completionist status:', response.statusText);
                    return;
                }
                
                const result = await response.json();
                console.log('Completionist recorded:', result);
                return result;
            } catch (error) {
                console.error('Error recording completionist:', error);
                // Reset flag on error so it can be retried
                completionistRecorded = false;
                // Don't throw - this is non-critical for gameplay
            }
        }

        async function getCompletionists(limit = 10) {
            try {
                console.log('Getting completionists list');
                const response = await fetch(`breakout_completionists.php?limit=${limit}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const completionists = await response.json();
                console.log('Loaded completionists:', completionists);
                return completionists;
            } catch (error) {
                console.error('Error loading completionists:', error);
                return [];
            }
        }

        // Alias for backwards compatibility
        const showCompletionistsHallOfFame = () => showCompletionistHallOfFame();

        async function getHighScores(limit = 10) {
            try {
                console.log('getHighScores called with limit:', limit);
                
                // Always use direct API for now to avoid secure API issues
                console.log('Using direct leaderboard API');
                const response = await fetch(`scores_api.php?limit=${limit}`);
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const scores = await response.json();
                console.log('Loaded scores:', scores);
                return scores;
            } catch (error) {
                console.error('Error fetching Hall of Fame scores:', error);
                console.error('Error details:', error.message);
                return [];
            }
        }

        async function showRegularHallOfFame(returnToGameOver = false, gameOverData = null) {
            try {
                console.log('showRegularHallOfFame called, gameStarted:', gameStarted, 'gameOverlay.active:', gameOverlay.active);
                console.log('Canvas:', canvas, 'Ctx:', ctx);
                const scores = await getHighScores(10);
                console.log('Scores loaded for Hall of Fame:', scores);
                
                // Regular hall of fame display (no name input functionality)
                gameOverlay = {
                    active: true,
                    type: 'hallOfFame',
                    title: '🏆 HALL OF FAME 🏆',
                    scores: scores,
                    returnToGameOver: returnToGameOver,
                    gameOverData: gameOverData,
                    instruction: returnToGameOver ? 'Press SPACE or CLICK to return • Press C for Completionists' : 'Press SPACE or CLICK to close • Press C for Completionists'
                };
                
                console.log('Hall of Fame overlay set:', gameOverlay);
                console.log('gameOverlay.active after setting:', gameOverlay.active);
                
                // Add global keyboard handler for this overlay
                addOverlayKeyHandler();
                
                // Force a redraw to ensure overlay shows
                console.log('Forcing draw call after setting overlay');
                draw();
                
                setTimeout(() => {
                    console.log('Timeout check - gameOverlay.active:', gameOverlay.active);
                }, 100);
                
            } catch (error) {
                console.error('Error displaying hall of fame:', error);
                // Show error overlay instead of alert
                gameOverlay = {
                    active: true,
                    type: 'hallOfFame',
                    title: '❌ ERROR ❌',
                    scores: [],
                    error: true,
                    instruction: 'Press SPACE or CLICK to close'
                };
            }
        }

        // Alias for backwards compatibility
        const showHallOfFame = showRegularHallOfFame;

        async function getCompletionists(limit = 10) {
            try {
                console.log('getCompletionists called with limit:', limit);
                const response = await fetch(`breakout_completionists.php?limit=${limit}`);
                console.log('Completionists response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const completionists = await response.json();
                console.log('Loaded completionists:', completionists);
                return completionists;
            } catch (error) {
                console.error('Error fetching Completionists Hall of Fame:', error);
                console.error('Error details:', error.message);
                return [];
            }
        }

        async function showCompletionistHallOfFame(returnToGameOver = false, gameOverData = null) {
            try {
                console.log('showCompletionistHallOfFame called');
                const completionists = await getCompletionists(10);
                console.log('Completionists loaded:', completionists);
                
                // Completionist hall of fame display
                gameOverlay = {
                    active: true,
                    type: 'completionistsHallOfFame',
                    title: '🏅 COMPLETIONISTS HALL OF FAME 🏅',
                    subtitle: 'Masters of the Ultimate Void',
                    completionists: completionists,
                    returnToGameOver: returnToGameOver,
                    gameOverData: gameOverData,
                    instruction: returnToGameOver ? 'Press SPACE or CLICK to return • Press H for High Scores' : 'Press SPACE or CLICK to close • Press H for High Scores'
                };
                
                console.log('Completionist Hall of Fame overlay set:', gameOverlay);
                
                // Add global keyboard handler for this overlay
                addOverlayKeyHandler();
                
                // Force a redraw to ensure overlay shows
                draw();
                
            } catch (error) {
                console.error('Error displaying completionist hall of fame:', error);
                // Show error overlay instead of alert
                gameOverlay = {
                    active: true,
                    type: 'completionistsHallOfFame',
                    title: '❌ ERROR ❌',
                    completionists: [],
                    error: true,
                    instruction: 'Press SPACE or CLICK to close'
                };
            }
        }

        // closeHighScoreTable function removed - now using canvas overlay system

        function updateUI() {
            if (scoreElement) scoreElement.textContent = score;
            if (livesElement) livesElement.textContent = lives;
            if (levelElement) levelElement.textContent = level;
            
            // Update session personal best if current score is higher
            if (score > sessionPersonalBest) {
                sessionPersonalBest = score;
            }
            
            // Update personal best display with current session's highest score
            if (personalBestElement) {
                const personalBest = Math.max(sessionPersonalBest, getLocalHighScore());
                personalBestElement.textContent = personalBest.toLocaleString();
            }
        }

        // Dynamic text positioning function to ensure text fits within screen bounds
        function getSafeInstructionTextY(baseY, textHeight = 25, margin = 20) {
            // Calculate maximum Y position that keeps text within canvas bounds
            const maxY = canvas.height - margin - textHeight;
            
            // If baseY would place text outside canvas, adjust it
            if (baseY > maxY) {
                return maxY;
            }
            
            // Ensure text isn't too close to the top either
            const minY = margin + textHeight;
            if (baseY < minY) {
                return minY;
            }
            
            return baseY;
        }
        
        function drawMultiLineInstruction(instructionText, baseY, fontSize = 23, lineSpacing = 30) {
            if (!ctx) return;
            // Split instruction text by bullet separator and periods for better line wrapping
            let lines = instructionText.split(' • ');
            
            // Further split lines at periods if they contain them
            const finalLines = [];
            lines.forEach(line => {
                if (line.includes('. ')) {
                    const periodSplit = line.split('. ');
                    periodSplit.forEach((segment, index) => {
                        if (index < periodSplit.length - 1) {
                            finalLines.push(segment.trim() + '.');
                        } else {
                            finalLines.push(segment.trim());
                        }
                    });
                } else {
                    finalLines.push(line);
                }
            });
            
            const startY = getSafeInstructionTextY(baseY, fontSize, 20);
            
            finalLines.forEach((line, index) => {
                const yPos = startY + (index * lineSpacing);
                ctx.fillText(line.trim(), canvas.width / 2, yPos);
            });
        }

        // Draw void zones for Void Titan boss
        function drawVoidZones() {
            if (!bossSystem.active || voidZones.length === 0) return;
            if (!ctx) return;
            
            ctx.save();
            voidZones.forEach(zone => {
                // Void zone background
                const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
                gradient.addColorStop(0, 'rgba(75, 0, 130, 0.8)');
                gradient.addColorStop(0.7, 'rgba(75, 0, 130, 0.4)');
                gradient.addColorStop(1, 'rgba(75, 0, 130, 0.1)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Void zone border with pulsing effect
                const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(148, 0, 211, ${pulse})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Warning text in center
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 8px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('VOID', zone.x, zone.y);
            });
            ctx.restore();
        }

        function draw() {
            if (!canvas || !ctx) {
                console.error('draw() called but canvas or ctx is null:', {canvas, ctx});
                return;
            }
            
            // Draw function running normally
            
            // Additional debug - check if context is still valid
            try {
                // Test if ctx is still functional
                ctx.save();
                ctx.restore();
            } catch (e) {
                console.error('Canvas context is corrupted, attempting to recreate:', e);
                // Try to recreate the context
                try {
                    ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error('Failed to recreate canvas context');
                        return;
                    }
                    console.log('Canvas context successfully recreated');
                } catch (recreateError) {
                    console.error('Error recreating context:', recreateError);
                    return;
                }
            }
            
            // Update body class for CSS animations
            if (!gameStarted) {
                document.body.classList.add('game-not-started');
            } else {
                document.body.classList.remove('game-not-started');
            }
            
            // Apply screen shake
            ctx.save();
            if (gameState.screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
                gameState.screenShake *= 0.8;
                if (gameState.screenShake < 0.1) gameState.screenShake = 0;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw blocks with enhanced 3D effect
            // Reset any lingering transforms before drawing blocks
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            // Re-apply screen shake if active
            if (gameState.screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
            }
            
            for (let block of blocks) {
                if (!block.destroyed) {
                    drawBlock(block);
                }
            }
            
            // Draw void zones for boss battles
            drawVoidZones();
            
            // Draw power-ups with enhanced round visuals
            gameState.powerUps.forEach(powerUp => {
                if (powerUp.isLaser) {
                    // Draw laser beam
                    ctx.fillStyle = powerUp.color;
                    ctx.fillRect(powerUp.x - 3, powerUp.y, 5, 25);
                } else {
                    // Enhanced circular power-up design
                    const radius = 18;
                    const time = Date.now() * 0.005;
                    const pulseEffect = Math.sin(time) * 0.2 + 1;
                    const glowRadius = radius * pulseEffect;
                    
                    // Draw outer glow effect
                    const gradient = ctx.createRadialGradient(powerUp.x, powerUp.y, 0, powerUp.x, powerUp.y, glowRadius + 8);
                    gradient.addColorStop(0, powerUp.color + '88'); // Semi-transparent center
                    gradient.addColorStop(0.7, powerUp.color + '44');
                    gradient.addColorStop(1, powerUp.color + '00'); // Fully transparent edge
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(powerUp.x, powerUp.y, glowRadius + 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw main circular background
                    ctx.fillStyle = powerUp.color;
                    ctx.beginPath();
                    ctx.arc(powerUp.x, powerUp.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add inner highlight for 3D effect
                    const highlightGradient = ctx.createRadialGradient(
                        powerUp.x - 6, powerUp.y - 6, 0,
                        powerUp.x, powerUp.y, radius
                    );
                    highlightGradient.addColorStop(0, '#FFFFFF44');
                    highlightGradient.addColorStop(1, '#FFFFFF00');
                    
                    ctx.fillStyle = highlightGradient;
                    ctx.beginPath();
                    ctx.arc(powerUp.x, powerUp.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw power-up symbol with better contrast
                    ctx.shadowColor = '#000000';
                    ctx.shadowBlur = 3;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '16px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Special handling for heart symbol (extra life)
                    if (powerUp.type === 'extralife') {
                        ctx.font = '20px "Press Start 2P", monospace';
                        ctx.fillText('♥', powerUp.x, powerUp.y);
                    } else {
                        ctx.fillText(powerUp.symbol, powerUp.x, powerUp.y);
                    }
                    
                    // Reset shadow and text properties to prevent UI interference
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.textAlign = 'left'; // Reset to default
                    ctx.textBaseline = 'alphabetic'; // Reset to default
                }
            });
            
            // Draw paddle with enhanced 3D effect and power-up indicators
            drawPaddle();
            
            // Draw particles
            drawParticles();
            
            // Draw score popups
            drawScorePopups();
            
            // CRITICAL: Reset transforms before UI drawing to prevent powerup/screenshake interference
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Completely reset transforms for UI
            
            // Draw UI overlays with clean transform state
            drawGameUI();
            
            ctx.restore(); // Restore clean UI state
            
            // Draw all balls with trails ON TOP of UI elements
            gameState.balls.forEach(ball => {
                drawBall(ball);
            });
            
            // Draw feedback messages (on top of everything including balls)
            drawFeedbackMessages();
            
            // Draw upgrade shop overlay
            if (upgradeShop.shopOpen) {
                drawUpgradeShopOverlay();
            }
            
            // Draw achievement gallery overlay
            if (achievementGallery.galleryOpen) {
                drawAchievementGallery();
            }
            
            // Draw challenge mode selection overlay
            drawChallengeModeSelection();
            
            // Draw challenge mode HUD
            drawChallengeModeHUD();
            
            // Draw mystical powers HUD
            drawMysticalPowersHUD();
            
            // Draw mystical powers selection menu
            drawMysticalSelectionMenu();
            
            // Draw world map HUD
            drawWorldMapHUD();
            
            // Draw world map overlay
            drawWorldMapOverlay();
            
            // Draw analytics overlays
            drawPlayerProfileOverlay();
            drawReplayBrowser();
            
            // Draw overlays (start screen, game over, level complete, etc.)
            if (!gameStarted || gameOverlay.active) {
                if (!ctx) {
                    console.error('ctx became undefined during draw execution');
                    return;
                }
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Drawing overlay or start screen
                
                if (!gameStarted && !gameOverlay.active) {
                    // Original start screen - moved to external UI panels
                    // This code is now handled by HTML UI elements
                } else if (gameOverlay.active) {
                    // Game over or level complete overlays
                    // This code will be moved here from the orphaned section
                }
            }
            
            ctx.restore(); // Restore original screen shake state
        }

        function drawBlock(block) {
            if (!ctx) return;
            const x = block.x;
            const y = block.y;
            const w = block.width;
            const h = block.height;
            
            // Adjust color based on hits remaining
            let color = block.color;
            let damageMultiplier = 1;
            if (block.hits < block.maxHits) {
                damageMultiplier = 0.6 + (block.hits / block.maxHits) * 0.4;
            }
            
            // Parse the hex color to create lighter and darker variants
            const hex = block.color.replace('#', '');
            const r = Math.floor(parseInt(hex.substr(0, 2), 16) * damageMultiplier);
            const g = Math.floor(parseInt(hex.substr(2, 2), 16) * damageMultiplier);
            const b = Math.floor(parseInt(hex.substr(4, 2), 16) * damageMultiplier);
            
            // Create vibrant gradient effect
            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
            gradient.addColorStop(0, `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`);
            gradient.addColorStop(0.3, `rgb(${r}, ${g}, ${b})`);
            gradient.addColorStop(0.7, `rgb(${r}, ${g}, ${b})`);
            gradient.addColorStop(1, `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`);
            
            // Fill main block with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, w, h);
            
            // Add animated shimmer effect (half speed with contrasting colors)
            const shimmerOffset = (Date.now() * 0.0025 + block.x * 0.01 + block.y * 0.01) % 1;
            const shimmerGradient = ctx.createLinearGradient(x - 20, y - 20, x + w + 20, y + h + 20);
            
            // Create contrasting shimmer color based on block color
            const shimmerR = r > 128 ? Math.max(0, r - 100) : Math.min(255, r + 100);
            const shimmerG = g > 128 ? Math.max(0, g - 100) : Math.min(255, g + 100);
            const shimmerB = b > 128 ? Math.max(0, b - 100) : Math.min(255, b + 100);
            const contrastColor = `rgba(${shimmerR}, ${shimmerG}, ${shimmerB}, 0.3)`;
            
            shimmerGradient.addColorStop(Math.max(0, shimmerOffset - 0.1), 'rgba(255, 255, 255, 0)');
            shimmerGradient.addColorStop(Math.max(0, Math.min(1, shimmerOffset - 0.05)), contrastColor);
            shimmerGradient.addColorStop(Math.max(0, Math.min(1, shimmerOffset)), 'rgba(255, 255, 255, 0.4)');
            shimmerGradient.addColorStop(Math.max(0, Math.min(1, shimmerOffset + 0.05)), contrastColor);
            shimmerGradient.addColorStop(Math.min(1, shimmerOffset + 0.1), 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = shimmerGradient;
            ctx.fillRect(x, y, w, h);
            
            // Add bright highlight on top and left edges
            const lightR = Math.min(255, r + 80);
            const lightG = Math.min(255, g + 80);
            const lightB = Math.min(255, b + 80);
            const lightColor = `rgb(${lightR}, ${lightG}, ${lightB})`;
            
            ctx.fillStyle = lightColor;
            ctx.fillRect(x, y, w, 4); // Top highlight
            ctx.fillRect(x, y, 4, h); // Left highlight
            
            // Add deep shadow on bottom and right edges
            const darkR = Math.max(0, r - 60);
            const darkG = Math.max(0, g - 60);
            const darkB = Math.max(0, b - 60);
            const darkColor = `rgb(${darkR}, ${darkG}, ${darkB})`;
            
            ctx.fillStyle = darkColor;
            ctx.fillRect(x, y + h - 4, w, 4); // Bottom shadow
            ctx.fillRect(x + w - 4, y, 4, h); // Right shadow
            
            // Add glowing border
            ctx.strokeStyle = `rgba(${Math.min(255, r + 100)}, ${Math.min(255, g + 100)}, ${Math.min(255, b + 100)}, 0.6)`;
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
            
            // Add damage/crack effects for multi-hit blocks
            if (block.maxHits > 1) {
                const damagePercent = 1 - (block.hits / block.maxHits);
                
                if (damagePercent > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    
                    // Create crack patterns based on damage
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    
                    // Light damage (25-50% damaged)
                    if (damagePercent >= 0.25) {
                        // Diagonal crack from top-left
                        ctx.beginPath();
                        ctx.moveTo(x + 2, y + 2);
                        ctx.lineTo(x + w/3, y + h/3);
                        ctx.stroke();
                        
                        // Small horizontal crack
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + 2);
                        ctx.lineTo(x + w - 4, y + 6);
                        ctx.stroke();
                    }
                    
                    // Medium damage (50-75% damaged)
                    if (damagePercent >= 0.5) {
                        ctx.lineWidth = 2;
                        
                        // Vertical crack down the middle
                        ctx.beginPath();
                        ctx.moveTo(x + w/2 + 2, y + 3);
                        ctx.lineTo(x + w/2 - 1, y + h - 3);
                        ctx.stroke();
                        
                        // Additional diagonal crack
                        ctx.beginPath();
                        ctx.moveTo(x + w - 3, y + 3);
                        ctx.lineTo(x + w/2, y + h/2);
                        ctx.stroke();
                        
                        // Add some missing chunks effect
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fillRect(x + 2, y + h - 6, 4, 4);
                        ctx.fillRect(x + w - 6, y + 2, 4, 3);
                    }
                    
                    // Heavy damage (75%+ damaged - 1-2 hits left)
                    if (damagePercent >= 0.75) {
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = '#333333';
                        
                        // Major crack network
                        ctx.beginPath();
                        ctx.moveTo(x + 1, y + h/3);
                        ctx.lineTo(x + w/3, y + h/2);
                        ctx.lineTo(x + 2*w/3, y + h/4);
                        ctx.lineTo(x + w - 1, y + 2*h/3);
                        ctx.stroke();
                        
                        // Cross crack pattern
                        ctx.beginPath();
                        ctx.moveTo(x + w/4, y + 1);
                        ctx.lineTo(x + 3*w/4, y + h - 1);
                        ctx.moveTo(x + 3*w/4, y + 1);
                        ctx.lineTo(x + w/4, y + h - 1);
                        ctx.stroke();
                        
                        // Large missing chunks
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(x + 1, y + 1, 5, 5);
                        ctx.fillRect(x + w - 6, y + h - 6, 5, 5);
                        ctx.fillRect(x + w/2 - 2, y + h - 4, 4, 3);
                        
                        // Add some dust/debris effect
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';
                        for (let i = 0; i < 6; i++) {
                            const dustX = x + Math.random() * w;
                            const dustY = y + Math.random() * h;
                            ctx.fillRect(dustX, dustY, 1, 1);
                        }
                    }
                    
                    // Extreme damage for 5-hit blocks (90%+ damaged - critical state)
                    if (damagePercent >= 0.9 && block.maxHits === 5) {
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = '#FF0000';
                        
                        // Critical crack network covering entire block
                        ctx.beginPath();
                        ctx.moveTo(x + 1, y + 1);
                        ctx.lineTo(x + w - 1, y + h - 1);
                        ctx.moveTo(x + w - 1, y + 1);
                        ctx.lineTo(x + 1, y + h - 1);
                        ctx.moveTo(x + w/2, y + 1);
                        ctx.lineTo(x + w/2, y + h - 1);
                        ctx.moveTo(x + 1, y + h/2);
                        ctx.lineTo(x + w - 1, y + h/2);
                        ctx.stroke();
                        
                        // Massive missing chunks
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(x + 1, y + 1, 6, 6);
                        ctx.fillRect(x + w - 7, y + 1, 6, 6);
                        ctx.fillRect(x + 1, y + h - 7, 6, 6);
                        ctx.fillRect(x + w - 7, y + h - 7, 6, 6);
                        ctx.fillRect(x + w/2 - 3, y + h/2 - 3, 6, 6);
                        
                        // Sparks/energy effect for 5-hit blocks
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        for (let i = 0; i < 8; i++) {
                            const sparkX = x + Math.random() * w;
                            const sparkY = y + Math.random() * h;
                            ctx.fillRect(sparkX, sparkY, 2, 2);
                        }
                    }
                    
                    ctx.restore();
                }
            }
            
            // Special rendering for metal bricks
            if (block.type === 'metal') {
                // Enhanced metallic gradient effect
                const metalGradient = ctx.createLinearGradient(x, y, x + w, y + h);
                metalGradient.addColorStop(0, 'rgba(220, 220, 255, 0.9)');
                metalGradient.addColorStop(0.2, 'rgba(180, 180, 200, 0.8)');
                metalGradient.addColorStop(0.5, 'rgba(140, 140, 160, 0.9)');
                metalGradient.addColorStop(0.8, 'rgba(100, 100, 120, 0.8)');
                metalGradient.addColorStop(1, 'rgba(60, 60, 80, 0.9)');
                
                ctx.fillStyle = metalGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add animated metallic shimmer
                const metalShimmer = (Date.now() * 0.003 + block.x * 0.02) % 1;
                const shimmerGradient = ctx.createLinearGradient(x - 15, y - 15, x + w + 15, y + h + 15);
                shimmerGradient.addColorStop(Math.max(0, metalShimmer - 0.05), 'rgba(255, 255, 255, 0)');
                shimmerGradient.addColorStop(metalShimmer, 'rgba(255, 255, 255, 0.7)');
                shimmerGradient.addColorStop(Math.min(1, metalShimmer + 0.05), 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = shimmerGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add diagonal metal pattern
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const lineY = y + (h / 5) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(x + 3, lineY);
                    ctx.lineTo(x + w - 3, lineY);
                    ctx.stroke();
                }
                
                // Add glowing border for metal
                ctx.strokeStyle = 'rgba(150, 150, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // Add metal icon/symbol with glow
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.font = 'bold 13px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('⚡', x + w/2, y + h/2 + 5);
                ctx.shadowBlur = 0;
            }
            
            // Special rendering for void blocks
            if (block.type === 'void') {
                // Deep void gradient effect
                const voidGradient = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, Math.max(w, h));
                voidGradient.addColorStop(0, 'rgba(74, 20, 140, 0.9)'); // Deep purple center
                voidGradient.addColorStop(0.6, 'rgba(26, 13, 38, 0.95)'); // Very dark purple
                voidGradient.addColorStop(1, 'rgba(0, 0, 0, 1)'); // Black edges
                
                ctx.fillStyle = voidGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add subtle shimmer effect for visibility
                const voidShimmer = (Date.now() * 0.001 + block.x * 0.01) % 1;
                const shimmerGradient = ctx.createLinearGradient(x - 10, y - 10, x + w + 10, y + h + 10);
                shimmerGradient.addColorStop(Math.max(0, voidShimmer - 0.03), 'rgba(138, 43, 226, 0)');
                shimmerGradient.addColorStop(voidShimmer, 'rgba(138, 43, 226, 0.3)');
                shimmerGradient.addColorStop(Math.min(1, voidShimmer + 0.03), 'rgba(138, 43, 226, 0)');
                
                ctx.fillStyle = shimmerGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add dark purple border
                ctx.strokeStyle = 'rgba(75, 0, 130, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // Add void symbol
                ctx.shadowColor = 'rgba(138, 43, 226, 0.8)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(186, 85, 211, 0.9)';
                ctx.font = 'bold 13px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('◯', x + w/2, y + h/2 + 5);
                ctx.shadowBlur = 0;
            }
            
            // Special rendering for lava blocks with diagonal orange/red stripes
            if (block.type === 'lava') {
                ctx.save();
                
                // Create diagonal stripe pattern
                const stripeWidth = 8;
                const stripeAngle = -45 * Math.PI / 180; // -45 degree angle
                
                // Create pattern with alternating orange and red stripes
                for (let i = -w; i < w + h; i += stripeWidth) {
                    const stripe = i;
                    
                    // Calculate stripe coordinates
                    const x1 = x + stripe;
                    const y1 = y;
                    const x2 = x + stripe + h;
                    const y2 = y + h;
                    
                    // Alternate between orange and red
                    const isOrange = Math.floor(stripe / stripeWidth) % 2 === 0;
                    ctx.fillStyle = isOrange ? '#FF6500' : '#CC2200'; // Bright orange and deep red
                    
                    // Draw diagonal stripe
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1 + stripeWidth, y1);
                    ctx.lineTo(x2 + stripeWidth, y2);
                    ctx.lineTo(x2, y2);
                    ctx.closePath();
                    
                    // Clip to block boundaries
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(x, y, w, h);
                    ctx.clip();
                    ctx.fill();
                    ctx.restore();
                }
                
                // Add animated lava glow effect
                const lavaGlow = Math.sin(Date.now() * 0.004 + block.x * 0.01) * 0.3 + 0.7;
                ctx.shadowColor = '#FF4500';
                ctx.shadowBlur = 6 * lavaGlow;
                ctx.strokeStyle = `rgba(255, 69, 0, ${lavaGlow})`;
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, w, h);
                
                // Add lava symbol with pulsing effect
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 8 * lavaGlow;
                ctx.fillStyle = `rgba(255, 215, 0, ${lavaGlow})`;
                ctx.font = 'bold 15px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('🔥', x + w/2, y + h/2 + 6);
                
                ctx.restore();
            }
            
            // Special rendering for 5-hit ultra-hard blocks (Diamond/Crystal effect)
            if (block.maxHits === 5) {
                ctx.save();
                
                // Enhanced diamond/crystal gradient effect
                const diamondGradient = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, Math.max(w, h));
                diamondGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                diamondGradient.addColorStop(0.3, 'rgba(230, 230, 250, 0.8)');
                diamondGradient.addColorStop(0.6, 'rgba(200, 200, 240, 0.7)');
                diamondGradient.addColorStop(1, 'rgba(150, 150, 200, 0.6)');
                
                ctx.fillStyle = diamondGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add animated crystal shimmer (faster than metal)
                const crystalShimmer = (Date.now() * 0.005 + block.x * 0.03) % 1;
                const crystalShimmerGradient = ctx.createLinearGradient(x - 20, y - 20, x + w + 20, y + h + 20);
                crystalShimmerGradient.addColorStop(Math.max(0, crystalShimmer - 0.08), 'rgba(255, 255, 255, 0)');
                crystalShimmerGradient.addColorStop(Math.max(0, crystalShimmer - 0.04), 'rgba(255, 255, 255, 0.4)');
                crystalShimmerGradient.addColorStop(crystalShimmer, 'rgba(255, 255, 255, 0.9)');
                crystalShimmerGradient.addColorStop(Math.min(1, crystalShimmer + 0.04), 'rgba(255, 255, 255, 0.4)');
                crystalShimmerGradient.addColorStop(Math.min(1, crystalShimmer + 0.08), 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = crystalShimmerGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add faceted crystal pattern
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Diamond facet lines
                ctx.moveTo(x + w/2, y + 2);
                ctx.lineTo(x + 2, y + h/2);
                ctx.lineTo(x + w/2, y + h - 2);
                ctx.lineTo(x + w - 2, y + h/2);
                ctx.closePath();
                ctx.stroke();
                
                // Inner facets
                ctx.beginPath();
                ctx.moveTo(x + w/4, y + h/4);
                ctx.lineTo(x + 3*w/4, y + h/4);
                ctx.lineTo(x + 3*w/4, y + 3*h/4);
                ctx.lineTo(x + w/4, y + 3*h/4);
                ctx.closePath();
                ctx.stroke();
                
                // Add prismatic rainbow border effect
                const rainbowTime = Date.now() * 0.003;
                const rainbowR = Math.floor(128 + 127 * Math.sin(rainbowTime));
                const rainbowG = Math.floor(128 + 127 * Math.sin(rainbowTime + 2));
                const rainbowB = Math.floor(128 + 127 * Math.sin(rainbowTime + 4));
                
                ctx.strokeStyle = `rgba(${rainbowR}, ${rainbowG}, ${rainbowB}, 0.8)`;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // Add crystal/diamond icon with powerful glow
                ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                ctx.shadowBlur = 12;
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('♦', x + w/2, y + h/2 + 3);
                
                // Add secondary glow
                ctx.shadowColor = `rgba(${rainbowR}, ${rainbowG}, ${rainbowB}, 0.8)`;
                ctx.shadowBlur = 8;
                ctx.fillText('♦', x + w/2, y + h/2 + 3);
                
                ctx.restore();
            }
            
            // Special rendering for treasure chest blocks
            if (block.type === 'treasure') {
                ctx.save();
                
                // Golden gradient base for treasure chest
                const treasureGradient = ctx.createLinearGradient(x, y, x + w, y + h);
                treasureGradient.addColorStop(0, 'rgba(255, 215, 0, 0.9)');    // Bright gold
                treasureGradient.addColorStop(0.3, 'rgba(255, 193, 37, 0.95)'); // Medium gold
                treasureGradient.addColorStop(0.7, 'rgba(218, 165, 32, 0.9)');  // Dark gold
                treasureGradient.addColorStop(1, 'rgba(184, 134, 11, 0.85)');   // Deep bronze-gold
                
                ctx.fillStyle = treasureGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add animated golden shimmer effect
                const treasureShimmer = (Date.now() * 0.004 + block.x * 0.03) % 1;
                const shimmerGradient = ctx.createLinearGradient(x - 20, y - 20, x + w + 20, y + h + 20);
                shimmerGradient.addColorStop(Math.max(0, treasureShimmer - 0.08), 'rgba(255, 255, 0, 0)');
                shimmerGradient.addColorStop(treasureShimmer, 'rgba(255, 255, 0, 0.6)');
                shimmerGradient.addColorStop(Math.min(1, treasureShimmer + 0.08), 'rgba(255, 255, 0, 0)');
                
                ctx.fillStyle = shimmerGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add chest details - metal bands
                ctx.fillStyle = 'rgba(139, 69, 19, 0.8)'; // Dark brown for metal bands
                ctx.fillRect(x + 2, y + h/4, w - 4, 2);     // Top band
                ctx.fillRect(x + 2, y + 3*h/4, w - 4, 2);   // Bottom band
                
                // Add chest lock/latch
                ctx.fillStyle = 'rgba(105, 105, 105, 0.9)'; // Dark gray for lock
                const lockSize = Math.min(w, h) / 4;
                ctx.fillRect(x + w/2 - lockSize/2, y + h/2 - lockSize/2, lockSize, lockSize);
                
                // Add golden glow border
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // Add treasure chest icon with glow effect
                ctx.shadowColor = 'rgba(255, 215, 0, 0.9)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.font = 'bold 12px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                
                // Show opening animation if treasure is being opened
                if (block.treasureOpening) {
                    ctx.fillText('✨', x + w/2, y + h/2 + 4);
                } else {
                    ctx.fillText('💰', x + w/2, y + h/2 + 4);
                }
                
                // Add pulsing effect for extra visibility
                const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                ctx.shadowColor = `rgba(255, 215, 0, ${pulse})`;
                ctx.shadowBlur = 6;
                ctx.fillText(block.treasureOpening ? '✨' : '💰', x + w/2, y + h/2 + 4);
                
                ctx.restore();
            }
            
            // Special rendering for shield blocks
            if (block.type === 'shield') {
                ctx.save();
                
                // Calculate shield damage percentage
                const shieldDamage = 1 - (block.shieldStrength / block.maxShieldStrength);
                
                // Base shield gradient that changes based on damage
                const intactColor = 'rgba(65, 105, 225, 0.9)';    // Royal blue when intact
                const damagedColor = 'rgba(220, 20, 60, 0.8)';     // Crimson when damaged
                
                // Interpolate between intact and damaged colors
                const r = Math.floor(65 + (220 - 65) * shieldDamage);
                const g = Math.floor(105 + (20 - 105) * shieldDamage);
                const b = Math.floor(225 + (60 - 225) * shieldDamage);
                
                const shieldGradient = ctx.createLinearGradient(x, y, x + w, y + h);
                shieldGradient.addColorStop(0, `rgba(${r + 30}, ${g + 30}, ${b + 30}, 0.95)`);
                shieldGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
                shieldGradient.addColorStop(1, `rgba(${r - 30}, ${g - 20}, ${b - 20}, 0.85)`);
                
                ctx.fillStyle = shieldGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add energy field shimmer effect
                const shieldShimmer = (Date.now() * 0.005 + block.x * 0.02) % 1;
                const shimmerGradient = ctx.createLinearGradient(x - 15, y - 15, x + w + 15, y + h + 15);
                shimmerGradient.addColorStop(Math.max(0, shieldShimmer - 0.06), 'rgba(255, 255, 255, 0)');
                shimmerGradient.addColorStop(shieldShimmer, 'rgba(255, 255, 255, 0.4)');
                shimmerGradient.addColorStop(Math.min(1, shieldShimmer + 0.06), 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = shimmerGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add shield pattern - hexagonal grid
                ctx.strokeStyle = `rgba(${255 - r}, ${255 - g}, ${255 - b}, 0.6)`;
                ctx.lineWidth = 1;
                
                // Draw hexagonal pattern
                const hexSize = Math.min(w, h) / 6;
                for (let i = 0; i < 3; i++) {
                    const hexX = x + (w / 4) * (i + 1);
                    const hexY = y + h / 2;
                    
                    ctx.beginPath();
                    for (let j = 0; j < 6; j++) {
                        const angle = (j * Math.PI) / 3;
                        const px = hexX + hexSize * Math.cos(angle);
                        const py = hexY + hexSize * Math.sin(angle);
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                
                // Add damage cracks based on shield strength
                if (shieldDamage > 0.3) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.lineWidth = Math.floor(shieldDamage * 3) + 1;
                    
                    // Draw cracks
                    ctx.beginPath();
                    ctx.moveTo(x + 2, y + h * 0.3);
                    ctx.lineTo(x + w * 0.4, y + h * 0.7);
                    if (shieldDamage > 0.6) {
                        ctx.moveTo(x + w * 0.6, y + 2);
                        ctx.lineTo(x + w - 2, y + h * 0.5);
                    }
                    if (shieldDamage > 0.8) {
                        ctx.moveTo(x + w * 0.2, y + h - 2);
                        ctx.lineTo(x + w * 0.8, y + h * 0.2);
                    }
                    ctx.stroke();
                }
                
                // Add pulsing border based on shield strength
                const pulseIntensity = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${pulseIntensity})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // Add shield icon with appropriate color
                ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.8)`;
                ctx.shadowBlur = 8;
                ctx.fillStyle = `rgba(${255 - r}, ${255 - g}, ${255 - b}, 1)`;
                ctx.font = 'bold 13px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('🛡', x + w/2, y + h/2 + 5);
                
                ctx.restore();
            }
            
            // Special rendering for magnetic blocks
            if (block.type === 'magnetic_attract' || block.type === 'magnetic_repel') {
                ctx.save();
                
                const isAttract = block.magneticPolarity === 'attract';
                const baseColor = isAttract ? '#DC143C' : '#00CED1'; // Red for attract, cyan for repel
                const pulseTime = Date.now() * 0.006;
                
                // Create magnetic field gradient
                const magneticGradient = ctx.createRadialGradient(
                    x + w/2, y + h/2, 0,
                    x + w/2, y + h/2, Math.max(w, h) / 2
                );
                
                if (isAttract) {
                    magneticGradient.addColorStop(0, 'rgba(220, 20, 60, 0.9)');   // Deep crimson center
                    magneticGradient.addColorStop(0.6, 'rgba(139, 0, 0, 0.8)');   // Dark red
                    magneticGradient.addColorStop(1, 'rgba(72, 0, 0, 0.7)');      // Very dark red
                } else {
                    magneticGradient.addColorStop(0, 'rgba(0, 206, 209, 0.9)');   // Bright cyan center
                    magneticGradient.addColorStop(0.6, 'rgba(0, 139, 139, 0.8)'); // Dark cyan
                    magneticGradient.addColorStop(1, 'rgba(0, 100, 100, 0.7)');   // Very dark cyan
                }
                
                ctx.fillStyle = magneticGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add magnetic field effect animation
                const fieldPulse = Math.sin(pulseTime) * 0.3 + 0.7;
                const fieldGradient = ctx.createRadialGradient(
                    x + w/2, y + h/2, 0,
                    x + w/2, y + h/2, Math.max(w, h)
                );
                
                fieldGradient.addColorStop(0, `rgba(255, 255, 255, ${fieldPulse * 0.3})`);
                fieldGradient.addColorStop(0.5, `rgba(255, 255, 255, ${fieldPulse * 0.1})`);
                fieldGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = fieldGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Draw magnetic field lines
                ctx.strokeStyle = `rgba(255, 255, 255, ${fieldPulse * 0.6})`;
                ctx.lineWidth = 1;
                
                const centerX = x + w/2;
                const centerY = y + h/2;
                const fieldLines = isAttract ? 6 : 8; // Attract has fewer, focused lines; repel has more scattered lines
                
                ctx.beginPath();
                for (let i = 0; i < fieldLines; i++) {
                    const angle = (i * Math.PI * 2) / fieldLines + pulseTime * 0.5;
                    const innerRadius = Math.min(w, h) / 6;
                    const outerRadius = Math.min(w, h) / 3;
                    
                    if (isAttract) {
                        // Attract: lines point inward
                        const startX = centerX + Math.cos(angle) * outerRadius;
                        const startY = centerY + Math.sin(angle) * outerRadius;
                        const endX = centerX + Math.cos(angle) * innerRadius;
                        const endY = centerY + Math.sin(angle) * innerRadius;
                        
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        
                        // Add arrowhead pointing inward
                        const arrowAngle = angle + Math.PI;
                        ctx.lineTo(endX + Math.cos(arrowAngle - 0.3) * 3, endY + Math.sin(arrowAngle - 0.3) * 3);
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX + Math.cos(arrowAngle + 0.3) * 3, endY + Math.sin(arrowAngle + 0.3) * 3);
                    } else {
                        // Repel: lines point outward
                        const startX = centerX + Math.cos(angle) * innerRadius;
                        const startY = centerY + Math.sin(angle) * innerRadius;
                        const endX = centerX + Math.cos(angle) * outerRadius;
                        const endY = centerY + Math.sin(angle) * outerRadius;
                        
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        
                        // Add arrowhead pointing outward
                        ctx.lineTo(endX + Math.cos(angle - 2.8) * 3, endY + Math.sin(angle - 2.8) * 3);
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX + Math.cos(angle + 2.8) * 3, endY + Math.sin(angle + 2.8) * 3);
                    }
                }
                ctx.stroke();
                
                // Add pulsing border
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 2;
                ctx.globalAlpha = fieldPulse;
                ctx.strokeRect(x, y, w, h);
                ctx.globalAlpha = 1;
                
                // Add magnetic symbol
                ctx.shadowColor = baseColor;
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.font = 'bold 12px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                
                // Use different symbols for attract vs repel
                const symbol = isAttract ? '🧲' : '⚡';
                ctx.fillText(symbol, centerX, centerY + 4);
                
                // Add secondary glow
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(symbol, centerX, centerY + 4);
                
                ctx.restore();
            }
            
            // Special rendering for boss blocks
            if (block.isBoss) {
                ctx.save();
                
                // Enhanced boss glow effect
                const bossGlow = Math.sin(Date.now() * 0.003 + block.x * 0.005) * 0.4 + 0.6;
                ctx.shadowColor = block.glowColor || '#FFD700';
                ctx.shadowBlur = 12 * bossGlow;
                
                // Boss border with pulsing effect
                ctx.strokeStyle = block.glowColor || '#FFD700';
                ctx.lineWidth = 3;
                ctx.globalAlpha = bossGlow;
                ctx.strokeRect(x - 1, y - 1, w + 2, h + 2);
                ctx.globalAlpha = 1;
                
                // Add boss aura
                const auraGradient = ctx.createRadialGradient(
                    x + w/2, y + h/2, 0,
                    x + w/2, y + h/2, Math.max(w, h) * 0.8
                );
                const glowColor = block.glowColor || '#FFD700';
                auraGradient.addColorStop(0, glowColor + '40');
                auraGradient.addColorStop(0.7, glowColor + '20');
                auraGradient.addColorStop(1, glowColor + '00');
                
                ctx.fillStyle = auraGradient;
                ctx.fillRect(x - 5, y - 5, w + 10, h + 10);
                
                // Boss type indicators
                if (block.type) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 10px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    
                    let symbol = '💀';
                    switch (block.type) {
                        case 'boss_wall':
                        case 'boss_core':
                            symbol = '🏰';
                            break;
                        case 'boss_swarm':
                        case 'boss_queen':
                            symbol = '🌀';
                            break;
                        case 'boss_void':
                        case 'boss_void_core':
                            symbol = '🕳';
                            break;
                        case 'boss_master':
                        case 'boss_final':
                            symbol = '👑';
                            break;
                    }
                    
                    ctx.shadowColor = '#000000';
                    ctx.shadowBlur = 3;
                    ctx.fillText(symbol, x + w/2, y + h/2 + 3);
                }
                
                // Mobile boss block movement trail
                if (block.mobile && block.isReorganizing) {
                    const progress = Math.min(1, (Date.now() - (block.reorganizeStartTime || Date.now())) / 2000);
                    if (block.targetX && block.targetY) {
                        const currentX = block.x + (block.targetX - block.x) * progress;
                        const currentY = block.y + (block.targetY - block.y) * progress;
                        
                        // Update block position
                        block.x = currentX;
                        block.y = currentY;
                        
                        if (progress >= 1) {
                            block.isReorganizing = false;
                            block.targetX = null;
                            block.targetY = null;
                        }
                    }
                }
                
                // Regenerating boss block effect
                if (block.regenerating) {
                    const regenTime = Date.now() - (block.regenStartTime || Date.now());
                    const regenProgress = Math.min(1, regenTime / 1000); // 1 second regeneration
                    
                    ctx.fillStyle = `rgba(0, 255, 0, ${0.5 - regenProgress * 0.5})`;
                    ctx.fillRect(x, y, w, h * regenProgress);
                    
                    if (regenProgress >= 1) {
                        block.regenerating = false;
                        block.regenStartTime = null;
                    }
                }
                
                ctx.restore();
            }
            
            // Optional: Show hits remaining for multi-hit blocks (now that we have visual damage)
            // Uncomment if you still want numbers in addition to visual damage
            /*
            if (block.maxHits > 1 && block.type !== 'metal') {
                ctx.save();
                ctx.shadowColor = '#FFFFFF';
                ctx.shadowBlur = 6;
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 11px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(block.hits.toString(), x + w/2, y + h/2 + 4);
                
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText(block.hits.toString(), x + w/2, y + h/2 + 4);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(block.hits.toString(), x + w/2, y + h/2 + 4);
                ctx.restore();
            }
            */
        }

        function drawPaddle() {
            if (!ctx) return;
            let paddleColor = '#4ECDC4'; // Teal color like original
            
            // Change color based on power-ups
            if (paddle.laser) {
                paddleColor = '#FFD700'; // Gold for laser
            } else if (paddle.sticky) {
                paddleColor = '#90EE90'; // Light green for sticky
            }
            
            const x = paddle.x;
            const y = paddle.y;
            const w = paddle.width;
            const h = paddle.height;
            
            // Parse the paddle color for 3D effect
            const hex = paddleColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Create lighter and darker variants
            const lightR = Math.min(255, r + 60);
            const lightG = Math.min(255, g + 60);
            const lightB = Math.min(255, b + 60);
            const darkR = Math.max(0, r - 40);
            const darkG = Math.max(0, g - 40);
            const darkB = Math.max(0, b - 40);
            
            const lightColor = `rgb(${lightR}, ${lightG}, ${lightB})`;
            const darkColor = `rgb(${darkR}, ${darkG}, ${darkB})`;
            
            // Fill main paddle
            ctx.fillStyle = paddleColor;
            ctx.fillRect(x, y, w, h);
            
            // Add highlight on top and left edges
            ctx.fillStyle = lightColor;
            ctx.fillRect(x, y, w, 2); // Top highlight
            ctx.fillRect(x, y, 2, h); // Left highlight
            
            // Add shadow on bottom and right edges
            ctx.fillStyle = darkColor;
            ctx.fillRect(x, y + h - 2, w, 2); // Bottom shadow
            ctx.fillRect(x + w - 2, y, 2, h); // Right shadow
            
            // Draw power-up indicators
            if (paddle.laser) {
                ctx.fillStyle = '#FFD700';
                // Dynamic turret positioning based on paddle width
                // For default paddle (188px), use 25% and 75% positions
                // For other sizes, position turrets 10px from edges
                let leftTurretX, rightTurretX;
                if (Math.abs(w - paddle.originalWidth) < 1) {
                    // Default size - use original 25% and 75% positions
                    leftTurretX = x + w * 0.25 - 2;
                    rightTurretX = x + w * 0.75 - 2;
                } else {
                    // Non-default size - position near edges
                    leftTurretX = x + 10;
                    rightTurretX = x + w - 14;
                }
                ctx.fillRect(leftTurretX, y - 5, 4, 5);
                ctx.fillRect(rightTurretX, y - 5, 4, 5);
            }
        }

        function drawBall(ball) {
            if (!ctx) return;
            // Draw ball trail
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < ball.trail.length; i++) {
                const trailPoint = ball.trail[i];
                const alpha = (i / ball.trail.length) * 0.3;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(trailPoint.x, trailPoint.y, ball.radius * (0.5 + i / ball.trail.length * 0.5), 0, Math.PI * 2);
                let trailColor = '#888888';
                
                // Check for elemental trail color first
                if (ball.trailColor) {
                    trailColor = ball.trailColor;
                } else if (ball.mega && ball.rocket) {
                    trailColor = '#FF4500';
                } else if (ball.mega) {
                    trailColor = '#FF6B6B';
                } else if (ball.rocket) {
                    trailColor = '#FFD700';
                } else if (ball.slow) {
                    trailColor = '#00CED1';
                }
                ctx.fillStyle = trailColor;
                ctx.fill();
                ctx.closePath();
            }
            ctx.globalAlpha = 1.0;
            
            // Draw main ball
            let ballColor = '#888888';
            let ballRadius = ball.radius;
            let highlightColor = '#BBBBBB';
            
            // Check for elemental color first (highest priority)
            if (ball.color) {
                ballColor = ball.color;
                // Set appropriate highlight based on element
                if (ball.element === 'fire') {
                    highlightColor = '#FFA500';
                } else if (ball.element === 'ice') {
                    highlightColor = '#E0FFFF';
                } else if (ball.element === 'lightning') {
                    highlightColor = '#FFFF99';
                } else if (ball.element === 'void') {
                    highlightColor = '#9370DB';
                } else {
                    highlightColor = '#BBBBBB';
                }
            } else if (ball.mega && ball.rocket) {
                // Combined rocket + explosive: orange-red gradient effect
                ballColor = '#FF4500';
                ballRadius = ball.radius * 1.2;
                highlightColor = '#FF7F50';
            } else if (ball.mega) {
                ballColor = '#FF6B6B';
                ballRadius = ball.radius * 1.2;
                highlightColor = '#FF9999';
            } else if (ball.rocket) {
                ballColor = '#FFD700';
                ballRadius = ball.radius;
                highlightColor = '#FFFF99';
            } else if (ball.slow) {
                ballColor = '#00CED1';  // Dark turquoise for slow ball
                ballRadius = ball.radius * 0.9; // Slightly smaller
                highlightColor = '#87CEEB';
            } else if (ball.speedUp) {
                ballColor = '#A8E6CF';  // Light green for speed ball (matches powerup feedback color)
                ballRadius = ball.radius * 1.1; // Slightly larger
                highlightColor = '#90EE90';
            }
            
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = ballColor;
            ctx.fill();
            ctx.closePath();
            
            // Add subtle highlight for 3D effect
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, ballRadius - 3, 0, Math.PI * 2);
            ctx.fillStyle = highlightColor;
            ctx.fill();
            ctx.closePath();
            
            // Add rocket trail effect
            if (ball.rocket) {
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#FF4500';
                
                // Draw rocket exhaust
                const angle = Math.atan2(ball.dy, ball.dx);
                const exhaustLength = 15;
                const exhaustWidth = 6;
                
                ctx.translate(ball.x, ball.y);
                ctx.rotate(angle + Math.PI);
                
                ctx.beginPath();
                ctx.ellipse(exhaustLength/2, 0, exhaustLength/2, exhaustWidth/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        function drawGameUI() {
            // Update HTML UI elements instead of drawing on canvas
            if (gameStarted && gameRunning) {
                // Update left panel
                document.getElementById('levelDisplay').textContent = `Level: ${level}/100`;
                
                const levelName = (levelNames && Array.isArray(levelNames) && levelNames[level - 1]) ? levelNames[level - 1] : `Level ${level}`;
                document.getElementById('levelNameDisplay').textContent = levelName;
                
                document.getElementById('livesDisplay').textContent = `♥ Lives: ${lives}`;
                
                // Banking info (show from level 3+)
                const bankingDisplay = document.getElementById('bankingDisplay');
                if (level >= 3) {
                    bankingDisplay.style.display = 'block';
                    document.getElementById('bankedAmount').textContent = `💰 Banked: ${scoreBanking.bankedScore.toLocaleString()}`;
                    
                    if (scoreBanking.bankedScore > 0) {
                        const levelsProgressed = Math.max(0, level - scoreBanking.lastBankLevel);
                        const interestRate = scoreBanking.interestRate * levelsProgressed;
                        const potentialInterest = Math.floor(scoreBanking.bankedScore * interestRate);
                        document.getElementById('interestAmount').textContent = `📈 Interest: +${potentialInterest.toLocaleString()}`;
                        document.getElementById('bankingControls').textContent = 'B=Bank V=Withdraw';
                    } else {
                        document.getElementById('interestAmount').textContent = '';
                        document.getElementById('bankingControls').textContent = 'B=Bank Score';
                    }
                } else {
                    bankingDisplay.style.display = 'none';
                }
                
                // Update right panel
                document.getElementById('scoreDisplay').textContent = `Score: ${score.toLocaleString()}`;
                
                // Active combo multiplier display
                const comboDisplay = document.getElementById('comboDisplay');
                if (gameState.tempComboMultiplier > 1) {
                    const timeLeft = gameState.tempComboTimer / 1000;
                    comboDisplay.style.display = 'block';
                    comboDisplay.innerHTML = `${gameState.tempComboMultiplier}× COMBO<br>${timeLeft.toFixed(1)}s`;
                } else {
                    comboDisplay.style.display = 'none';
                }
                
                // Temporary events
                const eventDisplay = document.getElementById('eventDisplay');
                if (temporaryEvents.active) {
                    const event = temporaryEvents.active.data;
                    const timeLeft = temporaryEvents.active.timeRemaining / 1000;
                    eventDisplay.style.display = 'block';
                    eventDisplay.innerHTML = `${event.icon} ${event.name}<br>${timeLeft.toFixed(1)}s<br><small>${event.description}</small>`;
                } else {
                    eventDisplay.style.display = 'none';
                }
                
                // Also update fullscreen UI if in fullscreen mode
                if (isFullscreen) {
                    updateFullscreenUI();
                }
                
                // Boss health bar still drawn on canvas if active
                if (bossSystem.active && bossSystem.currentBoss) {
                    drawBossHealthBar();
                }
            }
            
            // Draw combo indicator
            drawComboIndicator();
        }
        
        function updateFullscreenUI() {
            // Update fullscreen left panel
            const fsLevelEl = document.getElementById('fs-level-display');
            if (fsLevelEl) fsLevelEl.textContent = `Level: ${level}/100`;
            
            const levelName = (levelNames && Array.isArray(levelNames) && levelNames[level - 1]) ? levelNames[level - 1] : `Level ${level}`;
            const fsLevelNameEl = document.getElementById('fs-level-name');
            if (fsLevelNameEl) fsLevelNameEl.textContent = levelName;
            
            const fsLivesEl = document.getElementById('fs-lives-display');
            if (fsLivesEl) fsLivesEl.textContent = `♥ Lives: ${lives}`;
            
            // Banking info (show from level 3+)
            const fsBankingDisplay = document.getElementById('fs-banking-display');
            if (fsBankingDisplay) {
                if (level >= 3) {
                    fsBankingDisplay.style.display = 'block';
                    const fsBankedAmountEl = document.getElementById('fs-banked-amount');
                    if (fsBankedAmountEl) fsBankedAmountEl.textContent = `💰 Banked: ${scoreBanking.bankedScore.toLocaleString()}`;
                    
                    if (scoreBanking.bankedScore > 0) {
                        const levelsProgressed = Math.max(0, level - scoreBanking.lastBankLevel);
                        const interestRate = scoreBanking.interestRate * levelsProgressed;
                        const potentialInterest = Math.floor(scoreBanking.bankedScore * interestRate);
                        const fsInterestEl = document.getElementById('fs-interest-amount');
                        const fsControlsEl = document.getElementById('fs-banking-controls');
                        if (fsInterestEl) fsInterestEl.textContent = `📈 Interest: +${potentialInterest.toLocaleString()}`;
                        if (fsControlsEl) fsControlsEl.textContent = 'B=Bank V=Withdraw';
                    } else {
                        const fsInterestEl = document.getElementById('fs-interest-amount');
                        const fsControlsEl = document.getElementById('fs-banking-controls');
                        if (fsInterestEl) fsInterestEl.textContent = '';
                        if (fsControlsEl) fsControlsEl.textContent = 'B=Bank Score';
                    }
                } else {
                    fsBankingDisplay.style.display = 'none';
                }
            }
            
            // Update fullscreen right panel
            const fsScoreEl = document.getElementById('fs-score-display');
            if (fsScoreEl) fsScoreEl.textContent = `Score: ${score.toLocaleString()}`;
            
            // Active combo multiplier display
            const fsComboDisplay = document.getElementById('fs-combo-display');
            if (fsComboDisplay) {
                if (gameState.tempComboMultiplier > 1) {
                    const timeLeft = gameState.tempComboTimer / 1000;
                    fsComboDisplay.style.display = 'block';
                    fsComboDisplay.innerHTML = `${gameState.tempComboMultiplier}× COMBO<br>${timeLeft.toFixed(1)}s`;
                } else {
                    fsComboDisplay.style.display = 'none';
                }
            }
            
            // Temporary events
            const fsEventDisplay = document.getElementById('fs-event-display');
            if (fsEventDisplay) {
                if (temporaryEvents.active) {
                    const event = temporaryEvents.active.data;
                    const timeLeft = temporaryEvents.active.timeRemaining / 1000;
                    fsEventDisplay.style.display = 'block';
                    fsEventDisplay.innerHTML = `${event.icon} ${event.name}<br>${timeLeft.toFixed(1)}s<br><small>${event.description}</small>`;
                } else {
                    fsEventDisplay.style.display = 'none';
                }
            }
        }
        
        function drawComboIndicator() {
            // Draw enhanced combo indicator with scoring preview
            if (gameState.combo > 1) {
                if (!ctx) return;
                ctx.save();
                // Reset transform to ensure no interference with game elements
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Enhanced combo display with fixed positioning and color effects
                const comboMultiplier = Math.min(gameState.combo, 500);
                
                // Color progression: gold -> orange -> red -> purple -> white for extreme combos
                let comboColor = '#FFD700'; // Gold
                if (comboMultiplier >= 5) comboColor = '#FF8C00'; // Orange
                if (comboMultiplier >= 25) comboColor = '#FF4500'; // Red-orange
                if (comboMultiplier >= 100) comboColor = '#8B00FF'; // Purple
                if (comboMultiplier >= 250) comboColor = '#FFFFFF'; // White for extreme combos
                
                ctx.fillStyle = comboColor;
                ctx.font = 'bold 16px "Press Start 2P", monospace'; // Fixed size - no more scaling
                ctx.textAlign = 'center';
                
                // Add glow effect for high combos
                if (comboMultiplier >= 5) {
                    ctx.shadowColor = comboColor;
                    ctx.shadowBlur = 15; // Fixed glow intensity
                }
                
                // Show combo multiplier and point preview - ABSOLUTELY FIXED POSITION
                const nextPoints = 10 * gameState.multiplier * comboMultiplier;
                const comboX = Math.floor(canvas.width / 2); // Ensure integer pixel position
                const comboY = 44; // Fixed Y position
                ctx.fillText(`${gameState.combo}x COMBO! (+${nextPoints} pts)`, comboX, comboY);
                
                // Bright core for very high combos
                if (comboMultiplier >= 50) {
                    ctx.shadowBlur = 20; // Fixed glow intensity
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px "Press Start 2P", monospace'; // Fixed size
                    ctx.fillText(`${gameState.combo}x COMBO!`, comboX, comboY);
                }
                
                ctx.restore();
                // Ensure transform is fully reset after combo display
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            
            // Draw power-up timer on right side with retro styling
            if (paddle.powerUpTimer > 0) {
                const timerWidth = 100; // Reduced width to fit better on right
                const timerHeight = 10;
                const timerX = canvas.width - timerWidth - 25;
                // Fixed UI positioning
                const blockAreaBottom = 280;
                const timerY = blockAreaBottom + 15; // Position between score and POWER-UP label
                
                const maxTimer = paddle.sticky ? 900 : 600;
                const progress = Math.min(1.0, paddle.powerUpTimer / maxTimer); // Clamp to prevent overflow
                
                // Timer background with neon border
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(timerX, timerY, timerWidth, timerHeight);
                
                // Neon border
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(timerX, timerY, timerWidth, timerHeight);
                
                // Timer progress with glow (clamped to prevent overflow)
                ctx.save();
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#FFD700';
                const progressWidth = Math.min((timerWidth - 4), (timerWidth - 4) * progress);
                ctx.fillRect(timerX + 2, timerY + 2, progressWidth, timerHeight - 4);
                ctx.restore();
                
                // Timer label on right side
                ctx.save();
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 5;
                ctx.fillStyle = '#00FFFF';
                ctx.font = 'bold 11px "Press Start 2P", monospace';
                ctx.textAlign = 'right';
                ctx.fillText('POWER-UP', canvas.width - 25, 32);
                ctx.restore();
            }
        }
        
        // Boss health bar drawing function
        function drawBossHealthBar() {
                if (!ctx || !canvas) return;
                const boss = bossSystem.currentBoss;
                const healthPercent = bossSystem.bossHealthBar.current / bossSystem.bossHealthBar.max;
                
                // Position at top center of screen
                const barWidth = 400;
                const barHeight = 20;
                const barX = (canvas.width - barWidth) / 2;
                const barY = 20;
                
                ctx.save();
                
                // Boss name and phase
                ctx.fillStyle = boss.color;
                ctx.shadowColor = boss.glowColor;
                ctx.shadowBlur = 10;
                ctx.font = 'bold 12px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${boss.icon} ${boss.name} - Phase ${bossSystem.phase}/${bossDefinitions[level].phases.length}`, 
                           canvas.width / 2, barY - 5);
                
                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(barX - 2, barY + 15 - 2, barWidth + 4, barHeight + 4);
                
                // Health bar border
                ctx.strokeStyle = boss.glowColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY + 15, barWidth, barHeight);
                
                // Health bar fill
                const healthWidth = Math.max(0, barWidth * healthPercent);
                
                // Create gradient based on health percentage
                const healthGradient = ctx.createLinearGradient(barX, barY + 15, barX + barWidth, barY + 15);
                if (healthPercent > 0.6) {
                    healthGradient.addColorStop(0, '#FF6B6B');
                    healthGradient.addColorStop(1, '#FF4444');
                } else if (healthPercent > 0.3) {
                    healthGradient.addColorStop(0, '#FFB366');
                    healthGradient.addColorStop(1, '#FF8C42');
                } else {
                    healthGradient.addColorStop(0, '#66FF66');
                    healthGradient.addColorStop(1, '#44AA44');
                }
                
                ctx.fillStyle = healthGradient;
                ctx.fillRect(barX, barY + 15, healthWidth, barHeight);
                
                // Health text
                ctx.fillStyle = '#FFFFFF';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 3;
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.ceil(bossSystem.bossHealthBar.current)} / ${bossSystem.bossHealthBar.max}`, 
                           canvas.width / 2, barY + 27);
                
                // Phase transition timer
                if (bossSystem.phaseTransitionTimer > 0) {
                    const transitionPercent = bossSystem.phaseTransitionTimer / 3000;
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.font = 'bold 16px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Phase ${bossSystem.phase} Starting...`, canvas.width / 2, canvas.height / 2);
                    
                    // Countdown bar
                    const countdownWidth = 200;
                    const countdownHeight = 6;
                    const countdownX = (canvas.width - countdownWidth) / 2;
                    const countdownY = canvas.height / 2 + 30;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(countdownX, countdownY, countdownWidth, countdownHeight);
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(countdownX, countdownY, countdownWidth * (1 - transitionPercent), countdownHeight);
                }
                
                ctx.restore();
            }
            
            // Draw upgrade shop overlay
            if (upgradeShop.shopOpen) {
                drawUpgradeShopOverlay();
            }
            
            // Draw achievement gallery overlay
            if (achievementGallery.galleryOpen) {
                drawAchievementGallery();
            }
            
            // Draw challenge mode selection overlay
            drawChallengeModeSelection();
            
            // Draw challenge mode HUD
            drawChallengeModeHUD();
            
            // Draw mystical powers HUD
            drawMysticalPowersHUD();
            
            // Draw mystical powers selection menu
            if (mysticalPowers.selectionMenuOpen) {
                drawMysticalPowersSelectionMenu();
            }
            
            // Draw world map HUD
            drawWorldMapHUD();
            
            // Draw world map overlay
            drawWorldMapOverlay();
            
            // Draw analytics overlays
            drawPlayerProfileOverlay();
            drawReplayBrowser();
            
            // Rest of draw function continues here
        }
        
        // Draw upgrade shop overlay UI - moved to global scope
        function drawUpgradeShopOverlay() {
                if (!upgradeShop.shopOpen) return;
                if (!ctx) return;
                
                ctx.save();
                
                // Semi-transparent background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Shop title
                ctx.fillStyle = '#FFD700';
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 15;
                ctx.font = 'bold 24px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('UPGRADE SHOP', canvas.width / 2, 50);
                
                // Upgrade points display
                ctx.fillStyle = '#00FFFF';
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 10;
                ctx.font = 'bold 16px "Press Start 2P", monospace';
                ctx.fillText(`💎 ${upgradeShop.upgradePoints} Points`, canvas.width / 2, 80);
                
                // Category tabs
                const categories = [
                    { id: 'paddle', name: 'Paddle', key: '1' },
                    { id: 'ball', name: 'Ball', key: '2' },
                    { id: 'meta', name: 'Meta', key: '3' },
                    { id: 'special', name: 'Special', key: '4' }
                ];
                
                const tabWidth = 120;
                const tabHeight = 30;
                const tabSpacing = 10;
                const totalTabWidth = (tabWidth + tabSpacing) * categories.length - tabSpacing;
                const tabStartX = (canvas.width - totalTabWidth) / 2;
                
                categories.forEach((category, index) => {
                    const tabX = tabStartX + (tabWidth + tabSpacing) * index;
                    const tabY = 110;
                    const isSelected = upgradeShop.selectedCategory === category.id;
                    
                    // Tab background
                    ctx.fillStyle = isSelected ? 'rgba(255, 215, 0, 0.3)' : 'rgba(100, 100, 100, 0.3)';
                    ctx.fillRect(tabX, tabY, tabWidth, tabHeight);
                    
                    // Tab border
                    ctx.strokeStyle = isSelected ? '#FFD700' : '#CCCCCC';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(tabX, tabY, tabWidth, tabHeight);
                    
                    // Tab text
                    ctx.fillStyle = isSelected ? '#FFD700' : '#FFFFFF';
                    ctx.shadowColor = isSelected ? '#FFD700' : '#000000';
                    ctx.shadowBlur = isSelected ? 10 : 3;
                    ctx.font = 'bold 12px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${category.key}: ${category.name}`, tabX + tabWidth / 2, tabY + 20);
                });
                
                // Get upgrades for selected category
                const categoryUpgrades = Object.keys(upgradeDefinitions)
                    .filter(id => upgradeDefinitions[id].category === upgradeShop.selectedCategory)
                    .slice(0, 4); // Limit to 4 upgrades per category
                
                // Draw upgrade slots
                const slotWidth = 180;
                const slotHeight = 120;
                const slotSpacing = 20;
                const slotsPerRow = 2;
                const totalSlotWidth = (slotWidth + slotSpacing) * slotsPerRow - slotSpacing;
                const slotStartX = (canvas.width - totalSlotWidth) / 2;
                const slotStartY = 170;
                
                categoryUpgrades.forEach((upgradeId, index) => {
                    const row = Math.floor(index / slotsPerRow);
                    const col = index % slotsPerRow;
                    const slotX = slotStartX + (slotWidth + slotSpacing) * col;
                    const slotY = slotStartY + (slotHeight + slotSpacing) * row;
                    
                    const upgrade = upgradeShop.upgrades[upgradeId];
                    const definition = upgradeDefinitions[upgradeId];
                    const cost = getUpgradeCost(upgradeId);
                    const canAfford = cost && upgradeShop.upgradePoints >= cost;
                    const isMaxLevel = upgrade.level >= upgrade.maxLevel;
                    
                    // Slot background
                    let bgColor = 'rgba(50, 50, 50, 0.8)';
                    if (isMaxLevel) bgColor = 'rgba(0, 100, 0, 0.4)';
                    else if (canAfford) bgColor = 'rgba(100, 100, 0, 0.4)';
                    else if (cost) bgColor = 'rgba(100, 50, 50, 0.4)';
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(slotX, slotY, slotWidth, slotHeight);
                    
                    // Slot border
                    let borderColor = '#666666';
                    if (isMaxLevel) borderColor = '#00AA00';
                    else if (canAfford) borderColor = '#AAAA00';
                    else if (cost) borderColor = '#AA5555';
                    
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(slotX, slotY, slotWidth, slotHeight);
                    
                    // Purchase key
                    const purchaseKeys = ['A', 'S', 'D', 'F'];
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 10px "Press Start 2P", monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`[${purchaseKeys[index]}]`, slotX + 5, slotY + 15);
                    
                    // Upgrade icon and name
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 14px "Press Start 2P", monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${definition.icon} ${definition.name}`, slotX + 10, slotY + 35);
                    
                    // Current level
                    ctx.fillStyle = upgrade.level > 0 ? '#00FF00' : '#CCCCCC';
                    ctx.font = 'bold 10px "Press Start 2P", monospace';
                    ctx.fillText(`Level ${upgrade.level}/${upgrade.maxLevel}`, slotX + 10, slotY + 50);
                    
                    // Effect description
                    ctx.fillStyle = '#CCCCCC';
                    ctx.font = 'bold 8px "Press Start 2P", monospace';
                    const effectText = definition.effect(upgrade.level);
                    const lines = wrapText(ctx, effectText, slotWidth - 20);
                    lines.forEach((line, lineIndex) => {
                        ctx.fillText(line, slotX + 10, slotY + 65 + lineIndex * 10);
                    });
                    
                    // Cost or max level indicator
                    if (isMaxLevel) {
                        ctx.fillStyle = '#00FF00';
                        ctx.font = 'bold 10px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('MAX LEVEL', slotX + slotWidth / 2, slotY + slotHeight - 10);
                    } else if (cost) {
                        ctx.fillStyle = canAfford ? '#FFFF00' : '#FF6666';
                        ctx.font = 'bold 10px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(`💎 ${cost} Points`, slotX + slotWidth / 2, slotY + slotHeight - 10);
                    }
                });
                
                // Instructions
                ctx.fillStyle = '#FFFFFF';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 3;
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('1-4: Change Category  •  A/S/D/F: Purchase  •  U/Q: Close', canvas.width / 2, canvas.height - 20);
                
                ctx.restore();
            }
            
            // wrapText function moved to global scope
            
            // Draw upgrade shop overlay
            if (upgradeShop.shopOpen) {
                drawUpgradeShopOverlay();
            }
            
            // Draw achievement gallery overlay
            if (achievementGallery.galleryOpen) {
                drawAchievementGallery();
            }
            
            // Draw challenge mode selection overlay
            drawChallengeModeSelection();
            
            // Draw challenge mode HUD
            drawChallengeModeHUD();
            
            // Draw mystical powers HUD
            drawMysticalPowersHUD();
            
            // Draw mystical powers selection menu
            drawMysticalSelectionMenu();
            
            // Draw world map HUD
            drawWorldMapHUD();
            
            // Draw world map overlay
            drawWorldMapOverlay();
            
            // Draw analytics overlays
            drawPlayerProfileOverlay();
            drawReplayBrowser();
            
            // Draw overlays (start screen, game over, level complete, etc.)
            if (!gameStarted || gameOverlay.active) {
                if (!ctx) {
                    console.error('ctx became undefined during draw execution');
                    return;
                }
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Drawing overlay or start screen
                
                if (!gameStarted && !gameOverlay.active) {
                    // Original start screen
                    // Drawing start screen
                    ctx.save();
                    ctx.shadowColor = '#FF00FF';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#FF00FF';
                    ctx.font = 'bold 25px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('BREAKOUT', canvas.width / 2, canvas.height / 2 - 188);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.shadowColor = '#00FFFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#00FFFF';
                    
                    // Center-align all instructions
                    ctx.font = 'bold 18px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('Press SPACE or CLICK to start Classic Mode', canvas.width / 2, canvas.height / 2 - 135);
                    ctx.fillText('Press C for Challenge Modes', canvas.width / 2, canvas.height / 2 - 110);
                    ctx.fillText('Press M for Mystical Powers', canvas.width / 2, canvas.height / 2 - 85);
                    ctx.fillText('Press W for World Map', canvas.width / 2, canvas.height / 2 - 60);
                    ctx.fillText('Press H or click button for Hall of Fame', canvas.width / 2, canvas.height / 2 - 35);
                    ctx.fillText('Arrow Keys, WASD, Mouse, Touch to move', canvas.width / 2, canvas.height / 2 - 10);
                    ctx.fillText('Press P or ESC to pause during game', canvas.width / 2, canvas.height / 2 + 15);
                    ctx.fillText('Press S to toggle sound', canvas.width / 2, canvas.height / 2 + 40);
                    ctx.fillText('SPACE to fire laser when powered up', canvas.width / 2, canvas.height / 2 + 65);
                    ctx.restore();
                } else if (gameOverlay.active) {
                    // Handle different overlay types
                    ctx.save();
                    ctx.textAlign = 'center';
                    
                    if (gameOverlay.type === 'levelComplete') {
                        // Level completion overlay
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#00FF00';
                        ctx.font = 'bold 13px "Press Start 2P", monospace';
                        ctx.fillText(`🎉 Level ${gameOverlay.completedLevel} Complete! 🎉`, canvas.width / 2, canvas.height / 2 - 60);
                        
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 14px "Press Start 2P", monospace';
                        ctx.fillText(`Score: ${gameOverlay.score}`, canvas.width / 2, canvas.height / 2 - 20);
                        ctx.fillText(`Starting Level ${gameOverlay.nextLevel}`, canvas.width / 2, canvas.height / 2);
                        ctx.fillText('Press SPACE or CLICK to continue', canvas.width / 2, canvas.height / 2 + 40);
                        
                    } else if (gameOverlay.type === 'gameOver') {
                        // Game over overlay
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FF0000';
                        ctx.font = 'bold 15px "Press Start 2P", monospace';
                        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 80);
                        
                        if (gameOverlay.highScoreText) {
                            ctx.shadowColor = '#FFD700';
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 15px "Press Start 2P", monospace';
                            ctx.fillText(gameOverlay.highScoreText, canvas.width / 2, canvas.height / 2 - 50);
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 25px "Press Start 2P", monospace';
                        ctx.fillText(`Player: ${gameOverlay.playerName}`, canvas.width / 2, canvas.height / 2 - 50);
                        ctx.fillText(`Final Score: ${gameOverlay.finalScore}`, canvas.width / 2, canvas.height / 2 - 10);
                        
                        const levelReached = Math.max(1, gameOverlay.levelReached);
                        const levelName = (levelNames && Array.isArray(levelNames) && levelNames[levelReached - 1]) ? levelNames[levelReached - 1] : `Level ${levelReached}`;
                        ctx.fillText(`Level Reached: ${levelReached}/100`, canvas.width / 2, canvas.height / 2 + 30);
                        
                        // Show level name in smaller font
                        ctx.font = 'bold 18px "Press Start 2P", monospace';
                        ctx.fillText(`"${levelName}"`, canvas.width / 2, canvas.height / 2 + 60);
                        ctx.fillText('Click RESET button below to restart', canvas.width / 2, canvas.height / 2 + 90);
                        
                    } else if (gameOverlay.type === 'ultimateVictory') {
                        // Ultimate Victory celebration overlay - special effects for 100% completion
                        const now = Date.now();
                        const pulse = Math.sin(now * 0.01) * 0.3 + 0.7;
                        const rainbowHue = (now * 0.1) % 360;
                        
                        // Animated background effects
                        for (let i = 0; i < 50; i++) {
                            const x = (canvas.width * Math.sin(now * 0.001 + i * 0.5)) / 2 + canvas.width / 2;
                            const y = (canvas.height * Math.cos(now * 0.001 + i * 0.3)) / 2 + canvas.height / 2;
                            const alpha = Math.sin(now * 0.005 + i) * 0.3 + 0.4;
                            ctx.fillStyle = `hsla(${(rainbowHue + i * 10) % 360}, 100%, 70%, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Main title with rainbow effect
                        ctx.shadowColor = `hsl(${rainbowHue}, 100%, 50%)`;
                        ctx.shadowBlur = 30 * pulse;
                        ctx.fillStyle = `hsl(${rainbowHue}, 100%, 80%)`;
                        ctx.font = 'bold 30px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 120);
                        
                        // Subtitle with glow
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 20 * pulse;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 18px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.subtitle, canvas.width / 2, canvas.height / 2 - 85);
                        
                        // Main message
                        ctx.shadowColor = '#FFFFFF';
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 14px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.message, canvas.width / 2, canvas.height / 2 - 40);
                        
                        // Player details with special formatting
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 16px "Press Start 2P", monospace';
                        ctx.fillText(`COMPLETIONIST: ${gameOverlay.playerName}`, canvas.width / 2, canvas.height / 2);
                        ctx.fillText(`FINAL SCORE: ${gameOverlay.finalScore}`, canvas.width / 2, canvas.height / 2 + 25);
                        
                        // Victory stats
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = '#00FF00';
                        ctx.font = 'bold 12px "Press Start 2P", monospace';
                        ctx.fillText('🏆 ALL 100 LEVELS CONQUERED! 🏆', canvas.width / 2, canvas.height / 2 + 55);
                        
                        // Instructions with special formatting
                        ctx.shadowColor = '#FF69B4';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FF69B4';
                        ctx.font = 'bold 12px "Press Start 2P", monospace';
                        ctx.fillText('SPACE: Hall of Fame  |  H: Completionists', canvas.width / 2, canvas.height / 2 + 85);
                        ctx.fillText('R: Reset Game', canvas.width / 2, canvas.height / 2 + 105);
                        
                    } else if (gameOverlay.type === 'levelReady') {
                        // Level ready overlay
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#00FF00';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 40);
                        
                        ctx.shadowColor = '#FFFFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 25px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.message, canvas.width / 2, canvas.height / 2);
                        ctx.fillText(gameOverlay.instruction, canvas.width / 2, getSafeInstructionTextY(canvas.height / 2 + 40, 25));
                        
                    } else if (gameOverlay.type === 'paused') {
                        // Pause overlay
                        ctx.shadowColor = '#FFFF00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFFF00';
                        ctx.font = 'bold 18px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 40);
                        
                        ctx.shadowColor = '#FFFFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.message, canvas.width / 2, canvas.height / 2);
                        ctx.fillText(gameOverlay.instruction, canvas.width / 2, getSafeInstructionTextY(canvas.height / 2 + 40, 23));
                        
                    } else if (gameOverlay.type === 'hallOfFame') {
                        // Hall of Fame overlay
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 30px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 180);
                        
                        if (gameOverlay.error) {
                            ctx.shadowColor = '#FF0000';
                            ctx.fillStyle = '#FF0000';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('Failed to load scores', canvas.width / 2, canvas.height / 2 - 20);
                        } else if (gameOverlay.scores.length === 0) {
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('No scores yet!', canvas.width / 2, canvas.height / 2 - 20);
                            ctx.fillText('Be the first to play!', canvas.width / 2, canvas.height / 2);
                        } else {
                            // Display top scores
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            
                            gameOverlay.scores.slice(0, 10).forEach((score, index) => {
                                const rank = index + 1;
                                const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                                const isCurrentPlayer = score.player_name === playerName;
                                
                                // Use color from API response
                                let displayColor = score.color || '#FFFFFF';
                                
                                // Override for current player with cyan
                                if (isCurrentPlayer) {
                                    displayColor = '#00FFFF';
                                }
                                
                                // Add subtle highlighting for current user
                                if (score.is_current_user || isCurrentPlayer) {
                                    ctx.shadowColor = displayColor;
                                    ctx.shadowBlur = 15;
                                } else {
                                    // Reduce shadow to avoid overwhelming the colors
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                    ctx.shadowBlur = 2;
                                }
                                ctx.fillStyle = displayColor;
                                
                                const yPos = canvas.height / 2 - 140 + (index * 32);
                                const levelReached = score.level_reached || 1;
                                const levelName = (levelNames && Array.isArray(levelNames) && levelNames[levelReached - 1]) ? levelNames[levelReached - 1] : `Level ${levelReached}`;
                                
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            });
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        drawMultiLineInstruction(gameOverlay.instruction, canvas.height / 2 + 250, 23, 30);
                        
                    } else if (gameOverlay.type === 'hallOfFameInput') {
                        // Interactive Hall of Fame with name input overlay
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 30px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 180);
                        
                        if (gameOverlay.scores.length === 0) {
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('No scores yet!', canvas.width / 2, canvas.height / 2 - 20);
                            ctx.fillText('Be the first to play!', canvas.width / 2, canvas.height / 2);
                        } else {
                            // Display column headers
                            ctx.shadowColor = '#FFD700';
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 18px "Press Start 2P", monospace';
                            const headerY = canvas.height / 2 - 163;
                            ctx.textAlign = 'left';
                            ctx.fillText('PLAYER', 20, headerY);
                            ctx.textAlign = 'center';
                            ctx.fillText('LVL', canvas.width * 0.35, headerY);
                            ctx.fillText('LEVEL NAME', canvas.width * 0.55, headerY);
                            ctx.textAlign = 'right';
                            ctx.fillText('SCORE', canvas.width - 25, headerY);
                            ctx.textAlign = 'center';
                            
                            // Display top scores with player's position highlighted
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            
                            let displayIndex = 0;
                            
                            // Show existing scores up to player's position
                            for (let i = 0; i < gameOverlay.insertAtIndex && displayIndex < 10; i++, displayIndex++) {
                                const score = gameOverlay.scores[i];
                                const rank = displayIndex + 1;
                                const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                                const levelReached = score.level_reached || 1;
                                const levelName = (levelNames && Array.isArray(levelNames) && levelNames[levelReached - 1]) ? levelNames[levelReached - 1] : `Level ${levelReached}`;
                                
                                // Use color from API response
                                let displayColor = score.color || '#FFFFFF';
                                const isCurrentPlayer = score.player_name === (currentUser ? currentUser.username : '');
                                
                                // Override for current player with cyan (consistent with regular hall of fame)
                                if (isCurrentPlayer) {
                                    displayColor = '#00FFFF';
                                }
                                
                                // Add subtle highlighting for current user
                                if (score.is_current_user || isCurrentPlayer) {
                                    ctx.shadowColor = displayColor;
                                    ctx.shadowBlur = 15;
                                } else {
                                    // Reduce shadow to avoid overwhelming the colors
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                    ctx.shadowBlur = 2;
                                }
                                ctx.fillStyle = displayColor;
                                
                                const yPos = canvas.height / 2 - 140 + (displayIndex * 32);
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            }
                            
                            // Show player's input line if they made top 10
                            if (gameOverlay.playerRank <= 10 && displayIndex < 10) {
                                const rank = gameOverlay.playerRank;
                                const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                                
                                ctx.shadowColor = '#00FFFF';
                                ctx.fillStyle = '#00FFFF';
                                
                                const yPos = canvas.height / 2 - 140 + (displayIndex * 32);
                                ctx.textAlign = 'left';
                                
                                // Show blinking cursor
                                const cursorChar = (gameOverlay.cursorVisible && Date.now() - gameOverlay.cursorBlinkTime > 500) ? '_' : '';
                                if (Date.now() - gameOverlay.cursorBlinkTime > 1000) {
                                    gameOverlay.cursorBlinkTime = Date.now();
                                    gameOverlay.cursorVisible = !gameOverlay.cursorVisible;
                                }
                                
                                ctx.fillText(`${rankEmoji} ${gameOverlay.inputName}${cursorChar}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${gameOverlay.playerLevel}`, canvas.width * 0.35, yPos);
                                ctx.textAlign = 'right';
                                ctx.fillText(`${gameOverlay.playerScore.toLocaleString()}`, canvas.width - 20, yPos);
                                ctx.textAlign = 'center';
                                
                                displayIndex++;
                            }
                            
                            // Show remaining scores after player's position
                            for (let i = gameOverlay.insertAtIndex; i < gameOverlay.scores.length && displayIndex < 10; i++, displayIndex++) {
                                const score = gameOverlay.scores[i];
                                const rank = displayIndex + 1;
                                const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                                const levelReached = score.level_reached || 1;
                                const levelName = (levelNames && Array.isArray(levelNames) && levelNames[levelReached - 1]) ? levelNames[levelReached - 1] : `Level ${levelReached}`;
                                
                                // Use color from API response
                                let displayColor = score.color || '#FFFFFF';
                                const isCurrentPlayer = score.player_name === (currentUser ? currentUser.username : '');
                                
                                // Override for current player with cyan (consistent with regular hall of fame)
                                if (isCurrentPlayer) {
                                    displayColor = '#00FFFF';
                                }
                                
                                // Add subtle highlighting for current user
                                if (score.is_current_user || isCurrentPlayer) {
                                    ctx.shadowColor = displayColor;
                                    ctx.shadowBlur = 15;
                                } else {
                                    // Reduce shadow to avoid overwhelming the colors
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                    ctx.shadowBlur = 2;
                                }
                                ctx.fillStyle = displayColor;
                                
                                const yPos = canvas.height / 2 - 140 + (displayIndex * 32);
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            }
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        drawMultiLineInstruction(gameOverlay.instruction, canvas.height / 2 + 250, 23, 30);
                        
                    } else if (gameOverlay.type === 'hallOfFameNoQualify') {
                        // Hall of Fame for players who didn't qualify overlay
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 30px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 250);
                        
                        if (gameOverlay.scores.length === 0) {
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('No scores yet!', canvas.width / 2, canvas.height / 2 - 20);
                            ctx.fillText('Be the first to play!', canvas.width / 2, canvas.height / 2);
                        } else {
                            // Display column headers
                            ctx.shadowColor = '#FFD700';
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 18px "Press Start 2P", monospace';
                            const headerY = canvas.height / 2 - 203;
                            ctx.textAlign = 'left';
                            ctx.fillText('PLAYER', 20, headerY);
                            ctx.textAlign = 'center';
                            ctx.fillText('LVL', canvas.width * 0.35, headerY);
                            ctx.fillText('LEVEL NAME', canvas.width * 0.55, headerY);
                            ctx.textAlign = 'right';
                            ctx.fillText('SCORE', canvas.width - 25, headerY);
                            ctx.textAlign = 'center';
                            
                            // Display top scores
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            
                            gameOverlay.scores.slice(0, 10).forEach((score, index) => {
                                const rank = index + 1;
                                const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                                const levelReached = score.level_reached || 1;
                                const levelName = (levelNames && Array.isArray(levelNames) && levelNames[levelReached - 1]) ? levelNames[levelReached - 1] : `Level ${levelReached}`;
                                
                                // Use color from API response
                                let displayColor = score.color || '#FFFFFF';
                                
                                // Reduce shadow to avoid overwhelming the colors
                                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                ctx.shadowBlur = 2;
                                ctx.fillStyle = displayColor;
                                
                                const yPos = canvas.height / 2 - 140 + (index * 32);
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            });
                            
                            // Show player's score between the hall of fame and bottom message
                            ctx.shadowColor = '#FF6B6B';
                            ctx.fillStyle = '#FF6B6B';
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            const playerDisplayName = gameOverlay.playerName || 'Anonymous';
                            const playerLevelName = (levelNames && Array.isArray(levelNames) && levelNames[gameOverlay.playerLevel - 1]) ? levelNames[gameOverlay.playerLevel - 1] : `Level ${gameOverlay.playerLevel}`;
                            ctx.fillText(`${playerDisplayName}: ${gameOverlay.playerScore.toLocaleString()}`, canvas.width / 2, canvas.height / 2 + 211);
                            ctx.font = 'bold 15px "Press Start 2P", monospace';
                            ctx.fillText(`Level ${gameOverlay.playerLevel}/100: "${playerLevelName}"`, canvas.width / 2, canvas.height / 2 + 236);
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        drawMultiLineInstruction(gameOverlay.instruction, canvas.height / 2 + 270, 23, 30);
                        
                    } else if (gameOverlay.type === 'completionistsHallOfFame') {
                        // Completionists Hall of Fame overlay with special effects
                        const now = Date.now();
                        const pulse = Math.sin(now * 0.008) * 0.2 + 0.8;
                        const rainbowHue = (now * 0.05) % 360;
                        
                        // Animated title with rainbow effect
                        ctx.shadowColor = `hsl(${rainbowHue}, 100%, 50%)`;
                        ctx.shadowBlur = 25 * pulse;
                        ctx.fillStyle = `hsl(${rainbowHue}, 100%, 70%)`;
                        ctx.font = 'bold 24px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 180);
                        
                        // Subtitle
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 16px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.subtitle, canvas.width / 2, canvas.height / 2 - 150);
                        
                        if (gameOverlay.completionists.length === 0) {
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('No completionists yet!', canvas.width / 2, canvas.height / 2 - 80);
                            ctx.fillText('Be the first to conquer all 100 levels!', canvas.width / 2, canvas.height / 2 - 40);
                        } else {
                            // Draw completionist list with special formatting
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            ctx.textAlign = 'left';
                            
                            const startY = canvas.height / 2 - 110;
                            const maxVisible = Math.min(8, gameOverlay.completionists.length);
                            
                            gameOverlay.completionists.slice(0, maxVisible).forEach((completionist, index) => {
                                const y = startY + index * 35;
                                const rank = index + 1;
                                
                                // Rank with special colors for top 3
                                ctx.shadowBlur = 8;
                                if (rank === 1) {
                                    ctx.shadowColor = '#FFD700';
                                    ctx.fillStyle = '#FFD700';
                                } else if (rank === 2) {
                                    ctx.shadowColor = '#C0C0C0';
                                    ctx.fillStyle = '#C0C0C0';
                                } else if (rank === 3) {
                                    ctx.shadowColor = '#CD7F32';
                                    ctx.fillStyle = '#CD7F32';
                                } else {
                                    ctx.shadowColor = '#00FFFF';
                                    ctx.fillStyle = '#00FFFF';
                                }
                                
                                // Trophy icons for top 3
                                const trophy = rank <= 3 ? ['🥇', '🥈', '🥉'][rank - 1] : `${rank}.`;
                                ctx.fillText(`${trophy}`, 25, y);
                                
                                // Player name with completion count - use color system
                                const displayName = completionist.player_name || 'Anonymous';
                                const completionCount = completionist.completion_count || 1;
                                
                                // Make completion count more prominent with color coding
                                let completionText = '';
                                let completionColor = '#FFFFFF';
                                if (completionCount > 1) {
                                    if (completionCount >= 10) {
                                        completionColor = '#FFD700'; // Gold for 10+ completions
                                    } else if (completionCount >= 5) {
                                        completionColor = '#FF6B6B'; // Red for 5+ completions
                                    } else {
                                        completionColor = '#00FF00'; // Green for 2+ completions
                                    }
                                    completionText = ` (${completionCount}x)`;
                                }
                                
                                // Use persistent colors from server, with special highlighting for current user
                                let nameColor = '#FFFFFF';
                                if (completionist.color) {
                                    nameColor = completionist.color;
                                }
                                
                                if (completionist.is_current_user) {
                                    ctx.shadowColor = '#FFD700';
                                    ctx.shadowBlur = 15;
                                } else {
                                    ctx.shadowColor = nameColor;
                                    ctx.shadowBlur = 8;
                                }
                                ctx.fillStyle = nameColor;
                                
                                ctx.fillText(`${displayName}`, 80, y);
                                
                                // Draw completion count with special color if > 1
                                if (completionText) {
                                    ctx.fillStyle = completionColor;
                                    ctx.shadowColor = completionColor;
                                    ctx.shadowBlur = 6;
                                    const nameWidth = ctx.measureText(displayName).width;
                                    ctx.fillText(completionText, 80 + nameWidth, y);
                                }
                                
                                // Score and date
                                ctx.font = 'bold 14px "Press Start 2P", monospace';
                                ctx.fillStyle = '#FFFFFF';
                                ctx.shadowColor = '#FFFFFF';
                                ctx.shadowBlur = 5;
                                
                                const scoreText = completionist.score ? completionist.score.toLocaleString() : 'N/A';
                                const dateObj = new Date(completionist.completion_date);
                                const dateText = dateObj.toLocaleDateString();
                                
                                ctx.fillText(`Best Score: ${scoreText}`, 420, y - 8);
                                ctx.fillText(`Completions: ${completionCount}`, 420, y + 8);
                                
                                ctx.font = 'bold 20px "Press Start 2P", monospace';
                                ctx.textAlign = 'left';
                            });
                            
                            ctx.textAlign = 'center';
                        }
                        
                        // Special instruction with pulsing effect
                        ctx.shadowColor = '#FF69B4';
                        ctx.shadowBlur = 15 * pulse;
                        ctx.fillStyle = '#FF69B4';
                        ctx.font = 'bold 18px "Press Start 2P", monospace';
                        drawMultiLineInstruction(gameOverlay.instruction, canvas.height / 2 + 230, 18, 25);
                        
                    } else if (gameOverlay.type === 'nameError') {
                        // Name error overlay
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FF0000';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.fillText('❌ NAME ERROR ❌', canvas.width / 2, canvas.height / 2 - 40);
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 25px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.message, canvas.width / 2, canvas.height / 2);
                        ctx.fillText('Press SPACE or CLICK to continue', canvas.width / 2, canvas.height / 2 + 40);
                    } else if (gameOverlay.type === 'waveAnnouncement') {
                        // Survival mode wave announcement
                        ctx.shadowColor = '#FF6B00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FF6B00';
                        ctx.font = 'bold 20px "Press Start 2P", monospace';
                        ctx.fillText(`⚡ WAVE ${gameOverlay.wave} ⚡`, canvas.width / 2, canvas.height / 2 - 40);
                        
                        ctx.shadowColor = '#FFFF00';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FFFF00';
                        ctx.font = 'bold 14px "Press Start 2P", monospace';
                        ctx.fillText('Get ready for increased difficulty!', canvas.width / 2, canvas.height / 2);
                        
                        // Auto-dismiss after timer
                        gameOverlay.timer -= 16; // Approximately 60 FPS
                        if (gameOverlay.timer <= 0) {
                            gameOverlay.active = false;
                        }
                    } else if (gameOverlay.type === 'speedrunComplete') {
                        // Speed run completion overlay
                        const minutes = Math.floor(gameOverlay.time / 60000);
                        const seconds = Math.floor((gameOverlay.time % 60000) / 1000);
                        const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        
                        ctx.shadowColor = gameOverlay.newRecord ? '#FFD700' : '#00FF00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = gameOverlay.newRecord ? '#FFD700' : '#00FF00';
                        ctx.font = 'bold 20px "Press Start 2P", monospace';
                        
                        if (gameOverlay.newRecord) {
                            ctx.fillText('🏆 NEW RECORD! 🏆', canvas.width / 2, canvas.height / 2 - 60);
                        } else {
                            ctx.fillText('🏁 SPEED RUN COMPLETE 🏁', canvas.width / 2, canvas.height / 2 - 60);
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 16px "Press Start 2P", monospace';
                        ctx.fillText(`Final Time: ${timeText}`, canvas.width / 2, canvas.height / 2 - 20);
                        
                        if (!gameOverlay.newRecord && gameOverlay.bestTime) {
                            const bestMins = Math.floor(gameOverlay.bestTime / 60000);
                            const bestSecs = Math.floor((gameOverlay.bestTime % 60000) / 1000);
                            const bestTimeText = `${bestMins}:${bestSecs.toString().padStart(2, '0')}`;
                            ctx.fillText(`Best Time: ${bestTimeText}`, canvas.width / 2, canvas.height / 2 + 10);
                        }
                        
                        ctx.fillText('Press SPACE or CLICK to continue', canvas.width / 2, canvas.height / 2 + 40);
                    }
                    
                    ctx.restore();
                }
        }

        function gameLoop(currentTime = 0) {
            // Calculate delta time for frame-rate independent physics
            if (lastFrameTime === 0) lastFrameTime = currentTime;
            const deltaTime = currentTime - lastFrameTime;
            const deltaMultiplier = deltaTime / TARGET_FRAME_TIME; // Normalize to 60 FPS
            lastFrameTime = currentTime;
            
            // Always continue the loop to render overlays, but only update game logic if running
            if (gameRunning && !gamePaused) {
                updatePaddle(deltaMultiplier);
                updateBalls(deltaMultiplier);
                updatePowerUps(deltaMultiplier);
                updateParticles(deltaMultiplier);
                updateScorePopups(deltaMultiplier);
                updateFeedbackMessages(deltaMultiplier);
                updateTempComboMultiplier(); // Update combo multiplier timer
                
                // Phase 3: Update temporary events system
                updateTemporaryEvents(deltaTime);
                checkAndTriggerEvent();
                
                // Update boss battle system
                updateBossSystem(deltaTime);
                
                // Phase 4: Update challenge modes system
                updateChallengeMode(deltaTime);
                
                // Phase 4: Update mystical powers system
                updateMysticalPowers(deltaTime);
                
                // Phase 4: Update world mechanics
                updateWorldMechanics(deltaTime);
                
                // Phase 4: Update analytics system
                updateAnalyticsSystem(deltaTime);
                
                // Phase 3: Check achievements periodically
                if (Math.random() < 0.01) { // Check achievements occasionally to avoid performance impact
                    checkAchievements();
                }
                
                checkBlockCollisions();
                
                // Update session every 5 seconds (300 frames at 60fps)
                if (gameSessionId && Date.now() % 5000 < 100) {
                    updateGameSession();
                }
            }
            
            // Always draw to show overlays even when game is stopped
            draw();
            
            // Continue the loop if game is started, there's an active overlay, or showing start screen
            if (gameStarted || gameOverlay.active || (!gameStarted && !gameRunning)) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }


        // Theme management functions
        function detectParentTheme() {
            // Try to detect theme from parent if in iframe
            try {
                if (window.parent && window.parent !== window) {
                    // In iframe - try to get theme from parent
                    const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
                    if (parentTheme) {
                        console.log('Detected parent theme:', parentTheme);
                        return parentTheme;
                    }
                }
            } catch (e) {
                // Cross-origin iframe, can't access parent
                console.log('Cannot access parent theme (cross-origin)');
            }
            
            // Fallback: check localStorage or system preference
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            
            // Check system preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                return 'dark';
            }
            
            return 'light';
        }
        
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            
            // Update theme icon
            const themeIcon = document.getElementById('theme-icon');
            if (themeIcon) {
                themeIcon.className = theme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            }
            
            console.log('Applied theme:', theme);
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        }
        
        function initializeTheme() {
            const theme = detectParentTheme();
            applyTheme(theme);
            
            // Show/hide navigation header based on context
            const navHeader = document.querySelector('.navigation-header');
            if (navHeader) {
                // Check multiple ways if we're in an iframe
                const isIframe = window.self !== window.top || 
                               window.parent !== window || 
                               window.frameElement !== null ||
                               window.location !== window.parent.location;
                
                if (isIframe) {
                    navHeader.style.display = 'none';
                    console.log('Running in iframe - hiding navigation header');
                } else {
                    console.log('Running standalone - showing navigation header');
                }
            }
        }

        // Listen for theme changes from parent window
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'themeChange') {
                console.log('Received theme change from parent:', event.data.theme);
                applyTheme(event.data.theme);
            }
        });

        // Splash screen and game initialization
        window.addEventListener('DOMContentLoaded', async function() {
            console.log('DOMContentLoaded event fired');
            try {
                console.log('Calling initializeTheme...');
                initializeTheme();
                console.log('initializeTheme completed');
                
                // Set up fullscreen button event listener
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                if (fullscreenBtn) {
                    fullscreenBtn.addEventListener('click', async function() {
                        try {
                            await toggleFullscreen();
                        } catch (error) {
                            console.error('Fullscreen button click error:', error);
                            showError('Fullscreen failed: ' + (error.message || 'Unknown error'));
                        }
                    });
                    console.log('Fullscreen button event listener registered');
                } else {
                    console.warn('Fullscreen button not found during initialization');
                }
                
                // Show splash screen for 3 seconds before starting game
                const splashScreen = document.getElementById('splashScreen');
                if (splashScreen) {
                    console.log('Showing cr0soft splash screen for 3 seconds...');
                    
                    // Wait 3 seconds then fade out splash and start game
                    setTimeout(async function() {
                        console.log('Fading out splash screen...');
                        splashScreen.style.opacity = '0';
                        
                        // Wait for fade transition to complete, then hide and start game
                        setTimeout(async function() {
                            splashScreen.style.display = 'none';
                            console.log('Splash screen hidden, starting game...');
                            
                            try {
                                console.log('Calling initBreakoutGame...');
                                await initBreakoutGame();
                                console.log('initBreakoutGame completed');
                            } catch (error) {
                                console.error('Error during game initialization:', error);
                            }
                        }, 500); // Wait for fade transition (0.5s)
                    }, 3000); // Show splash for 3 seconds
                } else {
                    // Fallback if splash screen element not found
                    console.log('Splash screen element not found, starting game directly...');
                    console.log('Calling initBreakoutGame...');
                    await initBreakoutGame();
                    console.log('initBreakoutGame completed');
                }
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        });
    </script>
</body>
</html>