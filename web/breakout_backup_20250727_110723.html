<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout by cr0sis</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #3b82f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-tertiary: #f3f4f6;
            --border-light: #e5e7eb;
            --border-medium: #d1d5db;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
        }

        [data-theme="dark"] {
            --primary-color: #3b82f6;
            --primary-dark: #2563eb;
            --primary-light: #60a5fa;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --bg-primary: #1f2937;
            --bg-secondary: #374151;
            --bg-tertiary: #4b5563;
            --border-light: #4b5563;
            --border-medium: #6b7280;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
        }

        .game-container {
            max-width: 900px;
            margin: 0 auto;
            text-align: center;
        }

        .network-header {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-light);
        }

        .network-header h2 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            font-size: 1.75rem;
        }

        .network-description {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .retro-ui-element {
            font-family: 'Press Start 2P', monospace !important;
            font-size: 0.9rem !important;
            font-weight: 700 !important;
            background: rgba(0,0,0,0.7) !important;
            border-radius: 5px !important;
            padding: 0.4rem !important;
        }

        .ui {
            margin: 1.5rem 0;
        }

        .ui button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 0.5rem;
        }

        .ui button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        #hallOfFameBtn {
            background: #FFD700;
            color: #000;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }
        
        #hallOfFameBtn:hover {
            background: #FFA500;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
        }
        
        @keyframes pulse-gold {
            0% { box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(255, 215, 0, 0.6); }
            100% { box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3); }
        }
        
        .game-not-started #hallOfFameBtn {
            animation: pulse-gold 2s infinite;
        }

        .ui button:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .controls {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-top: 1.5rem;
        }

        .controls p {
            margin: 0.5rem 0;
        }

        #gameCanvas {
            border: 2px solid var(--border-medium);
            border-radius: var(--radius-lg);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            max-width: 100%;
            height: auto;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .ui {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
                text-align: center;
            }
            
            .retro-ui-element {
                font-size: 0.7rem !important;
                padding: 0.3rem !important;
            }
            
            .controls {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="navigation-header" style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-secondary); border-radius: var(--radius-md); border: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center;">
            <div>
                <a href="/" style="color: var(--primary-color); text-decoration: none; font-weight: 600;">
                    <i class="fas fa-arrow-left"></i> Back to Main Site
                </a>
            </div>
            <div style="display: flex; gap: 1rem; align-items: center;">
                <button onclick="toggleTheme()" style="background: var(--bg-tertiary); border: 1px solid var(--border-light); color: var(--text-primary); padding: 0.5rem; border-radius: var(--radius-md); cursor: pointer;">
                    <i class="fas fa-moon" id="theme-icon"></i>
                </button>
                <span style="font-size: 0.875rem; color: var(--text-muted);">Standalone Mode</span>
            </div>
        </div>
        
        
        <div class="ui" style="margin-bottom: 1.5rem; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1rem; text-align: center;">
            <div class="retro-ui-element" style="color: #00FFFF; text-shadow: 0 0 10px #00FFFF, 0 0 20px #00FFFF; border: 2px solid #00FFFF;">SCORE: <span id="score">0</span></div>
            <div class="retro-ui-element" style="color: #FF00FF; text-shadow: 0 0 10px #FF00FF, 0 0 20px #FF00FF; border: 2px solid #FF00FF;">LIVES: <span id="lives">3</span></div>
            <div class="retro-ui-element" style="color: #FFD700; text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700; border: 2px solid #FFD700;">LEVEL: <span id="level">1</span></div>
            <div class="retro-ui-element" style="color: #00FF7F; text-shadow: 0 0 10px #00FF7F, 0 0 20px #00FF7F; border: 2px solid #00FF7F;">BEST: <span id="personalBest">0</span></div>
        </div>
        
        <div style="text-align: center; margin-bottom: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.8); border-radius: 10px; border: 3px solid #FFD700; box-shadow: 0 0 20px #FFD700;">
            <div style="color: #FFD700; font-weight: 700; font-size: 0.8rem; font-family: 'Press Start 2P', monospace; text-shadow: 0 0 15px #FFD700;">üèÜ CHAMPION üèÜ</div>
            <div style="color: #FFFFFF; font-weight: 700; font-size: 0.9rem; margin-top: 0.25rem; font-family: 'Press Start 2P', monospace; text-shadow: 0 0 10px #FFFFFF;">
                <span id="allTimeScore">0</span> - <span id="allTimePlayer">Nobody</span>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="1000" height="750" style="background-color: #000;" tabindex="0"></canvas>
        
        <div class="ui">
            <button id="pauseBtn" onclick="togglePause()" disabled>Pause</button>
            <button id="resetBtn" onclick="resetGame()">Reset</button>
            <button id="hallOfFameBtn" onclick="console.log('Hall of Fame button clicked'); showRegularHallOfFame()">üèÜ Hall of Fame</button>
        </div>
        
        <div class="controls">
            <p>üéÆ <strong>Controls:</strong> Arrow Keys, WASD, Mouse, or Touch to move paddle</p>
            <p>‚ö° <strong>Actions:</strong> SPACE to launch ball / fire laser ‚Ä¢ S to toggle sound</p>
            <p>‚è∏Ô∏è <strong>Pause:</strong> Press P or ESC to pause during game</p>
            <p>üî• <strong>Power-ups:</strong> Catch falling power-ups for special abilities!</p>
        </div>
    </div>

    <!-- Include secure game API -->
    <script src="js/secure-game.min.js"></script>
    
    <script>
        // Basic security variables for legitimate gameplay
        let score = 0;
        let lives = 3;
        let level = 1;

        // Load breakout scores and initialization
        let hallOfFameLoaded = false;

        function loadBreakoutScores() {
            if (hallOfFameLoaded) return;
            
            fetch('breakout_scores.php?action=get_scores&limit=10')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.scores && data.scores.length > 0) {
                        const topScore = data.scores[0];
                        if (topScore.score && topScore.player_name) {
                            document.getElementById('allTimeScore').textContent = topScore.score.toLocaleString();
                            document.getElementById('allTimePlayer').textContent = topScore.player_name;
                            hallOfFameLoaded = true;
                        }
                    }
                })
                .catch(error => {
                    console.log('Could not load breakout scores:', error);
                });
        }

        // Load scores on page load
        loadBreakoutScores();
        
        // Breakout by cr0sis - Game Logic
        let canvas, ctx, scoreElement, livesElement, pauseBtn, resetBtn, levelElement, personalBestElement, allTimeScoreElement, allTimePlayerElement;
        
        function updateScore(increment) {
            score += increment;
            // Cap score at 999 trillion
            if (score > 999999999999999) {
                score = 999999999999999; // 999 trillion max score
            }
            return score;
        }
        
        async function startGameSession(playerName = 'Anonymous') {
            try {
                console.log('Attempting to start game session for:', playerName);
                const response = await fetch('game_session.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'start_session',
                        player_name: playerName
                    })
                });
                
                console.log('Session response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Session data received:', data);
                    
                    if (data.session_id && data.token) {
                        gameSessionId = data.session_id;
                        gameSessionToken = data.token;
                        console.log('Game session started with cryptographic protection');
                        return { success: true, session_id: gameSessionId, token: gameSessionToken };
                    } else {
                        console.error('Invalid session data received:', data);
                        return { success: false, error: 'Invalid session data received' };
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Failed to start game session:', response.status, errorText);
                    
                    // Check for IP blocking
                    if (response.status === 403 && errorText.includes('IP blocked')) {
                        return { 
                            success: false, 
                            error: 'IP_BLOCKED',
                            message: 'Your IP address is temporarily blocked. Please contact support.'
                        };
                    }
                    
                    return { success: false, error: `HTTP ${response.status}: ${errorText}` };
                }
            } catch (error) {
                console.error('Error starting game session:', error);
                return { success: false, error: error.message };
            }
        }
        
        async function updateGameSession() {
            if (!gameSessionId) return;
            
            try {
                await fetch('game_session.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'update_session',
                        session_id: gameSessionId,
                        level: level,
                        blocks_destroyed: sessionStats.blocksDestroyed,
                        lives_lost: sessionStats.livesLost,
                        powerups_collected: sessionStats.powerupsCollected
                    })
                });
            } catch (error) {
                console.error('Error updating game session:', error);
            }
        }
        let gameRunning = false;
        let gamePaused = false;
        let gameStarted = false;
        let gameOverlay = { active: false }; // Tracks current overlay state
        // Game score variable
        let gameSessionId = null;
        let gameSessionToken = null;
        let sessionStats = {
            blocksDestroyed: 0,
            livesLost: 0,  
            powerupsCollected: 0
        };
        
        // Login detection - Get user from parent window if in iframe
        let currentUser = null;
        
        async function updateCurrentUser(forceDirectCheck = false) {
            try {
                if (window.parent && window.parent !== window && !forceDirectCheck) {
                    currentUser = window.parent.currentUser;
                    console.log('Updated currentUser from parent:', currentUser);
                    
                    // If parent still undefined, try direct API as fallback
                    if (!currentUser) {
                        console.log('Parent currentUser undefined, falling back to direct API');
                        forceDirectCheck = true;
                    }
                }
                
                if (forceDirectCheck || window.parent === window) {
                    // Direct access or forced check - use auth API
                    console.log('Direct access detected - checking auth API');
                    try {
                        const response = await fetch('auth.php', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'check_auth' })
                        });
                        const data = await response.json();
                        console.log('Direct access - full API response:', data);
                        currentUser = data.logged_in ? data.user : null;
                        console.log('Direct access - auth API result:', currentUser);
                    } catch (authError) {
                        console.log('Auth API check failed:', authError.message);
                        currentUser = null;
                    }
                }
            } catch (error) {
                console.log('Could not access parent user data (cross-origin or no parent):', error.message);
            }
        }
        
        // Debug function to understand context
        function debugContext() {
            console.log('=== BREAKOUT CONTEXT DEBUG ===');
            console.log('URL:', window.location.href);
            console.log('Is iframe:', window.parent !== window);
            console.log('Parent URL:', window.parent !== window ? 'hidden (cross-origin)' : 'same window');
            console.log('Referrer:', document.referrer);
            
            if (window.parent !== window) {
                try {
                    console.log('Parent currentUser:', window.parent.currentUser);
                    console.log('Parent has checkAuthStatus:', typeof window.parent.checkAuthStatus);
                    console.log('Parent document title:', window.parent.document.title);
                } catch (e) {
                    console.log('Cannot access parent data:', e.message);
                }
            }
            console.log('===============================');
        }
        
        // Initial user detection
        (async () => {
            debugContext();
            await updateCurrentUser();
        })();
        
        // Enhanced parent user detection with multiple strategies
        if (window.parent && window.parent !== window) {
            let checkCount = 0;
            const userCheckInterval = setInterval(async () => {
                checkCount++;
                try {
                    // Strategy 1: Check parent.currentUser
                    let newUser = window.parent.currentUser;
                    
                    // Strategy 2: If undefined, try calling parent's checkAuthStatus if available
                    if (!newUser && typeof window.parent.checkAuthStatus === 'function') {
                        console.log('Parent currentUser undefined, triggering parent auth check');
                        await window.parent.checkAuthStatus();
                        // Wait a moment for the parent to update currentUser
                        await new Promise(resolve => setTimeout(resolve, 500));
                        newUser = window.parent.currentUser;
                        console.log('After parent auth check, currentUser:', newUser);
                    }
                    
                    // Strategy 3: Look for authentication data in parent DOM
                    if (!newUser) {
                        try {
                            const authData = window.parent.document.querySelector('[data-user-info]');
                            if (authData) {
                                newUser = JSON.parse(authData.getAttribute('data-user-info'));
                                console.log('Found user data in parent DOM:', newUser);
                            }
                        } catch (domError) {
                            // Parent DOM not accessible
                        }
                    }
                    
                    // Strategy 4: Direct auth check if still no user and we haven't tried recently
                    if (!newUser && checkCount <= 5) {
                        console.log('No user from parent, trying direct auth check (attempt ' + checkCount + ')');
                        // Force direct auth API call, bypassing parent check
                        try {
                            const response = await fetch('auth.php', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ action: 'check_auth' })
                            });
                            const data = await response.json();
                            newUser = data.logged_in ? data.user : null;
                            console.log('Direct auth API result:', newUser);
                        } catch (authError) {
                            console.log('Direct auth API failed:', authError.message);
                        }
                    }
                    
                    if (JSON.stringify(newUser) !== JSON.stringify(currentUser)) {
                        currentUser = newUser;
                        console.log('User status changed (check #' + checkCount + '):', currentUser);
                    }
                    
                    // If we found a user, we can check less frequently
                    if (currentUser && currentUser.username) {
                        console.log('User detected, reducing check frequency');
                        clearInterval(userCheckInterval);
                        // Set up less frequent checks
                        setInterval(() => {
                            const latestUser = window.parent.currentUser;
                            // Only update if parent has a valid user (don't overwrite with undefined)
                            if (latestUser && JSON.stringify(latestUser) !== JSON.stringify(currentUser)) {
                                currentUser = latestUser;
                                console.log('User status updated from parent:', currentUser);
                            }
                        }, 10000);
                    }
                } catch (error) {
                    // Cross-origin or parent not accessible - try direct auth check
                    if (checkCount % 3 === 0) { // Only every 3rd check to avoid spam
                        await updateCurrentUser();
                    }
                }
            }, 1000); // Check every second initially
            
            // Stop checking after 30 seconds
            setTimeout(() => clearInterval(userCheckInterval), 30000);
        }
        
        // Legacy compatibility variables (non-functional)
        let __debugMode = false;
        let __unlimitedLives = false;
        let __scoreMultiplier = 1;
        let __adminAccess = false;
        let cheatModeEnabled = false;
        let godMode = false;
        
        // Decoy functions that appear to work but are disabled
        window.enableCheatMode = function() {
            console.log("Feature disabled in secure mode");
            return "Access denied";
        };
        
        window.setScore = function(newScore) {
            console.log("Direct score modification blocked");
            return "Operation not permitted";
        };
        
        window.unlimitedLives = function() {
            console.log("Lives modification disabled");
            return "Feature unavailable";
        };
        let originalScore = 0;
        setInterval(() => {
            if (__debugMode || __unlimitedLives || __scoreMultiplier !== 1 || __adminAccess || cheatModeEnabled || godMode) {
                fetch('/report_tampering.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'client_tampering',
                        session_id: gameSessionId,
                        variables: {
                            debugMode: __debugMode,
                            unlimitedLives: __unlimitedLives,
                            scoreMultiplier: __scoreMultiplier,
                            adminAccess: __adminAccess,
                            cheatMode: cheatModeEnabled,
                            godMode: godMode
                        }
                    })
                }).catch(() => {}); // Silent fail
            }
            
            // Check for rapid score changes
            if (Math.abs(score - originalScore) > 100000) { // Allow for high combo scores
                fetch('/report_tampering.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'rapid_score_change',
                        session_id: gameSessionId,
                        old_score: originalScore,
                        new_score: score,
                        difference: score - originalScore
                    })
                }).catch(() => {});
            }
            originalScore = score;
        }, 1000);
        // Game lives and level variables
        let animationId;
        let soundEnabled = true;
        
        // Frame rate independent timing
        let lastFrameTime = 0;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS; // 16.67ms for 60 FPS
        const SPEED_MULTIPLIER = 144 / 60; // 2.4x speed to match 144 FPS feel
        let playerName = '';
        let scoreSubmitted = false;
        let gameOverData = null; // Stores game data for name override screen
        let legitGameCompleted = false; // Tracks if player completed a legitimate game

        // Game state
        const gameState = {
            balls: [],
            powerUps: [],
            particles: [],
            screenShake: 0,
            multiplier: 1,
            combo: 0,
            feedbackMessages: [],
            scorePopups: []
        };

        // Paddle with enhanced properties
        const paddle = {
            x: 0,
            y: 0,
            width: 188,
            height: 19,
            speed: 8,
            originalWidth: 188,
            laser: false,
            sticky: false,
            powerUpTimer: 0,
            velocity: 0,
            lastX: 0
        };

        // Ball template
        const ballTemplate = {
            x: 0,
            y: 0,
            radius: 13,
            dx: 0,
            dy: 0,
            speed: 5,
            launched: false,
            trail: []
        };

        // Power-up types
        const powerUpTypes = [
            { type: 'multiball', color: '#FF6B6B', symbol: '‚óè‚óè‚óè', chance: 0.13 },
            { type: 'bigpaddle', color: '#4ECDC4', symbol: '‚îÅ‚îÅ‚îÅ', chance: 0.18 },
            { type: 'laser', color: '#45B7D1', symbol: '‚ö°', chance: 0.13 },
            { type: 'sticky', color: '#96CEB4', symbol: '„Äá', chance: 0.13 },
            { type: 'extralife', color: '#FFEAA7', symbol: '‚ô•', chance: 0.09 },
            { type: 'slowball', color: '#DDA0DD', symbol: 'üêå', chance: 0.13 },
            { type: 'megaball', color: '#98D8C8', symbol: '‚ö´', chance: 0.09 },
            { type: 'rocket', color: '#FF4500', symbol: 'üöÄ', chance: 0.12 }
        ];

        // Block system
        const blocks = [];
        const blockRows = 8;
        const blockCols = 10;
        const blockWidth = 94; // 75 * 1.25
        const blockHeight = 25; // 20 * 1.25
        const blockPadding = 6; // 5 * 1.25 (rounded)
        const blockColors = [
            '#FF0040', // Bright red
            '#00FFD4', // Bright cyan  
            '#FF6600', // Bright orange
            '#8000FF', // Bright purple
            '#00FF40', // Bright green
            '#FF0080', // Bright magenta
            '#0080FF', // Bright blue
            '#FFFF00', // Bright yellow
            '#FF4080', // Hot pink
            '#80FF00', // Lime green
            '#4080FF', // Sky blue
            '#FF8040', // Coral
            '#FF2000', // Deep red for pixel art
            '#FF6000', // Orange-red for pixel art
            '#FFB000', // Gold for pixel art
            '#FFFFFF', // White for pixel art
            '#CCCCCC', // Light gray for pixel art
            '#808080', // Dark gray for pixel art
            '#FF00FF', // Bright magenta for pixel art
            '#00FFFF'  // Cyan for pixel art
        ];

        // Level names for the 100-level system (spooky/cyber themed)
        const levelNames = [
            "Viral Vortex",          // 1 - first lava blocks (was 5)
            "Pixel Purgatory",       // 2 - original level 1 with colors (was 4)
            "Cyber Crypt",           // 3 (was 3)
            "Neon Nightmare",         // 4 (was 2)
            "Digital Dawn",           // 5 (was 1)
            "Data Decay",            // 6
            "System Spiral",         // 7
            "Ghost Grid",            // 8
            "Phantom Protocol",      // 9
            "Demon Download",        // 10
            "Cryptic Code",          // 11
            "Shadow Server",         // 12
            "Haunted Hardware",      // 13
            "Spectral Syntax",       // 14
            "Mystic Matrix",         // 15 - first pixel art
            "Cursed Circuit",        // 16
            "Wraith Web",            // 17
            "Banshee Bandwidth",     // 18
            "Poltergeist Port",      // 19
            "Reaper's Realm",        // 20 - ALL LAVA (instant win)
            "Undead Upload",         // 21
            "Vampire Vector",        // 22
            "Witch's WiFi",          // 23
            "Demon Database",        // 24
            "Specter Signal",        // 25
            "Necro Network",         // 26
            "Phantom Firewall",      // 27
            "Ghoul Gateway",         // 28
            "Zombie Zone",           // 29
            "Terror Terminal",       // 30
            "Skull Screen",          // 31
            "Bone Bandwidth",        // 32
            "Soul Server",           // 33
            "Death Download",        // 34
            "Grave Graphics",        // 35
            "Crypt Code",            // 36
            "Tomb Terminal",         // 37
            "Coffin Cache",          // 38
            "Mummy Memory",          // 39
            "Pharaoh's Protocol",    // 40 - map clearing level
            "Ancient Algorithm",     // 41
            "Curse Compiler",        // 42
            "Pyramid Program",       // 43
            "Sarcophagus Script",    // 44
            "Hieroglyph Hack",      // 45 - map clearing level
            "Sphinx System",         // 46
            "Anubis Array",          // 47
            "Ra's Registry",         // 48
            "Osiris OS",             // 49
            "Void Vector",           // 50 - map clearing level
            "Black Binary",          // 51
            "Dark Data",             // 52
            "Shadow Script",         // 53
            "Midnight Matrix",       // 54
            "Eclipse Engine",        // 55 - map clearing level
            "Lunar Logic",           // 56
            "Solar System",          // 57
            "Stellar Script",        // 58
            "Cosmic Code",           // 59
            "Galaxy Gateway",        // 60 - map clearing level
            "Nebula Network",        // 61
            "Quasar Query",          // 62
            "Pulsar Protocol",       // 63
            "Supernova System",      // 64
            "Blackhole Binary",      // 65 - map clearing level
            "Wormhole Web",          // 66
            "Dimensional Data",      // 67
            "Parallel Protocol",     // 68
            "Quantum Query",         // 69
            "Atomic Array",          // 70 - map clearing level
            "Nuclear Network",       // 71
            "Fusion Framework",      // 72
            "Plasma Protocol",       // 73
            "Energy Engine",         // 74
            "Photon Program",        // 75 - map clearing level
            "Laser Logic",           // 76
            "Beam Binary",           // 77
            "Ray Registry",          // 78
            "Light Logic",           // 79
            "Prism Protocol",        // 80 - map clearing level
            "Crystal Core",          // 81
            "Diamond Data",          // 82
            "Emerald Engine",        // 83
            "Ruby Registry",         // 84
            "Sapphire System",       // 85 - map clearing level
            "Topaz Terminal",        // 86
            "Opal OS",               // 87
            "Amber Algorithm",       // 88
            "Pearl Program",         // 89
            "Gold Gateway",          // 90 - map clearing level
            "Silver System",         // 91
            "Platinum Protocol",     // 92
            "Titanium Terminal",     // 93
            "Steel Script",          // 94
            "Iron Interface",        // 95 - map clearing level
            "Copper Core",           // 96
            "Bronze Binary",         // 97
            "Alloy Algorithm",       // 98
            "Metal Matrix",          // 99
            "Ultimate Upload"        // 100 - final map clearing level
        ];

        // Input handling
        const keys = {};
        let mouseX = 0;
        let touchX = 0;
        
        // High Score System
        let allTimeHighScore = { score: 0, player: 'Nobody' };
        let sessionPersonalBest = 0;
        
        function getLocalHighScore() {
            return parseInt(localStorage.getItem('breakout-highscore')) || 0;
        }

        function setLocalHighScore(newScore) {
            const currentHigh = getLocalHighScore();
            if (newScore > currentHigh) {
                localStorage.setItem('breakout-highscore', newScore.toString());
                return true;
            }
            return false;
        }

        function updatePersonalBest(newScore) {
            if (newScore > sessionPersonalBest) {
                sessionPersonalBest = newScore;
                return true;
            }
            return false;
        }

        // Fetch all-time high score from database
        async function fetchAllTimeHighScore() {
            try {
                const response = await fetch('breakout_scores.php?limit=1');
                if (response.ok) {
                    const scores = await response.json();
                    if (scores.length > 0) {
                        allTimeHighScore = {
                            score: scores[0].score,
                            player: scores[0].player_name
                        };
                        // Update all-time champion display
                        if (allTimeScoreElement) allTimeScoreElement.textContent = allTimeHighScore.score.toLocaleString();
                        if (allTimePlayerElement) allTimePlayerElement.textContent = allTimeHighScore.player;
                        
                        // Update UI to show the personal best
                        updateUI();
                    }
                }
            } catch (error) {
                console.error('Failed to fetch all-time high score:', error);
            }
        }

        function getCurrentHighScore() {
            return Math.max(allTimeHighScore.score, getLocalHighScore());
        }

        // Client-side profanity filter (lightweight version)
        function containsProfanityJS(text) {
            // Core profanity list for client-side checking
            const profanityList = [
                'fuck', 'shit', 'bitch', 'damn', 'hell', 'ass', 'crap', 'piss', 'cock', 'dick', 'pussy', 'cunt', 'whore', 'slut',
                'bastard', 'asshole', 'bullshit', 'goddamn', 'wtf', 'stfu', 'gtfo', 'nigger', 'nigga', 'faggot', 'retard',
                'nazi', 'hitler', 'porn', 'sex', 'cum', 'kill', 'murder', 'rape', 'bomb', 'suicide', 'kys', 'admin', 'mod'
            ];
            
            const normalized = normalizeProfanityTextJS(text);
            
            for (const word of profanityList) {
                const normalizedWord = normalizeProfanityTextJS(word);
                if (normalized.includes(normalizedWord)) {
                    return true;
                }
                
                // Check for variations with separators
                const pattern = normalizedWord.split('').join('[0-9\\s\\-_\\.\\*\\+]*?');
                const regex = new RegExp(pattern, 'i');
                if (regex.test(normalized)) {
                    return true;
                }
            }
            
            return false;
        }

        function normalizeProfanityTextJS(text) {
            text = text.toLowerCase().trim();
            
            // Remove separators
            text = text.replace(/[\s\-_\.\*\+!@#$%^&]/g, '');
            
            // Replace leetspeak
            const leetspeak = {
                '4': 'a', '@': 'a', '3': 'e', '1': 'i', '!': 'i', '|': 'i',
                '0': 'o', '5': 's', '$': 's', '7': 't', '+': 't', '8': 'b'
            };
            
            for (const [leet, normal] of Object.entries(leetspeak)) {
                text = text.replace(new RegExp(leet.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), normal);
            }
            
            // Remove remaining numbers
            text = text.replace(/[0-9]+/g, '');
            
            return text;
        }

        // Check for admin localStorage reset - DISABLED (admin panel removed)
        async function checkLocalStorageReset() {
            // This functionality has been disabled as the admin panel was removed
            return;
        }

        // Sound System (Web Audio API simulation)
        function playSound(type) {
            if (!soundEnabled) return;
            
            // Simple sound effects using oscillator
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const sounds = {
                paddle: { freq: 200, duration: 0.1 },
                block: { freq: 400, duration: 0.15 },
                powerup: { freq: 600, duration: 0.2 },
                life: { freq: 150, duration: 0.3 },
                win: { freq: 800, duration: 0.5 }
            };
            
            const sound = sounds[type] || sounds.block;
            oscillator.frequency.setValueAtTime(sound.freq, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + sound.duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + sound.duration);
        }

        // Handle responsive canvas sizing
        function resizeCanvas() {
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            
            // For mobile devices
            if (window.innerWidth <= 768) {
                // Calculate dimensions maintaining aspect ratio
                const maxWidth = Math.min(containerWidth - 20, window.innerWidth - 20);
                const aspectRatio = 800 / 600;
                
                canvas.style.width = maxWidth + 'px';
                canvas.style.height = (maxWidth / aspectRatio) + 'px';
                
                // Adjust game scale factor
                const scaleFactor = maxWidth / 800;
                canvas.setAttribute('data-scale', scaleFactor);
            } else {
                // Desktop - use original size
                canvas.style.width = '800px';
                canvas.style.height = '600px';
                canvas.setAttribute('data-scale', '1');
            }
        }

        function initBreakoutGame() {
            canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            
            ctx = canvas.getContext('2d');
            scoreElement = document.getElementById('score');
            livesElement = document.getElementById('lives');
            levelElement = document.getElementById('level');
            personalBestElement = document.getElementById('personalBest');
            allTimeScoreElement = document.getElementById('allTimeScore');
            allTimePlayerElement = document.getElementById('allTimePlayer');
            pauseBtn = document.getElementById('pauseBtn');
            resetBtn = document.getElementById('resetBtn');

            // Handle responsive sizing
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Check for admin localStorage reset
            checkLocalStorageReset();

            // Fetch all-time high score from database
            fetchAllTimeHighScore();

            // Setup mouse and touch controls
            setupControls();

            // Set initial paddle position
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.y = canvas.height - 38;
            paddle.lastX = paddle.x; // Initialize lastX to prevent velocity glitch
            paddle.velocity = 0; // Reset velocity

            // Initialize first ball
            const firstBall = {
                x: canvas.width / 2,
                y: paddle.y - 20,
                radius: 10,
                dx: 0,
                dy: 0,
                speed: 5, // Hard-coded to base speed - NO level increases
                launched: false,
                trail: []
            };
            console.log(`Game initialized at level ${level}: Ball speed set to ${firstBall.speed} (base: 5)`);
            gameState.balls = [firstBall];

            initBlocks();
            updateUI();
            draw();
            
            // Game is ready but not started yet
            gameStarted = false;
            gameRunning = false;
            if (pauseBtn) pauseBtn.disabled = true;
            
            // Start the game loop to continuously render the start screen
            if (!animationId) {
                gameLoop();
            }
        }

        function setupControls() {
            // Helper function to get scaled coordinates
            function getScaledCoordinates(clientX, rect) {
                const scale = parseFloat(canvas.getAttribute('data-scale') || '1');
                const x = (clientX - rect.left) / scale;
                return x;
            }

            // Mouse controls - listen to document for global mouse tracking
            document.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                // Update mouseX with scaled coordinates
                mouseX = getScaledCoordinates(e.clientX, rect);
            });

            // Touch controls
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                touchX = getScaledCoordinates(e.touches[0].clientX, rect);
            });

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameStarted) {
                    startGame();
                } else if (gameRunning && gameState.balls.length > 0) {
                    launchNextBall(); // Launch balls sequentially
                }
            });
            
            // Mouse click handler (same behavior as touch and spacebar)
            canvas.addEventListener('click', async (e) => {
                // Focus the canvas to capture keyboard events
                canvas.focus();
                
                // Handle overlay dismissal first
                if (gameOverlay.active) {
                    // Don't handle clicks for interactive hall of fame - only keyboard input
                    if (gameOverlay.type === 'hallOfFameInput') {
                        return;
                    }
                    if (gameOverlay.type === 'levelComplete') {
                        // Continue to next level (level already incremented in nextLevel function)
                        if (level > totalLevels) {
                            // Game completed
                            gameOverlay = {
                                active: true,
                                type: 'gameComplete',
                                title: 'CONGRATULATIONS!',
                                message: 'You completed all levels!',
                                instruction: 'Press SPACE to restart'
                            };
                            return;
                        } else {
                            // Level setup already done in nextLevel() - just dismiss overlay
                            gameOverlay.active = false;
                        }
                    } else if (gameOverlay.type === 'gameOver') {
                        // Game over screen doesn't respond to click - use H/R keys instead
                        return;
                    } else if (gameOverlay.type === 'gameComplete') {
                        // Restart from level 1
                        resetGame();
                    } else if (gameOverlay.type === 'levelReady') {
                        // Just dismiss the overlay, game continues
                    } else if (gameOverlay.type === 'paused') {
                        // Unpause the game
                        togglePause();
                        return; // togglePause handles overlay cleanup
                    } else if (gameOverlay.type === 'hallOfFame') {
                        // Close hall of fame and return to game over screen if it was shown from there
                        if (gameOverlay.returnToGameOver) {
                            // Restore the game over screen
                            gameOverlay = {
                                active: true,
                                type: 'gameOver',
                                title: 'üéÆ GAME OVER üéÆ',
                                playerName: gameOverlay.gameOverData.playerName,
                                finalScore: gameOverlay.gameOverData.finalScore,
                                levelReached: gameOverlay.gameOverData.levelReached,
                                instruction: 'Press H for Hall of Fame or R to Reset'
                            };
                        } else {
                            // Just close the hall of fame overlay (called from start screen)
                            removeOverlayKeyHandler();
                        }
                    } else if (gameOverlay.type === 'hallOfFameNoQualify') {
                        // Show game over screen with final details
                        const playerScore = gameOverlay.playerScore;
                        const playerLevel = gameOverlay.playerLevel;
                        gameStarted = false; // Now it's safe to return to start screen
                        gameOverlay = {
                            active: true,
                            type: 'gameOver',
                            title: 'üéÆ GAME OVER üéÆ',
                            message: `Final Score: ${playerScore.toLocaleString()}\nLevel Reached: ${playerLevel}\nPlayer: Anonymous\n\nYour score didn't make the top 10.`,
                            instruction: 'Click RESET button below to restart'
                        };
                        return;
                    }
                    
                    gameOverlay.active = false;
                    return;
                }
                
                if (!gameStarted) {
                    startGame();
                } else if (gameRunning && gameState.balls.length > 0) {
                    launchNextBall(); // Launch balls sequentially
                }
            });
            
            // Add keyboard event listeners
            canvas.addEventListener('keydown', handleGameKeydown);
            canvas.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Add global keyboard handler for start screen (works even when canvas not focused)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'h' || e.key === 'H' || e.key === ' ') {
                    console.log('Document keydown:', e.key, 'gameStarted:', gameStarted, 'gameRunning:', gameRunning, 'gameOverlay.active:', gameOverlay.active);
                }
                
                // Handle start screen keys - allow Hall of Fame even if game was started before
                if (!gameRunning && !gameOverlay.active) {
                    if (e.key === ' ') {
                        e.preventDefault();
                        console.log('Space pressed - starting game');
                        canvas.focus(); // Focus canvas for game controls
                        startGame();
                        return;
                    } else if (e.key === 'h' || e.key === 'H') {
                        e.preventDefault();
                        console.log('H key pressed from start screen - calling showRegularHallOfFame');
                        showRegularHallOfFame();
                        return;
                    }
                }
            });
        }

        // Store current overlay handlers for keyboard events
        let overlayKeydownHandler = null;
        
        // Use canvas-specific keydown handlers
        async function handleGameKeydown(e) {
            // Handle keyboard events for game controls
            // Allow keyboard input when: canvas focused, game overlay active, or on start screen
            if (document.activeElement !== canvas && !gameOverlay.active && gameStarted) {
                return;
            }
            
            // Handle name input for interactive hall of fame
            if (gameOverlay.active && gameOverlay.type === 'hallOfFameInput') {
                console.log('Hall of fame input - Key pressed:', e.key, 'Current input:', gameOverlay.inputName);
                
                if (e.key === 'Enter') {
                    e.preventDefault();
                    console.log('Enter pressed - submitting score');
                    
                    // Submit the score with the entered name
                    const finalName = gameOverlay.inputName.trim() || 'Anonymous';
                    const finalScore = gameOverlay.playerScore;
                    const finalLevel = gameOverlay.playerLevel;
                    
                    console.log('Submitting score:', finalName, finalScore, finalLevel);
                    
                    // Submit score directly (validation happens server-side)
                    try {
                        await submitScore(finalName, finalScore, finalLevel);
                        console.log('Score submitted successfully');
                    } catch (error) {
                        console.error('Score submission error:', error);
                        // Still continue to game over screen even if submission fails
                    }
                    
                    // Show game over screen
                    gameStarted = false; // Now it's safe to return to start screen
                    gameOverlay = {
                        active: true,
                        type: 'gameOver',
                        title: 'üéÆ GAME OVER üéÆ',
                        playerName: finalName,
                        finalScore: finalScore,
                        levelReached: finalLevel,
                        instruction: 'Press H for Hall of Fame or R to Reset'
                    };
                    return;
                } else if (e.key === 'Backspace') {
                    e.preventDefault();
                    gameOverlay.inputName = gameOverlay.inputName.slice(0, -1);
                    return;
                } else if (e.key.length === 1 && gameOverlay.inputName.length < 15) {
                    // Only allow printable characters and limit length
                    if (/^[a-zA-Z0-9\s!@#$%^&*()_+\-=\[\]{}|;':",./<>?`~]$/.test(e.key)) {
                        e.preventDefault();
                        gameOverlay.inputName += e.key;
                    }
                    return;
                }
                return;
            }
            
            // Handle H and R keys for game over screen
            if (gameOverlay.active && gameOverlay.type === 'gameOver') {
                if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    // Store game over data and show hall of fame
                    const gameOverData = {
                        playerName: gameOverlay.playerName,
                        finalScore: gameOverlay.finalScore,
                        levelReached: gameOverlay.levelReached
                    };
                    showRegularHallOfFame(true, gameOverData);
                    return;
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    // Reset the game
                    resetGame();
                    return;
                }
                return; // Don't allow other keys for game over screen
            }
            
            // Handle space key for hall of fame when player didn't qualify
            if (gameOverlay.active && gameOverlay.type === 'hallOfFameNoQualify') {
                if (e.key === ' ') {
                    e.preventDefault();
                    // Show game over screen with final details
                    gameStarted = false; // Now it's safe to return to start screen
                    gameOverlay = {
                        active: true,
                        type: 'gameOver',
                        title: 'üéÆ GAME OVER üéÆ',
                        message: `Final Score: ${gameOverlay.playerScore.toLocaleString()}\nLevel Reached: ${gameOverlay.playerLevel}\nPlayer: Anonymous\n\nYour score didn't make the top 10.`,
                        instruction: 'Press SPACE or CLICK to restart'
                    };
                    return;
                }
                return;
            }
            
            // Handle space key or enter for regular hall of fame (called from button)
            if (gameOverlay.active && gameOverlay.type === 'hallOfFame') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    // Check if we should return to game over screen
                    if (gameOverlay.returnToGameOver) {
                        // Restore the game over screen
                        gameOverlay = {
                            active: true,
                            type: 'gameOver',
                            title: 'üéÆ GAME OVER üéÆ',
                            playerName: gameOverlay.gameOverData.playerName,
                            finalScore: gameOverlay.gameOverData.finalScore,
                            levelReached: gameOverlay.gameOverData.levelReached,
                            instruction: 'Press H for Hall of Fame or R to Reset'
                        };
                    } else {
                        // Just close the hall of fame overlay (called from start screen) - don't allow game start
                        gameOverlay.active = false;
                        removeOverlayKeyHandler();
                        // Ensure we stay on start screen, don't allow immediate restart  
                        gameStarted = false;
                    }
                    return;
                }
                return;
            }
            
            
            keys[e.key] = true;
            if (e.key === ' ') {
                // Only prevent default if not typing in an input field
                const activeElement = document.activeElement;
                const isInputField = activeElement && (
                    activeElement.tagName === 'INPUT' || 
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.contentEditable === 'true'
                );
                
                if (!isInputField) {
                    e.preventDefault();
                    
                    // Handle overlay dismissal first
                    if (gameOverlay.active) {
                        // Don't handle space for interactive hall of fame - only keyboard input
                        if (gameOverlay.type === 'hallOfFameInput') {
                            return;
                        }
                        if (gameOverlay.type === 'levelComplete') {
                            // Continue to next level (level already incremented in nextLevel function)
                            if (level > totalLevels) {
                                // Game completed
                                gameOverlay = {
                                    active: true,
                                    type: 'gameComplete',
                                    title: 'CONGRATULATIONS!',
                                    message: 'You completed all levels!',
                                    instruction: 'Press SPACE to restart'
                                };
                                return;
                            } else {
                                // Level setup already done in nextLevel() - just dismiss overlay
                                gameOverlay.active = false;
                            }
                        } else if (gameOverlay.type === 'gameOver') {
                            // Game over screen doesn't respond to space - use H/R keys instead
                            return;
                        } else if (gameOverlay.type === 'gameComplete') {
                            // Restart from level 1
                            resetGame();
                        } else if (gameOverlay.type === 'levelReady') {
                            // Just dismiss the overlay, game continues
                        } else if (gameOverlay.type === 'paused') {
                            // Unpause the game
                            togglePause();
                            return; // togglePause handles overlay cleanup
                        } else if (gameOverlay.type === 'hallOfFame') {
                            // Check if we should return to game over screen
                            if (gameOverlay.returnToGameOver) {
                                // Restore the game over screen
                                gameOverlay = {
                                    active: true,
                                    type: 'gameOver',
                                    title: 'üéÆ GAME OVER üéÆ',
                                    playerName: gameOverlay.gameOverData.playerName,
                                    finalScore: gameOverlay.gameOverData.finalScore,
                                    levelReached: gameOverlay.gameOverData.levelReached,
                                    instruction: 'Press H for Hall of Fame or R to Reset'
                                };
                                return;
                            } else {
                                // Close hall of fame (called from start screen) - don't allow game start
                                gameOverlay.active = false;
                                // Ensure we stay on start screen, don't allow immediate restart
                                gameStarted = false;
                            }
                        } else if (gameOverlay.type === 'hallOfFameNoQualify') {
                            // Show game over screen with final details
                            const playerScore = gameOverlay.playerScore;
                            const playerLevel = gameOverlay.playerLevel;
                            gameOverlay = {
                                active: true,
                                type: 'gameOver',
                                title: 'üéÆ GAME OVER üéÆ',
                                message: `Final Score: ${playerScore.toLocaleString()}\nLevel Reached: ${playerLevel}\nPlayer: Anonymous\n\nYour score didn't make the top 10.`,
                                instruction: 'Click RESET button below to restart'
                            };
                            return;
                        }
                        
                        gameOverlay.active = false;
                        return;
                    }
                    
                    if (!gameStarted && canvas) {
                        startGame();
                    } else if (gameRunning && gameState.balls.length > 0) {
                        // Launch next ball in sequence or fire laser
                        const ballLaunched = launchNextBall();
                        if (!ballLaunched && paddle.laser) {
                            fireLaser();
                        }
                    } else if (paddle.laser && gameRunning) {
                        fireLaser();
                    }
                }
            }
            if (e.key === 's' || e.key === 'S') {
                soundEnabled = !soundEnabled;
            }
            if ((e.key === 'Escape' || e.key === 'p' || e.key === 'P') && gameStarted && gameRunning) {
                e.preventDefault();
                togglePause();
            }
        }
        
        // Don't attach any global handlers - use dynamic handlers instead
        
        // Add overlay handler when needed
        function addOverlayKeyHandler() {
            if (!overlayKeydownHandler) {
                overlayKeydownHandler = (e) => handleGameKeydown(e);
                document.addEventListener('keydown', overlayKeydownHandler);
            }
        }
        
        // Remove overlay handler when not needed
        function removeOverlayKeyHandler() {
            if (overlayKeydownHandler) {
                document.removeEventListener('keydown', overlayKeydownHandler);
                overlayKeydownHandler = null;
            }
        }
        
        // Event listeners now added inside setupControls() function

        // Particle System
        function createParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 1.0,
                    decay: Math.random() * 0.02 + 0.01
                });
            }
        }

        function updateParticles(deltaMultiplier = 1) {
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.dx * deltaMultiplier;
                particle.y += particle.dy * deltaMultiplier;
                particle.dx *= 0.98;
                particle.dy *= 0.98;
                particle.life -= particle.decay;
                return particle.life > 0;
            });
        }

        function drawParticles() {
            gameState.particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
            });
            ctx.globalAlpha = 1.0;
        }

        // Score Popup System
        function createScorePopup(x, y, points, combo = 1) {
            gameState.scorePopups.push({
                x: x,
                y: y,
                points: points,
                combo: combo,
                life: 2.0, // 2 second lifetime
                startY: y,
                color: combo >= 100 ? '#8B00FF' : combo >= 25 ? '#FF4500' : combo >= 5 ? '#FF8C00' : combo >= 3 ? '#FFD700' : '#FFFFFF'
            });
        }

        function updateScorePopups(deltaMultiplier = 1) {
            gameState.scorePopups = gameState.scorePopups.filter(popup => {
                popup.life -= 0.02 * deltaMultiplier; // Fade over time
                popup.y = popup.startY - (2.0 - popup.life) * 40; // Float upward
                return popup.life > 0;
            });
        }

        function drawScorePopups() {
            gameState.scorePopups.forEach(popup => {
                ctx.save();
                ctx.globalAlpha = popup.life / 2.0;
                ctx.fillStyle = popup.color;
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                
                // Add glow for high combo scores
                if (popup.combo >= 5) {
                    ctx.shadowColor = popup.color;
                    ctx.shadowBlur = 6;
                }
                
                const text = popup.combo > 1 ? `${popup.points} (${popup.combo}x)` : `${popup.points}`;
                ctx.fillText(text, popup.x, popup.y);
                ctx.restore();
            });
        }

        // Power-up System
        // Add powerup timing control
        let lastPowerUpSpawnTime = 0;
        const POWERUP_SPAWN_DELAY = 1000; // 1 second delay between spawns
        const MAX_SIMULTANEOUS_POWERUPS = 4; // Maximum 4 powerups falling at once

        function spawnPowerUp(x, y, forceSpawn = false) {
            const currentTime = Date.now();
            
            // Check timing constraints
            if (currentTime - lastPowerUpSpawnTime < POWERUP_SPAWN_DELAY) {
                return; // Too soon since last powerup
            }
            
            // Count non-laser powerups currently falling
            const fallingPowerUps = gameState.powerUps.filter(p => !p.isLaser).length;
            if (fallingPowerUps >= MAX_SIMULTANEOUS_POWERUPS) {
                return; // Too many powerups already falling
            }
            
            if (forceSpawn || Math.random() < 0.8) { // 80% chance to spawn power-up (unless forced)
                const totalChance = powerUpTypes.reduce((sum, type) => sum + type.chance, 0);
                let random = Math.random() * totalChance;
                
                for (const type of powerUpTypes) {
                    random -= type.chance;
                    if (random <= 0) {
                        gameState.powerUps.push({
                            x: x,
                            y: y,
                            type: type.type,
                            color: type.color,
                            symbol: type.symbol,
                            dy: 2
                        });
                        lastPowerUpSpawnTime = currentTime; // Update last spawn time
                        break;
                    }
                }
            }
        }
        
        // Helper function for consistent powerup spawning on block hits
        function trySpawnPowerUpOnHit(x, y) {
            if (Math.random() < 0.7) { // 70% chance on any block hit (increased from 30%)
                spawnPowerUp(x, y, false); // Use normal spawn logic with timing constraints
            }
        }

        function updatePowerUps(deltaMultiplier = 1) {
            gameState.powerUps = gameState.powerUps.filter(powerUp => {
                powerUp.y += powerUp.dy * deltaMultiplier * SPEED_MULTIPLIER;
                
                // Handle laser beams differently
                if (powerUp.isLaser) {
                    // Remove laser beams that go off screen
                    return powerUp.y > 0;
                }
                
                // Check collision with paddle for regular power-ups
                if (powerUp.y + 10 > paddle.y &&
                    powerUp.x > paddle.x &&
                    powerUp.x < paddle.x + paddle.width) {
                    
                    activatePowerUp(powerUp.type);
                    playSound('powerup');
                    createParticles(powerUp.x, powerUp.y, powerUp.color, 12);
                    return false; // Remove power-up
                }
                
                return powerUp.y < canvas.height; // Keep if still on screen
            });
        }

        function showPowerUpFeedback(message, color = '#FFFFFF') {
            const lineHeight = 20; // Space between lines
            const leftMargin = 160; // Moved more to the left
            const startY = canvas.height * 0.55; // Moved lower - better middle position
            
            // Push existing messages down
            gameState.feedbackMessages.forEach(msg => {
                msg.targetY += lineHeight;
            });
            
            // Add new message at the top
            gameState.feedbackMessages.push({
                text: message,
                x: leftMargin, // Left side but with enough margin for right-aligned text
                y: startY,
                targetY: startY,
                color: color,
                alpha: 1.0,
                scale: 0.1, // Start small
                maxScale: 1.0,
                duration: 300, // 5 seconds at 60fps
                frame: 0
            });
            
            // Remove messages that have been pushed too far down (max 8 lines)
            const maxY = startY + (lineHeight * 7); // 8 lines total (0-7)
            gameState.feedbackMessages = gameState.feedbackMessages.filter(msg => msg.targetY <= maxY);
        }

        function updateFeedbackMessages(deltaMultiplier = 1) {
            gameState.feedbackMessages = gameState.feedbackMessages.filter(msg => {
                msg.frame += deltaMultiplier;
                
                // Smooth vertical movement animation
                const moveSpeed = 0.15 * deltaMultiplier; // How fast messages slide to their target position
                if (Math.abs(msg.y - msg.targetY) > 0.5) {
                    msg.y += (msg.targetY - msg.y) * moveSpeed;
                } else {
                    msg.y = msg.targetY;
                }
                
                // Scale animation: grow quickly to full size
                if (msg.frame < 8) {
                    msg.scale = (msg.frame / 8) * msg.maxScale;
                } else if (msg.frame > msg.duration - 90) {
                    // Fade out over last 1.5 seconds (90 frames)
                    const fadeFrames = msg.duration - msg.frame;
                    msg.alpha = fadeFrames / 90;
                } else {
                    msg.scale = msg.maxScale;
                    msg.alpha = 1.0;
                }
                
                // Remove if duration exceeded
                return msg.frame < msg.duration;
            });
        }

        function drawFeedbackMessages() {
            gameState.feedbackMessages.forEach(msg => {
                ctx.save();
                ctx.globalAlpha = msg.alpha;
                ctx.font = `bold ${Math.floor(13 * msg.scale)}px "Press Start 2P", monospace`;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                
                // Simple glow effect
                ctx.shadowColor = msg.color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = msg.color;
                ctx.fillText(msg.text, msg.x, msg.y);
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // Draw thin black outline for contrast
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeText(msg.text, msg.x, msg.y);
                
                // Draw bright main text in the powerup color
                ctx.fillStyle = msg.color;
                ctx.fillText(msg.text, msg.x, msg.y);
                
                ctx.restore();
            });
        }

        function activatePowerUp(type) {
            sessionStats.powerupsCollected++;
            switch (type) {
                case 'multiball':
                    showPowerUpFeedback('MULTIBALL!', '#00FFFF');
                    // Apply to ALL active balls, not just the first one
                    if (gameState.balls.length < 15) { // Increased limit for multiple balls
                        const currentBalls = [...gameState.balls]; // Copy current balls array
                        for (let ballIndex = 0; ballIndex < currentBalls.length; ballIndex++) {
                            const sourceBall = currentBalls[ballIndex];
                            if (!sourceBall.launched) continue; // Skip unlaunched balls
                            
                            // Create 2 new balls for each existing ball
                            for (let i = 0; i < 2; i++) {
                                const newBall = { ...ballTemplate };
                                newBall.x = sourceBall.x + (Math.random() - 0.5) * 50;
                                newBall.y = sourceBall.y;
                                // Set speed based on source ball's current speed (accounts for slow effect)
                                const newBallSpeed = sourceBall.speed || ballTemplate.speed;
                                newBall.dx = (Math.random() - 0.5) * 8;
                                newBall.dy = -newBallSpeed;
                                newBall.speed = newBallSpeed;
                                newBall.launched = true;
                                newBall.trail = [];
                                newBall.mega = sourceBall.mega; // Inherit mega status
                                newBall.megaStartTime = sourceBall.megaStartTime; // Inherit mega start time
                                newBall.megaDuration = sourceBall.megaDuration; // Inherit mega duration
                                newBall.rocket = sourceBall.rocket; // Inherit rocket status
                                newBall.rocketStartTime = sourceBall.rocketStartTime; // Inherit rocket start time
                                newBall.rocketDuration = sourceBall.rocketDuration; // Inherit rocket duration
                                newBall.slow = sourceBall.slow; // Inherit slow status
                                newBall.slowStartTime = sourceBall.slowStartTime; // Inherit slow start time
                                newBall.slowDuration = sourceBall.slowDuration; // Inherit slow duration
                                newBall.originalSpeed = sourceBall.originalSpeed; // Inherit original speed
                                gameState.balls.push(newBall);
                            }
                        }
                    }
                    break;
                case 'bigpaddle':
                    showPowerUpFeedback('BIG PADDLE!', '#00BFFF');
                    paddle.width = Math.min(paddle.originalWidth * 1.5, 313);
                    paddle.powerUpTimer = 600; // 10 seconds at 60fps
                    break;
                case 'laser':
                    showPowerUpFeedback('LASER!', '#FFD700');
                    paddle.laser = true;
                    paddle.powerUpTimer = 600; // 10 seconds
                    break;
                case 'sticky':
                    showPowerUpFeedback('STICKY PADDLE!', '#00FF7F');
                    paddle.sticky = true;
                    paddle.powerUpTimer = 900; // 15 seconds
                    break;
                case 'extralife':
                    showPowerUpFeedback('+1 LIFE!', '#FF1493');
                    lives++;
                    updateUI();
                    playSound('life');
                    break;
                case 'slowball':
                    showPowerUpFeedback('SLOW BALL!', '#00CED1');
                    gameState.balls.forEach(ball => {
                        ball.slow = true;
                        ball.slowStartTime = Date.now();
                        ball.slowDuration = 5000; // 5 seconds in milliseconds
                        ball.originalSpeed = ball.speed; // Store original speed
                        ball.speed = Math.max(ball.speed * 0.7, 2);
                        const length = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        ball.dx = (ball.dx / length) * ball.speed;
                        ball.dy = (ball.dy / length) * ball.speed;
                    });
                    break;
                case 'megaball':
                    showPowerUpFeedback('EXPLOSIVE BALL!', '#FF4500');
                    gameState.balls.forEach(ball => {
                        ball.mega = true;
                        ball.megaStartTime = Date.now(); // Store start time in milliseconds
                        ball.megaDuration = 6000; // 6 seconds in milliseconds
                    });
                    break;
                case 'rocket':
                    showPowerUpFeedback('ROCKET BALL!', '#FFD700');
                    gameState.balls.forEach(ball => {
                        ball.rocket = true;
                        ball.rocketStartTime = Date.now(); // Store start time in milliseconds
                        ball.rocketDuration = 8000; // 8 seconds in milliseconds
                    });
                    break;
            }
        }

        function initBlocks() {
            blocks.length = 0;
            generateBlocksForLevel(level);
        }

        function generateBlocksForLevel(currentLevel) {
            // Core block patterns for 100-level system
            const patterns = [
                // Pattern 1: Standard rows
                () => {
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const hitCount = getBlockHitCount(currentLevel, row, col);
                            const blockType = getBlockType(currentLevel, row, col);
                            if (shouldPlaceBlock(currentLevel, row, col)) {
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            }
                        }
                    }
                },
                // Pattern 2: Diamond
                () => {
                    for (let row = 0; row < blockRows; row++) {
                        const width = Math.max(1, blockCols - Math.abs(row - blockRows/2) * 2);
                        const start = Math.floor((blockCols - width) / 2);
                        for (let col = start; col < start + width; col++) {
                            const hitCount = getBlockHitCount(currentLevel, row, col);
                            const blockType = getBlockType(currentLevel, row, col);
                            blocks.push(createBlock(col, row, hitCount, blockType));
                        }
                    }
                },
                // Pattern 3: Pyramid
                () => {
                    for (let row = 0; row < blockRows; row++) {
                        const width = blockCols - row * 2;
                        if (width <= 0) break;
                        const start = row;
                        for (let col = start; col < start + width; col++) {
                            const hitCount = getBlockHitCount(currentLevel, row, col);
                            const blockType = getBlockType(currentLevel, row, col);
                            blocks.push(createBlock(col, row, hitCount, blockType));
                        }
                    }
                },
                // Pattern 4: Alternating Rows
                () => {
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if ((row + col) % 2 === 0) {
                                const hitCount = getBlockHitCount(currentLevel, row, col);
                                const blockType = getBlockType(currentLevel, row, col);
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            }
                        }
                    }
                },
                // Pattern 5: Cross Pattern
                () => {
                    const centerRow = Math.floor(blockRows / 2);
                    const centerCol = Math.floor(blockCols / 2);
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if (row === centerRow || col === centerCol || 
                                Math.abs(row - centerRow) === Math.abs(col - centerCol)) {
                                const hitCount = getBlockHitCount(currentLevel, row, col);
                                const blockType = getBlockType(currentLevel, row, col);
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            }
                        }
                    }
                },
                // Pattern 6: Fortress
                () => {
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if (row === 0 || row === blockRows-1 || col === 0 || col === blockCols-1) {
                                const hitCount = getBlockHitCount(currentLevel, row, col, 3);
                                const blockType = getBlockType(currentLevel, row, col);
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            } else if (row === 2 || row === blockRows-3 || col === 2 || col === blockCols-3) {
                                const hitCount = getBlockHitCount(currentLevel, row, col, 2);
                                const blockType = getBlockType(currentLevel, row, col);
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            } else if ((row + col) % 3 === 0) {
                                const hitCount = getBlockHitCount(currentLevel, row, col);
                                const blockType = getBlockType(currentLevel, row, col);
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            }
                        }
                    }
                },
                // Pattern 7: Spiral
                () => {
                    let top = 0, bottom = blockRows - 1, left = 0, right = blockCols - 1;
                    let spiralLevel = 1;
                    
                    while (top <= bottom && left <= right) {
                        // Top row
                        for (let i = left; i <= right; i++) {
                            const hitCount = getBlockHitCount(currentLevel, top, i, spiralLevel);
                            const blockType = getBlockType(currentLevel, top, i);
                            blocks.push(createBlock(i, top, hitCount, blockType));
                        }
                        top++;
                        
                        // Right column
                        for (let i = top; i <= bottom; i++) {
                            const hitCount = getBlockHitCount(currentLevel, i, right, spiralLevel);
                            const blockType = getBlockType(currentLevel, i, right);
                            blocks.push(createBlock(right, i, hitCount, blockType));
                        }
                        right--;
                        
                        // Bottom row
                        if (top <= bottom) {
                            for (let i = right; i >= left; i--) {
                                const hitCount = getBlockHitCount(currentLevel, bottom, i, spiralLevel);
                                const blockType = getBlockType(currentLevel, bottom, i);
                                blocks.push(createBlock(i, bottom, hitCount, blockType));
                            }
                            bottom--;
                        }
                        
                        // Left column
                        if (left <= right) {
                            for (let i = bottom; i >= top; i--) {
                                const hitCount = getBlockHitCount(currentLevel, i, left, spiralLevel);
                                const blockType = getBlockType(currentLevel, i, left);
                                blocks.push(createBlock(left, i, hitCount, blockType));
                            }
                            left++;
                        }
                        
                        spiralLevel = spiralLevel % 4 + 1; // Cycle through 1, 2, 3, 4 hits
                    }
                },
                // Pattern 8: Maze
                () => {
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            if ((row % 2 === 0 && col % 3 !== 1) || 
                                (row % 2 === 1 && col % 3 === 1)) {
                                const hitCount = getBlockHitCount(currentLevel, row, col);
                                const blockType = getBlockType(currentLevel, row, col);
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            }
                        }
                    }
                },
                // Pattern 9: Target
                () => {
                    const centerRow = Math.floor(blockRows / 2);
                    const centerCol = Math.floor(blockCols / 2);
                    for (let row = 0; row < blockRows; row++) {
                        for (let col = 0; col < blockCols; col++) {
                            const distance = Math.sqrt((row - centerRow) ** 2 + (col - centerCol) ** 2);
                            const ring = Math.floor(distance / 1.5);
                            if (ring < 4) {
                                const hitCount = getBlockHitCount(currentLevel, row, col, 4 - ring);
                                const blockType = getBlockType(currentLevel, row, col);
                                blocks.push(createBlock(col, row, hitCount, blockType));
                            }
                        }
                    }
                },
                // Pattern 10: Zigzag
                () => {
                    for (let row = 0; row < blockRows; row++) {
                        const offset = row % 2;
                        for (let col = offset; col < blockCols; col += 2) {
                            const hitCount = getBlockHitCount(currentLevel, row, col);
                            const blockType = getBlockType(currentLevel, row, col);
                            blocks.push(createBlock(col, row, hitCount, blockType));
                        }
                    }
                }
            ];

            // Cycle through patterns for 100 levels, reverse first 5 levels
            let patternIndex;
            if (currentLevel <= 5) {
                // Reverse the first 5 levels: level 1 uses pattern 5, level 2 uses pattern 4, etc.
                patternIndex = (5 - currentLevel) % patterns.length;
            } else {
                patternIndex = (currentLevel - 1) % patterns.length;
            }
            const pattern = patterns[patternIndex];
            pattern();
            
            // Add lava blocks based on level progression rules
            addLavaBlocks(currentLevel);
            
            // TEMPORARY TEST: Add a row of lava blocks in level 1
            if (currentLevel === 1) {
                for (let col = 2; col < 8; col++) { // Row of 6 lava blocks in middle columns
                    const testBlock = createBlock(col, 2, 1, 'lava'); // Row 2 (3rd row), 1 hit lava blocks
                    blocks.push(testBlock);
                }
            }
        }

        // Determine block hit count based on level and position
        function getBlockHitCount(currentLevel, row, col, baseHits = 1) {
            // Block introduction timeline
            if (currentLevel < 15) {
                // Levels 1-14: Only single hit blocks
                return 1;
            } else if (currentLevel < 25) {
                // Levels 15-24: Introduce double hit blocks
                return Math.max(1, Math.min(baseHits, 2));
            } else if (currentLevel < 75) {
                // Levels 25-74: Up to 4-hit blocks (including metal)
                return Math.max(1, Math.min(baseHits, 4));
            } else {
                // Levels 75+: Add 5-hit blocks
                return Math.max(1, Math.min(baseHits, 5));
            }
        }

        // Determine block type based on level and position
        function getBlockType(currentLevel, row, col) {
            // Level 75+: No lava blocks
            if (currentLevel >= 75) {
                // Metal blocks at level 25+
                if (currentLevel >= 25) {
                    // Strategic metal placement for higher levels
                    if ((row === 0 || row === blockRows - 1) && (col % 3 === 0)) {
                        return 'metal';
                    }
                    if ((col === 0 || col === blockCols - 1) && (row % 3 === 0)) {
                        return 'metal';
                    }
                }
                return 'normal';
            }
            
            // Level 7+ but before 75: Lava block logic will be handled separately
            return 'normal';
        }

        // Determine if a block should be placed at this position
        function shouldPlaceBlock(currentLevel, row, col) {
            // For higher levels, create some gaps for strategic play
            if (currentLevel > 50) {
                // Create some strategic gaps
                if ((row + col) % 7 === 0 && row > 0 && row < blockRows - 1) {
                    return false;
                }
            }
            return true;
        }

        // Add lava blocks based on progression rules
        function addLavaBlocks(currentLevel) {
            if (currentLevel < 7 || currentLevel >= 75) {
                return; // No lava blocks before level 7 or after level 75
            }

            if (currentLevel >= 7 && currentLevel < 10) {
                // Level 7-9: Single scattered lava blocks
                addScatteredLavaBlocks(2 + currentLevel - 7); // 2-4 blocks
            } else if (currentLevel >= 10 && currentLevel < 20) {
                // Level 10-19: Short 3-6 block rows
                addLavaRows(3, 6, false);
            } else if (currentLevel >= 20 && currentLevel < 30) {
                // Level 20-29: Doubled up touching patterns
                addTouchingLavaBlocks();
            } else if (currentLevel >= 30 && currentLevel < 50) {
                // Level 30-49: Bottom row lava chains
                addBottomRowLavaChains(Math.min(0.3, (currentLevel - 30) * 0.02)); // Up to 30%
            } else if (currentLevel >= 50 && currentLevel < 75) {
                // Level 50-74: Up to 50% bottom row lava
                addBottomRowLavaChains(Math.min(0.5, (currentLevel - 50) * 0.02 + 0.3)); // 30% to 50%
            }
        }

        // Add scattered individual lava blocks
        function addScatteredLavaBlocks(count) {
            const availablePositions = [];
            blocks.forEach((block, index) => {
                if (block.type === 'normal') {
                    availablePositions.push(index);
                }
            });

            // Randomly select positions for lava blocks
            for (let i = 0; i < Math.min(count, availablePositions.length); i++) {
                const randomIndex = Math.floor(Math.random() * availablePositions.length);
                const blockIndex = availablePositions.splice(randomIndex, 1)[0];
                blocks[blockIndex].type = 'lava';
                blocks[blockIndex].color = '#FF4500'; // Lava orange-red color
            }
        }

        // Add lava blocks in short rows
        function addLavaRows(minLength, maxLength, allowOverlap) {
            const rowLength = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
            const startRow = Math.floor(Math.random() * (blockRows - 1));
            const startCol = Math.floor(Math.random() * (blockCols - rowLength));

            for (let i = 0; i < rowLength; i++) {
                const targetBlock = blocks.find(block => 
                    Math.abs(block.x - (startCol + i) * (blockWidth + blockPadding) - blockPadding) < 5 &&
                    Math.abs(block.y - (startRow * (blockHeight + blockPadding) + 50)) < 5
                );
                
                if (targetBlock && (allowOverlap || targetBlock.type === 'normal')) {
                    targetBlock.type = 'lava';
                    targetBlock.color = '#FF4500';
                }
            }
        }

        // Add touching lava block patterns
        function addTouchingLavaBlocks() {
            const clusters = Math.floor(Math.random() * 3) + 2; // 2-4 clusters
            
            for (let cluster = 0; cluster < clusters; cluster++) {
                const centerRow = Math.floor(Math.random() * (blockRows - 2)) + 1;
                const centerCol = Math.floor(Math.random() * (blockCols - 2)) + 1;
                
                // Create 2x2 or 3x3 clusters
                const clusterSize = Math.random() < 0.5 ? 2 : 3;
                
                for (let dr = 0; dr < clusterSize; dr++) {
                    for (let dc = 0; dc < clusterSize; dc++) {
                        const targetBlock = blocks.find(block => 
                            Math.abs(block.x - ((centerCol + dc) * (blockWidth + blockPadding) + blockPadding)) < 5 &&
                            Math.abs(block.y - ((centerRow + dr) * (blockHeight + blockPadding) + 50)) < 5
                        );
                        
                        if (targetBlock && targetBlock.type === 'normal') {
                            targetBlock.type = 'lava';
                            targetBlock.color = '#FF4500';
                        }
                    }
                }
            }
        }

        // Add bottom row lava chains
        function addBottomRowLavaChains(percentage) {
            const bottomRow = blockRows - 1;
            const lavaCount = Math.floor(blockCols * percentage);
            
            // Start from random position and create chains
            let startCol = Math.floor(Math.random() * (blockCols - lavaCount));
            
            for (let i = 0; i < lavaCount; i++) {
                const targetBlock = blocks.find(block => 
                    Math.abs(block.x - ((startCol + i) * (blockWidth + blockPadding) + blockPadding)) < 5 &&
                    Math.abs(block.y - (bottomRow * (blockHeight + blockPadding) + 50)) < 5
                );
                
                if (targetBlock) {
                    targetBlock.type = 'lava';
                    targetBlock.color = '#FF4500';
                }
            }
        }

        function createBlock(col, row, hits = 1, type = 'normal', color = null) {
            const isMetalBrick = type === 'metal';
            const isLavaBrick = type === 'lava';
            
            let blockColor;
            if (color) {
                blockColor = color; // Use specific color for pixel art
            } else if (isMetalBrick) {
                blockColor = '#666666';
            } else if (isLavaBrick) {
                blockColor = '#FF4500'; // Lava orange-red color
            } else if (hits === 5) {
                // Special ultra-hard block color - diamond-like appearance
                blockColor = '#E6E6FA'; // Lavender for diamond/crystal appearance
            } else {
                blockColor = blockColors[row % blockColors.length];
            }
            
            return {
                x: col * (blockWidth + blockPadding) + blockPadding,
                y: row * (blockHeight + blockPadding) + 63,
                width: blockWidth,
                height: blockHeight,
                color: blockColor,
                destroyed: false,
                hits: hits,
                maxHits: hits,
                type: type,
                exploded: false // Track if this lava block already exploded to prevent infinite loops
            };
        }

        // Lava block explosion system with chain reactions
        function explodeLavaBlock(centerBlock, explosionQueue = new Set()) {
            if (explosionQueue.has(centerBlock)) return; // Prevent infinite loops
            explosionQueue.add(centerBlock);
            
            // Find all blocks in the 8 surrounding positions
            const surroundingBlocks = blocks.filter(block => {
                if (block.destroyed || block === centerBlock) return false;
                
                // Check if block is in the 8 surrounding positions
                const deltaX = Math.abs(block.x - centerBlock.x);
                const deltaY = Math.abs(block.y - centerBlock.y);
                
                return deltaX <= blockWidth + blockPadding && 
                       deltaY <= blockHeight + blockPadding &&
                       (deltaX > 0 || deltaY > 0); // Exclude the center block itself
            });
            
            // Damage surrounding blocks with staggered timing for visual effect
            surroundingBlocks.forEach((block, index) => {
                setTimeout(() => {
                    if (!block.destroyed) {
                        // Deal 3 hits of damage to the block
                        block.hits -= 3;
                        
                        // Create damage particles even if block isn't destroyed
                        createParticles(block.x + block.width / 2, block.y + block.height / 2, '#FF6500', 8);
                        
                        // Only destroy if hits drop to 0 or below
                        if (block.hits <= 0) {
                            block.destroyed = true;
                            sessionStats.blocksDestroyed++;
                            // Lava chain reactions use combo multiplier for explosive scoring
                            const basePoints = 15 * gameState.multiplier;
                            const comboMultiplier = Math.min(gameState.combo, 500);
                            const points = basePoints * comboMultiplier;
                            updateScore(points);
                            createScorePopup(block.x + block.width / 2, block.y + block.height / 2, points, gameState.combo);
                            createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color, 12);
                            
                            // If this block is also lava, trigger its explosion
                            if (block.type === 'lava') {
                                explodeLavaBlock(block, explosionQueue);
                            }
                            
                            // Play explosion sound effect
                            playSound('powerup'); // Use powerup sound for dramatic effect
                        } else {
                            // Block survived the damage - play different sound and show damage indicator
                            playSound('block'); // Regular hit sound for damaged but surviving blocks
                            createScorePopup(block.x + block.width / 2, block.y + block.height / 2 - 15, '-3', 1);
                        }
                    }
                }, index * 50); // 50ms delay between each explosion for visual drama
            });
        }

        async function resetGame() {
            console.log('RESET: Starting resetGame function');
            gameRunning = false;
            gamePaused = false;
            gameStarted = false;
            score = 0;
            lives = 3;
            level = 1;
            console.log('RESET: Basic variables set - lives:', lives, 'level:', level, 'score:', score);
            // Preserve logged-in user's name during reset
            if (typeof currentUser !== 'undefined' && currentUser && currentUser.username) {
                playerName = currentUser.username;
            } else {
                playerName = ''; // Reset player name to prompt again for anonymous users
            }
            scoreSubmitted = false; // Reset score submission flag
            legitGameCompleted = false; // Reset legitimate game completion flag
            lastFrameTime = 0; // Reset frame timing for accurate delta calculation
            
            // Reset session tracking (but don't reinitialize during reset to avoid errors)
            gameSessionId = null;
            gameSessionToken = null;
            console.log('RESET: Session tracking cleared');
            sessionStats = {
                blocksDestroyed: 0,
                livesLost: 0,
                powerupsCollected: 0
            };
            
            // Secure session already initialized above
            
            if (!canvas) return;
            
            // Reset paddle
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.width = paddle.originalWidth;
            paddle.laser = false;
            paddle.sticky = false;
            paddle.powerUpTimer = 0;
            paddle.lastX = paddle.x; // Initialize lastX to prevent velocity glitch
            paddle.velocity = 0; // Reset velocity
            
            // Reset game state
            gameState.balls = [];
            gameState.powerUps = [];
            gameState.particles = [];
            gameState.feedbackMessages = [];
            gameState.scorePopups = [];
            gameState.screenShake = 0;
            gameState.multiplier = 1;
            gameState.combo = 0;
            
            // Initialize first ball
            const firstBall = {
                x: canvas.width / 2,
                y: paddle.y - 20,
                radius: 10,
                dx: 0,
                dy: 0,
                speed: 5, // Hard-coded to base speed - NO level increases
                launched: false,
                trail: []
            };
            console.log(`Game reset at level ${level}: Ball speed set to ${firstBall.speed} (base: 5)`);
            gameState.balls = [firstBall];
            
            // Reset blocks - force clear and regenerate
            blocks.length = 0; // Clear the blocks array completely
            console.log('Blocks cleared, count:', blocks.length);
            initBlocks();
            console.log('Blocks regenerated, count:', blocks.length);
            console.log('Reset complete - Lives:', lives, 'Level:', level, 'Score:', score);
            
            // Update UI
            updateUI();
            
            // Clear any active overlays
            gameOverlay.active = false;
            removeOverlayKeyHandler();
            
            // Reset buttons
            if (pauseBtn) pauseBtn.disabled = true;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Ensure we show the start screen by drawing once and starting game loop
            draw();
            
            // Restart the game loop to show the start screen (not started, not running)
            if (!animationId) {
                gameLoop();
            }
            
            console.log('RESET: Function completed successfully!');
        }

        function startGame() {
            if (!gameStarted && canvas) {
                // Prevent starting new game if player completed game but didn't use reset button
                if (legitGameCompleted) {
                    console.log("Game start blocked - use reset button to start new game");
                    return;
                }
                
                // Cancel any existing animation frames before starting
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                
                // Set player name - Default to Anonymous, allow override at end of game
                if (typeof currentUser !== 'undefined' && currentUser && currentUser.username) {
                    playerName = currentUser.username;
                } else {
                    // Default to Anonymous - player can change name at end of game
                    playerName = "Anonymous";
                }
                
                console.log("Player name set to:", playerName); // Debug log
                
                gameStarted = true;
                gameRunning = true;
                scoreSubmitted = false; // Ensure score can be submitted for this new game
                lastFrameTime = 0; // Reset frame timing for accurate delta calculation
                if (pauseBtn) pauseBtn.disabled = false;
                gameLoop();
            }
        }

        function togglePause() {
            if (gameRunning) {
                gamePaused = !gamePaused;
                if (pauseBtn) pauseBtn.textContent = gamePaused ? 'Resume' : 'Pause';
                
                if (gamePaused) {
                    // Show pause overlay
                    gameOverlay = {
                        active: true,
                        type: 'paused',
                        title: 'GAME PAUSED',
                        message: 'Press ESC, P, or SPACE to resume',
                        instruction: 'Click or press any key to continue'
                    };
                } else {
                    // Hide pause overlay - game loop will automatically resume
                    // since it continues running but only updates when not paused
                    gameOverlay.active = false;
                    // Don't call gameLoop() again - it's already running
                }
            }
        }

        function launchBall(ball) {
            if (!ball) return;
            ball.launched = true;
            
            // If ball was stuck to paddle, launch from its contact point with proper angle
            if (ball.stuckToPaddle && ball.stickOffset !== undefined) {
                // Calculate launch angle based on contact point (same as bounce calculation)
                const hitPos = ball.stickOffset / paddle.width;
                const bounceAngle = (hitPos - 0.5) * Math.PI / 2.2; // Same steeper angle as bounce
                
                ball.dx = Math.sin(bounceAngle) * ball.speed;
                ball.dy = -Math.cos(bounceAngle) * ball.speed;
                
                // Ensure minimum upward velocity to prevent horizontal-only launches
                if (Math.abs(ball.dy) < ball.speed * 0.3) {
                    ball.dy = -ball.speed * 0.3;
                }
            } else {
                // Default launch for unlaunched balls (slight randomness)
                const angle = (Math.random() - 0.5) * Math.PI / 4; // Random angle between -45 and 45 degrees
                ball.dx = Math.sin(angle) * ball.speed;
                ball.dy = -Math.cos(angle) * ball.speed;
            }
            
            // Debug logging for ball launch
            const launchSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
            console.log(`Ball launched at level ${level}: dx=${ball.dx.toFixed(2)}, dy=${ball.dy.toFixed(2)}, speed=${launchSpeed.toFixed(2)}, base speed=${ball.speed}`);
            
            ball.trail = []; // Clear any existing trail when launching
        }
        
        function launchNextBall() {
            // Launch balls sequentially: first any unlaunched balls, then stuck balls in order
            let ballLaunched = false;
            
            // First priority: launch any unlaunched balls (game start)
            for (let ball of gameState.balls) {
                if (!ball.launched && !ball.stuckToPaddle) {
                    launchBall(ball);
                    ballLaunched = true;
                    break; // Only launch one at a time
                }
            }
            
            // Second priority: launch stuck balls in sequential order
            if (!ballLaunched) {
                const stuckBalls = gameState.balls
                    .filter(ball => ball.stuckToPaddle)
                    .sort((a, b) => (a.stickOrder || 0) - (b.stickOrder || 0));
                
                if (stuckBalls.length > 0) {
                    const nextBall = stuckBalls[0];
                    launchBall(nextBall);
                    nextBall.stuckToPaddle = false;
                    nextBall.stickOrder = undefined;
                    nextBall.stickOffset = undefined; // Clear the contact point
                    ballLaunched = true;
                }
            }
            
            return ballLaunched;
        }

        function fireLaser() {
            if (!paddle.laser) return;
            
            // Create laser beams
            for (let i = 0; i < 2; i++) {
                gameState.powerUps.push({
                    x: paddle.x + paddle.width * (0.25 + i * 0.5),
                    y: paddle.y,
                    type: 'laser_beam',
                    color: '#FFD700',
                    symbol: '|',
                    dy: -8,
                    isLaser: true
                });
            }
        }

        function updatePaddle(deltaMultiplier = 1) {
            // Store previous position for velocity calculation
            const prevX = paddle.x;
            let keyboardControl = false;
            
            // Keyboard controls - always take priority
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                paddle.x -= paddle.speed * deltaMultiplier;
                keyboardControl = true;
                // Clear mouse position when using keyboard to prevent snap-back
                mouseX = 0;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D'] || keys['w'] || keys['W']) {
                paddle.x += paddle.speed * deltaMultiplier;
                keyboardControl = true;
                // Clear mouse position when using keyboard to prevent snap-back
                mouseX = 0;
            }
            
            // Mouse/touch controls - only when no keyboard input
            if (!keyboardControl) {
                if (mouseX > 0) {
                    paddle.x = mouseX - paddle.width / 2;
                }
                if (touchX > 0) {
                    paddle.x = touchX - paddle.width / 2;
                }
            }
            
            // Keep paddle within bounds
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }
            
            // Calculate paddle velocity (current position - previous position)
            const rawVelocity = paddle.x - prevX;
            
            // Limit velocity to maximum achievable with arrow keys (paddle.speed)
            // This prevents mouse users from getting unfair advantage
            paddle.velocity = Math.max(-paddle.speed, Math.min(paddle.speed, rawVelocity));
            
            // Store current position for next frame
            paddle.lastX = paddle.x;
            
            // Update power-up timers
            if (paddle.powerUpTimer > 0) {
                paddle.powerUpTimer--;
                if (paddle.powerUpTimer <= 0) {
                    // When sticky expires, keep balls stuck until player launches them manually
                    // This maintains the same behavior as the initial ball at round start
                    paddle.width = paddle.originalWidth;
                    paddle.laser = false;
                    paddle.sticky = false;
                }
            }
            
            // Move unlaunched balls and balls stuck to paddle
            gameState.balls.forEach(ball => {
                if (!ball.launched) {
                    // Unlaunched balls stay centered
                    ball.x = paddle.x + paddle.width / 2;
                    ball.y = paddle.y - ball.radius;
                } else if (ball.stuckToPaddle) {
                    // Stuck balls maintain their contact point
                    ball.x = paddle.x + (ball.stickOffset || paddle.width / 2);
                    ball.y = paddle.y - ball.radius;
                    // Clamp to paddle bounds
                    ball.x = Math.max(paddle.x + ball.radius, Math.min(paddle.x + paddle.width - ball.radius, ball.x));
                }
            });
        }

        function updateBalls(deltaMultiplier = 1) {
            gameState.balls = gameState.balls.filter(ball => {
                if (!ball.launched) return true;
                
                // Debug logging for ball velocity
                if (Math.random() < 0.01) { // Log occasionally to avoid spam
                    const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    console.log(`Level ${level}: Ball velocity dx=${ball.dx.toFixed(2)}, dy=${ball.dy.toFixed(2)}, speed=${currentSpeed.toFixed(2)}, base speed=${ball.speed}`);
                }
                
                // Update ball position with frame-rate independent physics (2.4x speed for 144 FPS feel)
                // Apply slow effect only when slow powerup is active
                const ballSpeedMultiplier = ball.slow ? (SPEED_MULTIPLIER * 0.5) : SPEED_MULTIPLIER;
                ball.x += ball.dx * deltaMultiplier * ballSpeedMultiplier;
                ball.y += ball.dy * deltaMultiplier * ballSpeedMultiplier;
                
                // Update ball trail
                ball.trail.push({ x: ball.x, y: ball.y });
                if (ball.trail.length > 5) ball.trail.shift();
                
                // Update mega ball timer (time-based, frame-rate independent)
                if (ball.mega && ball.megaStartTime) {
                    const elapsedTime = Date.now() - ball.megaStartTime;
                    if (elapsedTime >= ball.megaDuration) {
                        ball.mega = false;
                        ball.megaStartTime = undefined;
                        ball.megaDuration = undefined;
                    }
                }
                
                // Update rocket ball timer (time-based, frame-rate independent)
                if (ball.rocket && ball.rocketStartTime) {
                    const elapsedTime = Date.now() - ball.rocketStartTime;
                    if (elapsedTime >= ball.rocketDuration) {
                        ball.rocket = false;
                        ball.rocketStartTime = undefined;
                        ball.rocketDuration = undefined;
                    }
                }
                
                // Update slow ball timer (time-based, frame-rate independent)
                if (ball.slow && ball.slowStartTime) {
                    const elapsedTime = Date.now() - ball.slowStartTime;
                    if (elapsedTime >= ball.slowDuration) {
                        ball.slow = false;
                        ball.slowStartTime = undefined;
                        ball.slowDuration = undefined;
                        // Restore original speed
                        if (ball.originalSpeed) {
                            ball.speed = ball.originalSpeed;
                            const length = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                            ball.dx = (ball.dx / length) * ball.speed;
                            ball.dy = (ball.dy / length) * ball.speed;
                            ball.originalSpeed = undefined;
                        }
                    }
                }
                
                // Wall collisions with proper positioning to prevent getting stuck
                if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius; // Push ball back inside boundary
                    ball.dx = -Math.abs(ball.dx); // Ensure ball moves left
                    playSound('paddle');
                } else if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius; // Push ball back inside boundary
                    ball.dx = Math.abs(ball.dx); // Ensure ball moves right
                    playSound('paddle');
                }
                
                if (ball.y - ball.radius < 0) {
                    ball.y = ball.radius; // Push ball back inside boundary
                    ball.dy = Math.abs(ball.dy); // Ensure ball moves down
                    playSound('paddle');
                }
                
                // Enhanced paddle collision detection with better edge case handling
                if (ball.y + ball.radius >= paddle.y &&
                    ball.y - ball.radius < paddle.y + paddle.height &&
                    ball.x + ball.radius > paddle.x &&
                    ball.x - ball.radius < paddle.x + paddle.width &&
                    ball.dy > 0) {
                    
                    // Ensure ball is properly positioned above paddle
                    ball.y = paddle.y - ball.radius;
                    
                    // Prevent ball from getting stuck inside paddle
                    if (ball.y + ball.radius > paddle.y) {
                        ball.y = paddle.y - ball.radius;
                    }
                    
                    playSound('paddle');
                    
                    if (paddle.sticky && ball.launched && !ball.stuckToPaddle) {
                        ball.launched = false;
                        ball.dx = 0;
                        ball.dy = 0;
                        ball.stuckToPaddle = true; // Mark as stuck to paddle
                        ball.trail = []; // Clear trail when ball gets stuck to prevent ghost trails
                        
                        // Store the contact point relative to paddle for consistent positioning
                        ball.stickOffset = ball.x - paddle.x;
                        
                        // Clamp stick offset to prevent balls from appearing outside paddle bounds
                        ball.stickOffset = Math.max(ball.radius, Math.min(paddle.width - ball.radius, ball.stickOffset));
                        
                        // Assign a stick order number for sequential release
                        const maxStickOrder = Math.max(0, ...gameState.balls.filter(b => b.stuckToPaddle).map(b => b.stickOrder || 0));
                        ball.stickOrder = maxStickOrder + 1;
                        return true;
                    }
                    
                    // Calculate bounce angle based on where ball hits paddle (normalized positioning)
                    const hitPos = Math.max(0, Math.min(1, (ball.x - paddle.x) / paddle.width));
                    const bounceAngle = (hitPos - 0.5) * Math.PI / 2.2; // Consistent angle calculation
                    
                    // Base velocity from angle - normalized for consistency
                    const baseDx = Math.sin(bounceAngle) * ball.speed;
                    const baseDy = -Math.cos(bounceAngle) * ball.speed;
                    
                    // Add paddle velocity for skill-based control with consistent scaling
                    const isReturningBall = ball.dy > 0;
                    const velocityTransfer = isReturningBall ? paddle.velocity * 0.15 : 0; // Reduced from 0.2 for consistency
                    
                    ball.dx = baseDx + velocityTransfer;
                    ball.dy = baseDy;
                    
                    // Normalize final velocity to maintain consistent speed
                    const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    const targetSpeed = ball.speed * 1.1; // Consistent 110% max speed
                    
                    if (currentSpeed > targetSpeed) {
                        const scale = targetSpeed / currentSpeed;
                        ball.dx *= scale;
                        ball.dy *= scale;
                    } else if (currentSpeed < ball.speed * 0.8) {
                        // Ensure minimum speed to prevent slow balls
                        const scale = (ball.speed * 0.8) / currentSpeed;
                        ball.dx *= scale;
                        ball.dy *= scale;
                    }
                    
                    // Ensure consistent minimum vertical speed
                    const minVerticalSpeed = ball.speed * 0.4;
                    if (Math.abs(ball.dy) < minVerticalSpeed) {
                        ball.dy = ball.dy < 0 ? -minVerticalSpeed : minVerticalSpeed;
                        // Recalculate dx to maintain target speed
                        const remainingSpeed = Math.sqrt(Math.max(0, (ball.speed * ball.speed) - (ball.dy * ball.dy)));
                        ball.dx = ball.dx >= 0 ? remainingSpeed : -remainingSpeed;
                    }
                }
                
                // Strict boundary enforcement - prevent balls from going below paddle level
                if (ball.y + ball.radius > paddle.y + paddle.height + 5) {
                    // Clear the trail before removing the ball
                    ball.trail = [];
                    return false; // Remove this ball
                }
                
                // Additional safety check - if ball somehow gets far below screen
                if (ball.y > canvas.height + ball.radius) {
                    ball.trail = [];
                    return false;
                }
                
                return true; // Keep this ball
            });
            
            // Check if all balls are gone
            if (gameState.balls.length === 0 && gameRunning) {
                lives--;
                sessionStats.livesLost++;
                console.log(`Lives decremented to: ${lives}`);
                updateUI();
                
                if (lives <= 0) {
                    console.log('Calling gameOver() - no lives left');
                    gameOver();
                } else {
                    console.log('Resetting balls for next life');
                    resetBalls();
                }
            }
        }

        function checkBlockCollisions() {
            gameState.balls.forEach(ball => {
                if (!ball.launched) return;
                
                for (let block of blocks) {
                    if (block.destroyed) continue;
                    
                    if (ball.x + ball.radius > block.x &&
                        ball.x - ball.radius < block.x + block.width &&
                        ball.y + ball.radius > block.y &&
                        ball.y - ball.radius < block.y + block.height) {
                        
                        // Check if this is a metal brick - only rocket and explosive balls can destroy them
                        const isMetalBrick = block.type === 'metal';
                        if (isMetalBrick && !ball.rocket && !ball.mega) {
                            // Metal brick - only rocket and explosive balls can destroy, but ball still bounces
                            const ballCenterX = ball.x;
                            const ballCenterY = ball.y;
                            const blockCenterX = block.x + block.width / 2;
                            const blockCenterY = block.y + block.height / 2;
                            
                            const deltaX = ballCenterX - blockCenterX;
                            const deltaY = ballCenterY - blockCenterY;
                            
                            // Determine collision side and bounce
                            if (Math.abs(deltaX / block.width) > Math.abs(deltaY / block.height)) {
                                ball.dx = -ball.dx; // Hit left or right side
                            } else {
                                ball.dy = -ball.dy; // Hit top or bottom
                            }
                            
                            // Spawn powerup when metal block is hit (even though not destroyed)
                            // Metal blocks have a much higher chance of spawning powerups (80%)
                            if (Math.random() < 0.8) {
                                spawnPowerUp(blockCenterX, blockCenterY, true);
                                // Create visual feedback for powerup spawn from metal block
                                createParticles(blockCenterX, blockCenterY, '#FFD700', 10); // Gold particles
                            } else {
                                // Even if no powerup, still create some visual feedback
                                createParticles(blockCenterX, blockCenterY, '#CCCCCC', 5); // Silver particles
                            }
                            
                            // Metal blocks create a bigger screen shake
                            playSound('block');
                            gameState.screenShake = 5;
                            break;
                        }
                        
                        // Rocket ball destroys block instantly but doesn't deflect (except metal bricks)
                        if (ball.rocket) {
                            block.destroyed = true;
                            sessionStats.blocksDestroyed++;
                            
                            // Scoring with combo system - combo multiplies points
                            gameState.combo++;
                            const basePoints = 10 * gameState.multiplier;
                            const comboMultiplier = Math.min(gameState.combo, 500); // Allow up to 500x combo
                            const points = basePoints * comboMultiplier;
                            updateScore(points);
                            createScorePopup(block.x + block.width / 2, block.y + block.height / 2, points, gameState.combo);
                            
                            // Spawn power-up on destruction
                            trySpawnPowerUpOnHit(block.x + block.width / 2, block.y + block.height / 2);
                            
                            // Create particles
                            createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color);
                            
                            // If this block is lava, trigger explosion
                            if (block.type === 'lava') {
                                explodeLavaBlock(block);
                            }
                            
                            // Rocket + Explosive combo: explode surrounding blocks too
                            if (ball.mega) {
                                const adjacentBlocks = blocks.filter(b => 
                                    !b.destroyed && 
                                    Math.abs(b.x - block.x) <= blockWidth + blockPadding &&
                                    Math.abs(b.y - block.y) <= blockHeight + blockPadding
                                );
                                
                                adjacentBlocks.forEach(adjBlock => {
                                    // Only destroy if not metal brick, or if it's a metal brick and we can destroy it
                                    if (adjBlock.type !== 'metal') {
                                        adjBlock.destroyed = true;
                                        sessionStats.blocksDestroyed++;
                                        const comboPoints = 10 * gameState.multiplier * Math.min(gameState.combo, 500);
                                        updateScore(comboPoints);
                                        createParticles(adjBlock.x + adjBlock.width / 2, adjBlock.y + adjBlock.height / 2, adjBlock.color);
                                        // Consistent powerup chance for explosive destruction
                                        trySpawnPowerUpOnHit(adjBlock.x + adjBlock.width / 2, adjBlock.y + adjBlock.height / 2);
                                    }
                                });
                                
                                gameState.screenShake = 8; // Bigger shake for combo effect
                            }
                            
                            updateUI();
                            playSound('block');
                            if (!ball.mega) gameState.screenShake = 3;
                            
                            // Rocket ball continues through - no deflection for regular bricks
                            if (isMetalBrick) {
                                // Only deflect off metal bricks
                                const ballCenterX = ball.x;
                                const ballCenterY = ball.y;
                                const blockCenterX = block.x + block.width / 2;
                                const blockCenterY = block.y + block.height / 2;
                                
                                const deltaX = ballCenterX - blockCenterX;
                                const deltaY = ballCenterY - blockCenterY;
                                
                                if (Math.abs(deltaX / block.width) > Math.abs(deltaY / block.height)) {
                                    ball.dx = -ball.dx;
                                } else {
                                    ball.dy = -ball.dy;
                                }
                            }
                        } else {
                            // Regular ball collision - handle multi-hit blocks
                            block.hits--;
                            
                            // Consistent powerup chance on any hit
                            trySpawnPowerUpOnHit(block.x + block.width / 2, block.y + block.height / 2);
                            
                            if (block.hits <= 0) {
                                block.destroyed = true;
                                sessionStats.blocksDestroyed++;
                                
                                // Scoring with combo system - combo multiplies points
                                gameState.combo++;
                                const basePoints = 10 * gameState.multiplier;
                                const comboMultiplier = Math.min(gameState.combo, 500); // Allow up to 500x combo
                                const points = basePoints * comboMultiplier;
                                updateScore(points);
                                createScorePopup(block.x + block.width / 2, block.y + block.height / 2, points, gameState.combo);
                                
                                // Note: Powerup already attempted above for consistency
                                
                                // Create particles
                                createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color);
                                
                                // If this block is lava, trigger explosion
                                if (block.type === 'lava') {
                                    explodeLavaBlock(block);
                                }
                            }
                            
                            updateUI();
                            playSound('block');
                            gameState.screenShake = 3;
                            
                            // Ball collision response (improved physics)
                            const ballCenterX = ball.x;
                            const ballCenterY = ball.y;
                            const blockCenterX = block.x + block.width / 2;
                            const blockCenterY = block.y + block.height / 2;
                            
                            const deltaX = ballCenterX - blockCenterX;
                            const deltaY = ballCenterY - blockCenterY;
                            
                            // Determine collision side
                            if (Math.abs(deltaX / block.width) > Math.abs(deltaY / block.height)) {
                                ball.dx = -ball.dx; // Hit left or right side
                            } else {
                                ball.dy = -ball.dy; // Hit top or bottom
                            }
                            
                            // Mega ball destroys multiple blocks
                            if (ball.mega) {
                                const adjacentBlocks = blocks.filter(b => 
                                    !b.destroyed && 
                                    Math.abs(b.x - block.x) <= blockWidth + blockPadding &&
                                    Math.abs(b.y - block.y) <= blockHeight + blockPadding
                                );
                                
                                adjacentBlocks.forEach(adjBlock => {
                                    adjBlock.destroyed = true;
                                    sessionStats.blocksDestroyed++;
                                    const comboPoints = 10 * gameState.multiplier * Math.min(gameState.combo, 500);
                                    updateScore(comboPoints);
                                    createParticles(adjBlock.x + adjBlock.width / 2, adjBlock.y + adjBlock.height / 2, adjBlock.color);
                                });
                            }
                        }
                        
                        // Check win condition
                        if (blocks.every(block => block.destroyed)) {
                            nextLevel();
                        }
                        
                        break;
                    }
                }
                
            });
            
            // Handle laser beam collisions separately
            gameState.powerUps.forEach((laser, laserIndex) => {
                if (!laser.isLaser) return;
                
                for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {
                    const block = blocks[blockIndex];
                    if (block.destroyed) continue;
                    
                    if (laser.x >= block.x && laser.x <= block.x + block.width &&
                        laser.y >= block.y && laser.y <= block.y + block.height) {
                        
                        // Check if this is a metal brick - lasers cannot damage them
                        if (block.type === 'metal') {
                            // Remove the laser beam but don't damage metal block
                            gameState.powerUps.splice(laserIndex, 1);
                            playSound('block'); // Still make sound for feedback
                            break;
                        }
                        
                        // Handle multi-hit blocks properly - reduce hits by 1
                        block.hits--;
                        
                        // Consistent powerup chance on laser hit
                        trySpawnPowerUpOnHit(block.x + block.width / 2, block.y + block.height / 2);
                        
                        if (block.hits <= 0) {
                            block.destroyed = true;
                            sessionStats.blocksDestroyed++;
                            // Create particles when block is destroyed
                            createParticles(block.x + block.width / 2, block.y + block.height / 2, block.color);
                            
                            // If this block is lava, trigger explosion
                            if (block.type === 'lava') {
                                explodeLavaBlock(block);
                            }
                        }
                        
                        updateScore(5 * gameState.multiplier);
                        updateUI();
                        playSound('block');
                        
                        // Remove the laser beam
                        gameState.powerUps.splice(laserIndex, 1);
                        
                        // Check win condition
                        if (blocks.every(block => block.destroyed)) {
                            nextLevel();
                        }
                        
                        break;
                    }
                }
            });
        }

        function resetBalls() {
            // Clear all existing balls and their trails
            gameState.balls.forEach(ball => {
                if (ball.trail) ball.trail = [];
            });
            gameState.balls = [];
            
            const newBall = {
                x: canvas.width / 2,
                y: paddle.y - 20,
                radius: 10,
                dx: 0,
                dy: 0,
                speed: 5, // Hard-coded to base speed - NO level increases
                launched: false,
                trail: []
            };
            console.log(`After life lost at level ${level}: Ball speed set to ${newBall.speed} (base: 5)`);
            gameState.balls = [newBall];
            gameState.combo = 0;
        }

        function nextLevel() {
            const completedLevel = level;
            level++;
            gameState.multiplier = 1; // Keep multiplier constant, no level-based increases
            
            // DEBUG: Log all game variables at level transition
            console.log(`=== LEVEL TRANSITION FROM ${completedLevel} TO ${level} ===`);
            console.log('ballTemplate.speed:', ballTemplate.speed);
            console.log('paddle.speed:', paddle.speed);
            console.log('gameState:', JSON.stringify(gameState));
            console.log('Current balls:', gameState.balls.map(b => ({speed: b.speed, dx: b.dx, dy: b.dy})));
            
            // STEP 1: Stop all balls and game action
            gameState.balls = [];
            gameState.powerUps = gameState.powerUps.filter(p => p.isLaser);
            gameState.particles = [];
            gameState.feedbackMessages = [];
            gameState.combo = 0;
            
            // STEP 2: Pause the game loop temporarily
            const wasRunning = gameRunning;
            gameRunning = false;
            
            playSound('win');
            
            // STEP 3: Show level completion overlay immediately
            setTimeout(() => {
                gameOverlay = {
                    type: 'levelComplete',
                    completedLevel: completedLevel,
                    score: score.toLocaleString(),
                    nextLevel: level
                };
                
                // STEP 4: Set up next level immediately (don't wait for user input)
                setupNextLevel();
                
                if (wasRunning) {
                    gameRunning = true;
                    // Don't call gameLoop() - it's already running and will resume automatically
                }
            }, 100); // Reduced from 300ms to 100ms
        }
        
        function setupNextLevel() {
            // Initialize new level blocks
            initBlocks();
            
            // Reset paddle position and properties
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.width = paddle.originalWidth;
            paddle.laser = false;
            paddle.sticky = false;
            paddle.powerUpTimer = 0;
            paddle.lastX = paddle.x; // Initialize lastX to prevent velocity glitch
            paddle.velocity = 0; // Reset velocity
            
            // Clear any remaining power-ups and particles completely
            gameState.powerUps = [];
            gameState.particles = []; // Clear all particles that could cause performance issues
            gameState.scorePopups = []; // Clear score popups
            gameState.feedbackMessages = [];
            gameState.combo = 0;
            gameState.screenShake = 0;
            
            // Force garbage collection of any lingering objects
            if (window.gc) window.gc();
            
            // CRITICAL FIX: Clear all balls and their effects completely - don't modify existing balls
            // The old balls with their effects were causing frame rate issues
            gameState.balls = [];
            
            const newBall = {
                x: paddle.x + paddle.width / 2,
                y: paddle.y - 20,
                radius: 10,
                dx: 0,
                dy: 0,
                speed: 5, // Hard-coded to base speed - NO level increases
                launched: false,
                trail: []
            };
            console.log(`Level ${level}: Ball speed set to ${newBall.speed} (base: 5, ballTemplate: ${ballTemplate.speed})`);
            gameState.balls = [newBall];
            
            // Update UI
            updateUI();
            
            // Draw the new state immediately
            draw();
            
            // Show instruction for launching
            setTimeout(() => {
                if (gameRunning) {
                    gameOverlay = {
                        active: true,
                        type: 'levelReady',
                        level: level,
                        title: `LEVEL ${level} READY!`,
                        message: 'PRESS SPACE TO LAUNCH',
                        instruction: 'CLICK OR PRESS SPACE TO CONTINUE'
                    };
                }
            }, 100);
        }

        async function gameOver() {
            // Prevent multiple calls
            console.log(`gameOver() called - gameRunning: ${gameRunning}, lives: ${lives}, score: ${score}`);
            if (!gameRunning) {
                console.log('gameOver() blocked - gameRunning is false');
                return;
            }
            
            gameRunning = false;
            legitGameCompleted = true; // Mark as legitimate game completion
            // Don't set gameStarted = false yet - wait until after hall of fame
            if (pauseBtn) pauseBtn.disabled = true;
            
            // Show the interactive hall of fame directly
            setTimeout(async () => {
                await showInteractiveHallOfFame();
                console.log('gameOver() - after showInteractiveHallOfFame, gameRunning:', gameRunning);
                console.log('gameOver() - overlay active:', gameOverlay.active, 'type:', gameOverlay.type);
            }, 100);
        }
        
        async function showInteractiveHallOfFame() {
            console.log('showInteractiveHallOfFame() called');
            
            // Prevent duplicate entries - only allow after legitimate game completion
            if (!legitGameCompleted) {
                console.log('showInteractiveHallOfFame() blocked - not a legitimate game completion');
                return;
            }
            
            try {
                const scores = await getHighScores(10);
                console.log('Got scores:', scores);
                console.log('First score object:', scores[0]);
                
                // Calculate where the current player's score would rank
                console.log('Calculating player rank, current score:', score);
                let playerRank = scores.length + 1; // Default to last position
                let insertAtIndex = scores.length;
                
                try {
                    for (let i = 0; i < scores.length; i++) {
                        console.log(`Comparing score ${score} with ${scores[i].score} (${parseInt(scores[i].score)})`);
                        if (score > parseInt(scores[i].score)) {
                            playerRank = i + 1;
                            insertAtIndex = i;
                            console.log(`Player ranks at position ${playerRank}`);
                            break;
                        }
                    }
                    console.log(`Final player rank: ${playerRank}, insertAtIndex: ${insertAtIndex}`);
                } catch (rankError) {
                    console.error('Error calculating player rank:', rankError);
                    // Use default values if there's an error
                }
                
                // Show name input if player makes top 10 OR if there are fewer than 10 scores
                const allowNameInput = playerRank <= 10 || scores.length < 10;
                console.log(`Player rank: ${playerRank}, scores.length: ${scores.length}, allowNameInput: ${allowNameInput}`);
                
                if (allowNameInput) {
                    console.log('Setting up hall of fame for qualifying score');
                    
                    // Force direct auth check for critical hall of fame decision
                    await updateCurrentUser(true);
                    
                    // Check if user is logged in
                    const defaultName = (typeof currentUser !== 'undefined' && currentUser && currentUser.username) ? currentUser.username : '';
                    console.log('=== HALL OF FAME DECISION DEBUG ===');
                    console.log('currentUser type:', typeof currentUser);
                    console.log('currentUser value:', currentUser);
                    console.log('currentUser.username:', currentUser ? currentUser.username : 'N/A');
                    console.log('defaultName result:', defaultName);
                    console.log('defaultName is truthy:', !!defaultName);
                    console.log('Window context:', window.parent === window ? 'Direct access' : 'Iframe');
                    console.log('===================================');
                    
                    if (defaultName) {
                        console.log('üéØ TAKING AUTO-SUBMIT PATH for user:', defaultName);
                        // User is logged in - automatically submit score and show non-interactive hall of fame
                        console.log('Auto-submitting score for logged-in user:', defaultName);
                        
                        let ipBlocked = false;
                        try {
                            await submitScore(defaultName, score, Math.max(1, level));
                            console.log('Score auto-submitted successfully');
                        } catch (error) {
                            console.error('Auto score submission error:', error);
                            
                            // Show special message for IP blocking
                            if (error.message === 'IP_BLOCKED') {
                                ipBlocked = true;
                                // Add a feedback message about IP blocking
                                gameState.feedbackMessages.push({
                                    text: '‚ö†Ô∏è IP BLOCKED - Score cannot be saved. Contact support.',
                                    color: '#FF6B6B',
                                    duration: 10000, // Show for 10 seconds
                                    startTime: Date.now()
                                });
                            }
                            // Continue to show hall of fame even if submission fails
                        }
                        
                        // Refresh scores to include the newly submitted score
                        const updatedScores = await getHighScores(10);
                        
                        // Show non-interactive hall of fame
                        gameOverlay = {
                            active: true,
                            type: 'hallOfFame',
                            title: ipBlocked ? '‚ö†Ô∏è IP BLOCKED - HALL OF FAME ‚ö†Ô∏è' : 'üèÜ HALL OF FAME üèÜ',
                            scores: updatedScores,
                            returnToGameOver: true,
                            gameOverData: {
                                playerName: defaultName,
                                finalScore: score,
                                levelReached: Math.max(1, level)
                            },
                            instruction: ipBlocked ? 'Press SPACE - Score NOT saved (IP Blocked)' : 'Press SPACE or ENTER to save your score'
                        };
                    } else {
                        // User not logged in - show interactive input
                        console.log('üî¥ TAKING INTERACTIVE PATH - User not detected as logged in');
                        console.log('Showing interactive name input for anonymous user');
                        
                        gameOverlay = {
                            active: true,
                            type: 'hallOfFameInput',
                            title: 'üèÜ HALL OF FAME üèÜ',
                            scores: scores,
                            playerScore: score,
                            playerLevel: Math.max(1, level),
                            playerRank: playerRank,
                            insertAtIndex: insertAtIndex,
                            inputName: '',
                            cursorVisible: true,
                            cursorBlinkTime: Date.now(),
                            instruction: 'Type your name and press ENTER to save your score'
                        };
                    }
                } else {
                    console.log('Player did not qualify for top 10, showing regular hall of fame');
                    // Score doesn't qualify for top 10, show hall of fame first, then game over
                    
                    // Force direct auth check for non-qualifying scores too
                    await updateCurrentUser(true);
                    
                    // Check if user is logged in even for non-qualifying scores
                    const playerName = (typeof currentUser !== 'undefined' && currentUser && currentUser.username) ? currentUser.username : 'Anonymous';
                    console.log('Non-qualifying - Detected user:', playerName);
                    console.log('Non-qualifying - currentUser object:', typeof currentUser !== 'undefined' ? currentUser : 'undefined');
                    
                    await submitScore(playerName, score, Math.max(1, level));
                    
                    // Show hall of fame with a message about not qualifying
                    gameOverlay = {
                        active: true,
                        type: 'hallOfFameNoQualify',
                        title: 'üèÜ HALL OF FAME üèÜ',
                        scores: scores,
                        playerScore: score,
                        playerLevel: Math.max(1, level),
                        playerName: playerName,
                        instruction: "Your score didn't make the top 10. Press SPACE or CLICK to continue"
                    };
                }
                
                console.log('showInteractiveHallOfFame() completed, gameOverlay:', gameOverlay);
            } catch (error) {
                console.error('Error displaying interactive hall of fame:', error);
                // Fallback to regular game over on error
                const fallbackPlayerName = (typeof currentUser !== 'undefined' && currentUser && currentUser.username) ? currentUser.username : 'Anonymous';
                await submitScore(fallbackPlayerName, score, Math.max(1, level));
                
                gameStarted = false; // Now it's safe to return to start screen
                gameOverlay = {
                    active: true,
                    type: 'gameOver',
                    title: 'üéÆ GAME OVER üéÆ',
                    message: `Final Score: ${score.toLocaleString()}\nLevel Reached: ${Math.max(1, level)}\nPlayer: ${fallbackPlayerName}`,
                    instruction: 'Press SPACE or CLICK to continue'
                };
            }
        }

        async function submitScore(playerName, score, levelReached) {
            try {
                console.log('submitScore called:', playerName, score, levelReached);
                console.log('Session data:', {
                    gameSessionId: gameSessionId,
                    gameSessionToken: gameSessionToken ? 'token present' : 'no token',
                    tokenLength: gameSessionToken ? gameSessionToken.length : 0
                });
                
                // Ensure we have a session ID for submission
                if (!gameSessionId) {
                    console.warn('No game session ID found, attempting to create session for score submission');
                    try {
                        // Try to create a session for score submission with retry
                        let emergencySession;
                        for (let attempt = 1; attempt <= 3; attempt++) {
                            console.log(`Emergency session creation attempt ${attempt}/3`);
                            emergencySession = await startGameSession(playerName);
                            if (emergencySession.success && gameSessionId) {
                                console.log('Emergency session created for score submission:', gameSessionId);
                                break;
                            }
                            if (attempt < 3) {
                                console.warn(`Attempt ${attempt} failed, retrying...`);
                                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                            }
                        }
                        
                        if (!emergencySession.success || !gameSessionId) {
                            if (emergencySession.error === 'IP_BLOCKED') {
                                console.error('IP is blocked - cannot submit scores');
                                // Show special message for IP blocking
                                throw new Error('IP_BLOCKED');
                            }
                            throw new Error('Failed to create emergency session after 3 attempts: ' + (emergencySession.error || 'Unknown error'));
                        }
                    } catch (sessionError) {
                        console.error('Failed to create session for score submission:', sessionError);
                        throw new Error('No valid game session available for score submission');
                    }
                }
                
                const submissionData = {
                    player_name: playerName,
                    score: score,
                    level_reached: levelReached,
                    session_id: gameSessionId,
                    token: gameSessionToken
                };
                console.log('Exact submission data:', submissionData);
                
                // Use direct API for now to avoid secure API issues
                const response = await fetch('breakout_scores.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(submissionData)
                });
                
                console.log('Score submission response:', response.status, response.statusText);
                
                if (!response.ok) {
                    // Try to get the error message from the response
                    let errorMessage = `Failed to submit score: ${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error) {
                            errorMessage += ` - ${errorData.error}`;
                        }
                    } catch (e) {
                        // Error response might not be JSON
                    }
                    throw new Error(errorMessage);
                }
                
                const result = await response.json();
                console.log('Score submission result:', result);
                return result;
            } catch (error) {
                console.error('Error submitting score:', error);
                throw error;
            }
        }

        async function getHighScores(limit = 10) {
            try {
                console.log('getHighScores called with limit:', limit);
                
                // Always use direct API for now to avoid secure API issues
                console.log('Using direct leaderboard API');
                const response = await fetch(`breakout_scores.php?limit=${limit}`);
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const scores = await response.json();
                console.log('Loaded scores:', scores);
                return scores;
            } catch (error) {
                console.error('Error fetching Hall of Fame scores:', error);
                console.error('Error details:', error.message);
                return [];
            }
        }

        async function showRegularHallOfFame(returnToGameOver = false, gameOverData = null) {
            try {
                console.log('showRegularHallOfFame called, gameStarted:', gameStarted, 'gameOverlay.active:', gameOverlay.active);
                console.log('Canvas:', canvas, 'Ctx:', ctx);
                const scores = await getHighScores(10);
                console.log('Scores loaded for Hall of Fame:', scores);
                
                // Regular hall of fame display (no name input functionality)
                gameOverlay = {
                    active: true,
                    type: 'hallOfFame',
                    title: 'üèÜ HALL OF FAME üèÜ',
                    scores: scores,
                    returnToGameOver: returnToGameOver,
                    gameOverData: gameOverData,
                    instruction: returnToGameOver ? 'Press SPACE or CLICK to return' : 'Press SPACE or CLICK to close'
                };
                
                console.log('Hall of Fame overlay set:', gameOverlay);
                console.log('gameOverlay.active after setting:', gameOverlay.active);
                
                // Add global keyboard handler for this overlay
                addOverlayKeyHandler();
                
                // Force a redraw to ensure overlay shows
                console.log('Forcing draw call after setting overlay');
                draw();
                
                setTimeout(() => {
                    console.log('Timeout check - gameOverlay.active:', gameOverlay.active);
                }, 100);
                
            } catch (error) {
                console.error('Error displaying hall of fame:', error);
                // Show error overlay instead of alert
                gameOverlay = {
                    active: true,
                    type: 'hallOfFame',
                    title: '‚ùå ERROR ‚ùå',
                    scores: [],
                    error: true,
                    instruction: 'Press SPACE or CLICK to close'
                };
            }
        }

        // closeHighScoreTable function removed - now using canvas overlay system

        function updateUI() {
            if (scoreElement) scoreElement.textContent = score;
            if (livesElement) livesElement.textContent = lives;
            if (levelElement) levelElement.textContent = level;
            
            // Update session personal best if current score is higher
            if (score > sessionPersonalBest) {
                sessionPersonalBest = score;
            }
            
            // Update personal best display with current session's highest score
            if (personalBestElement) {
                const personalBest = Math.max(sessionPersonalBest, getLocalHighScore());
                personalBestElement.textContent = personalBest.toLocaleString();
            }
        }

        function draw() {
            if (!canvas || !ctx) return;
            
            // Draw function running normally
            
            // Update body class for CSS animations
            if (!gameStarted) {
                document.body.classList.add('game-not-started');
            } else {
                document.body.classList.remove('game-not-started');
            }
            
            // Apply screen shake
            ctx.save();
            if (gameState.screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
                gameState.screenShake *= 0.8;
                if (gameState.screenShake < 0.1) gameState.screenShake = 0;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw blocks with enhanced 3D effect
            for (let block of blocks) {
                if (!block.destroyed) {
                    drawBlock(block);
                }
            }
            
            // Draw power-ups
            gameState.powerUps.forEach(powerUp => {
                if (powerUp.isLaser) {
                    // Draw laser beam
                    ctx.fillStyle = powerUp.color;
                    ctx.fillRect(powerUp.x - 3, powerUp.y, 5, 25);
                } else {
                    // Draw power-up
                    ctx.fillStyle = powerUp.color;
                    ctx.fillRect(powerUp.x - 19, powerUp.y - 10, 38, 20);
                    
                    // Draw power-up symbol
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '15px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(powerUp.symbol, powerUp.x, powerUp.y + 4);
                }
            });
            
            // Draw paddle with enhanced 3D effect and power-up indicators
            drawPaddle();
            
            // Draw all balls with trails
            gameState.balls.forEach(ball => {
                drawBall(ball);
            });
            
            // Draw particles
            drawParticles();
            
            // Draw score popups
            drawScorePopups();
            
            // Draw UI overlays
            drawGameUI();
            
            // Draw feedback messages (on top of everything)
            drawFeedbackMessages();
            
            ctx.restore();
        }

        function drawBlock(block) {
            const x = block.x;
            const y = block.y;
            const w = block.width;
            const h = block.height;
            
            // Adjust color based on hits remaining
            let color = block.color;
            let damageMultiplier = 1;
            if (block.hits < block.maxHits) {
                damageMultiplier = 0.6 + (block.hits / block.maxHits) * 0.4;
            }
            
            // Parse the hex color to create lighter and darker variants
            const hex = block.color.replace('#', '');
            const r = Math.floor(parseInt(hex.substr(0, 2), 16) * damageMultiplier);
            const g = Math.floor(parseInt(hex.substr(2, 2), 16) * damageMultiplier);
            const b = Math.floor(parseInt(hex.substr(4, 2), 16) * damageMultiplier);
            
            // Create vibrant gradient effect
            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
            gradient.addColorStop(0, `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`);
            gradient.addColorStop(0.3, `rgb(${r}, ${g}, ${b})`);
            gradient.addColorStop(0.7, `rgb(${r}, ${g}, ${b})`);
            gradient.addColorStop(1, `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`);
            
            // Fill main block with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, w, h);
            
            // Add animated shimmer effect (half speed with contrasting colors)
            const shimmerOffset = (Date.now() * 0.0025 + block.x * 0.01 + block.y * 0.01) % 1;
            const shimmerGradient = ctx.createLinearGradient(x - 20, y - 20, x + w + 20, y + h + 20);
            
            // Create contrasting shimmer color based on block color
            const shimmerR = r > 128 ? Math.max(0, r - 100) : Math.min(255, r + 100);
            const shimmerG = g > 128 ? Math.max(0, g - 100) : Math.min(255, g + 100);
            const shimmerB = b > 128 ? Math.max(0, b - 100) : Math.min(255, b + 100);
            const contrastColor = `rgba(${shimmerR}, ${shimmerG}, ${shimmerB}, 0.3)`;
            
            shimmerGradient.addColorStop(Math.max(0, shimmerOffset - 0.1), 'rgba(255, 255, 255, 0)');
            shimmerGradient.addColorStop(Math.max(0, Math.min(1, shimmerOffset - 0.05)), contrastColor);
            shimmerGradient.addColorStop(Math.max(0, Math.min(1, shimmerOffset)), 'rgba(255, 255, 255, 0.4)');
            shimmerGradient.addColorStop(Math.max(0, Math.min(1, shimmerOffset + 0.05)), contrastColor);
            shimmerGradient.addColorStop(Math.min(1, shimmerOffset + 0.1), 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = shimmerGradient;
            ctx.fillRect(x, y, w, h);
            
            // Add bright highlight on top and left edges
            const lightR = Math.min(255, r + 80);
            const lightG = Math.min(255, g + 80);
            const lightB = Math.min(255, b + 80);
            const lightColor = `rgb(${lightR}, ${lightG}, ${lightB})`;
            
            ctx.fillStyle = lightColor;
            ctx.fillRect(x, y, w, 4); // Top highlight
            ctx.fillRect(x, y, 4, h); // Left highlight
            
            // Add deep shadow on bottom and right edges
            const darkR = Math.max(0, r - 60);
            const darkG = Math.max(0, g - 60);
            const darkB = Math.max(0, b - 60);
            const darkColor = `rgb(${darkR}, ${darkG}, ${darkB})`;
            
            ctx.fillStyle = darkColor;
            ctx.fillRect(x, y + h - 4, w, 4); // Bottom shadow
            ctx.fillRect(x + w - 4, y, 4, h); // Right shadow
            
            // Add glowing border
            ctx.strokeStyle = `rgba(${Math.min(255, r + 100)}, ${Math.min(255, g + 100)}, ${Math.min(255, b + 100)}, 0.6)`;
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
            
            // Add damage/crack effects for multi-hit blocks
            if (block.maxHits > 1) {
                const damagePercent = 1 - (block.hits / block.maxHits);
                
                if (damagePercent > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    
                    // Create crack patterns based on damage
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    
                    // Light damage (25-50% damaged)
                    if (damagePercent >= 0.25) {
                        // Diagonal crack from top-left
                        ctx.beginPath();
                        ctx.moveTo(x + 2, y + 2);
                        ctx.lineTo(x + w/3, y + h/3);
                        ctx.stroke();
                        
                        // Small horizontal crack
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + 2);
                        ctx.lineTo(x + w - 4, y + 6);
                        ctx.stroke();
                    }
                    
                    // Medium damage (50-75% damaged)
                    if (damagePercent >= 0.5) {
                        ctx.lineWidth = 2;
                        
                        // Vertical crack down the middle
                        ctx.beginPath();
                        ctx.moveTo(x + w/2 + 2, y + 3);
                        ctx.lineTo(x + w/2 - 1, y + h - 3);
                        ctx.stroke();
                        
                        // Additional diagonal crack
                        ctx.beginPath();
                        ctx.moveTo(x + w - 3, y + 3);
                        ctx.lineTo(x + w/2, y + h/2);
                        ctx.stroke();
                        
                        // Add some missing chunks effect
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fillRect(x + 2, y + h - 6, 4, 4);
                        ctx.fillRect(x + w - 6, y + 2, 4, 3);
                    }
                    
                    // Heavy damage (75%+ damaged - 1-2 hits left)
                    if (damagePercent >= 0.75) {
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = '#333333';
                        
                        // Major crack network
                        ctx.beginPath();
                        ctx.moveTo(x + 1, y + h/3);
                        ctx.lineTo(x + w/3, y + h/2);
                        ctx.lineTo(x + 2*w/3, y + h/4);
                        ctx.lineTo(x + w - 1, y + 2*h/3);
                        ctx.stroke();
                        
                        // Cross crack pattern
                        ctx.beginPath();
                        ctx.moveTo(x + w/4, y + 1);
                        ctx.lineTo(x + 3*w/4, y + h - 1);
                        ctx.moveTo(x + 3*w/4, y + 1);
                        ctx.lineTo(x + w/4, y + h - 1);
                        ctx.stroke();
                        
                        // Large missing chunks
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(x + 1, y + 1, 5, 5);
                        ctx.fillRect(x + w - 6, y + h - 6, 5, 5);
                        ctx.fillRect(x + w/2 - 2, y + h - 4, 4, 3);
                        
                        // Add some dust/debris effect
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';
                        for (let i = 0; i < 6; i++) {
                            const dustX = x + Math.random() * w;
                            const dustY = y + Math.random() * h;
                            ctx.fillRect(dustX, dustY, 1, 1);
                        }
                    }
                    
                    // Extreme damage for 5-hit blocks (90%+ damaged - critical state)
                    if (damagePercent >= 0.9 && block.maxHits === 5) {
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = '#FF0000';
                        
                        // Critical crack network covering entire block
                        ctx.beginPath();
                        ctx.moveTo(x + 1, y + 1);
                        ctx.lineTo(x + w - 1, y + h - 1);
                        ctx.moveTo(x + w - 1, y + 1);
                        ctx.lineTo(x + 1, y + h - 1);
                        ctx.moveTo(x + w/2, y + 1);
                        ctx.lineTo(x + w/2, y + h - 1);
                        ctx.moveTo(x + 1, y + h/2);
                        ctx.lineTo(x + w - 1, y + h/2);
                        ctx.stroke();
                        
                        // Massive missing chunks
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(x + 1, y + 1, 6, 6);
                        ctx.fillRect(x + w - 7, y + 1, 6, 6);
                        ctx.fillRect(x + 1, y + h - 7, 6, 6);
                        ctx.fillRect(x + w - 7, y + h - 7, 6, 6);
                        ctx.fillRect(x + w/2 - 3, y + h/2 - 3, 6, 6);
                        
                        // Sparks/energy effect for 5-hit blocks
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        for (let i = 0; i < 8; i++) {
                            const sparkX = x + Math.random() * w;
                            const sparkY = y + Math.random() * h;
                            ctx.fillRect(sparkX, sparkY, 2, 2);
                        }
                    }
                    
                    ctx.restore();
                }
            }
            
            // Special rendering for metal bricks
            if (block.type === 'metal') {
                // Enhanced metallic gradient effect
                const metalGradient = ctx.createLinearGradient(x, y, x + w, y + h);
                metalGradient.addColorStop(0, 'rgba(220, 220, 255, 0.9)');
                metalGradient.addColorStop(0.2, 'rgba(180, 180, 200, 0.8)');
                metalGradient.addColorStop(0.5, 'rgba(140, 140, 160, 0.9)');
                metalGradient.addColorStop(0.8, 'rgba(100, 100, 120, 0.8)');
                metalGradient.addColorStop(1, 'rgba(60, 60, 80, 0.9)');
                
                ctx.fillStyle = metalGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add animated metallic shimmer
                const metalShimmer = (Date.now() * 0.003 + block.x * 0.02) % 1;
                const shimmerGradient = ctx.createLinearGradient(x - 15, y - 15, x + w + 15, y + h + 15);
                shimmerGradient.addColorStop(Math.max(0, metalShimmer - 0.05), 'rgba(255, 255, 255, 0)');
                shimmerGradient.addColorStop(metalShimmer, 'rgba(255, 255, 255, 0.7)');
                shimmerGradient.addColorStop(Math.min(1, metalShimmer + 0.05), 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = shimmerGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add diagonal metal pattern
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const lineY = y + (h / 5) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(x + 3, lineY);
                    ctx.lineTo(x + w - 3, lineY);
                    ctx.stroke();
                }
                
                // Add glowing border for metal
                ctx.strokeStyle = 'rgba(150, 150, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // Add metal icon/symbol with glow
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.font = 'bold 13px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö°', x + w/2, y + h/2 + 5);
                ctx.shadowBlur = 0;
            }
            
            // Special rendering for lava blocks with diagonal orange/red stripes
            if (block.type === 'lava') {
                ctx.save();
                
                // Create diagonal stripe pattern
                const stripeWidth = 8;
                const stripeAngle = -45 * Math.PI / 180; // -45 degree angle
                
                // Create pattern with alternating orange and red stripes
                for (let i = -w; i < w + h; i += stripeWidth) {
                    const stripe = i;
                    
                    // Calculate stripe coordinates
                    const x1 = x + stripe;
                    const y1 = y;
                    const x2 = x + stripe + h;
                    const y2 = y + h;
                    
                    // Alternate between orange and red
                    const isOrange = Math.floor(stripe / stripeWidth) % 2 === 0;
                    ctx.fillStyle = isOrange ? '#FF6500' : '#CC2200'; // Bright orange and deep red
                    
                    // Draw diagonal stripe
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1 + stripeWidth, y1);
                    ctx.lineTo(x2 + stripeWidth, y2);
                    ctx.lineTo(x2, y2);
                    ctx.closePath();
                    
                    // Clip to block boundaries
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(x, y, w, h);
                    ctx.clip();
                    ctx.fill();
                    ctx.restore();
                }
                
                // Add animated lava glow effect
                const lavaGlow = Math.sin(Date.now() * 0.004 + block.x * 0.01) * 0.3 + 0.7;
                ctx.shadowColor = '#FF4500';
                ctx.shadowBlur = 6 * lavaGlow;
                ctx.strokeStyle = `rgba(255, 69, 0, ${lavaGlow})`;
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, w, h);
                
                // Add lava symbol with pulsing effect
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 8 * lavaGlow;
                ctx.fillStyle = `rgba(255, 215, 0, ${lavaGlow})`;
                ctx.font = 'bold 15px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('üî•', x + w/2, y + h/2 + 6);
                
                ctx.restore();
            }
            
            // Special rendering for 5-hit ultra-hard blocks (Diamond/Crystal effect)
            if (block.maxHits === 5) {
                ctx.save();
                
                // Enhanced diamond/crystal gradient effect
                const diamondGradient = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, Math.max(w, h));
                diamondGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                diamondGradient.addColorStop(0.3, 'rgba(230, 230, 250, 0.8)');
                diamondGradient.addColorStop(0.6, 'rgba(200, 200, 240, 0.7)');
                diamondGradient.addColorStop(1, 'rgba(150, 150, 200, 0.6)');
                
                ctx.fillStyle = diamondGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add animated crystal shimmer (faster than metal)
                const crystalShimmer = (Date.now() * 0.005 + block.x * 0.03) % 1;
                const crystalShimmerGradient = ctx.createLinearGradient(x - 20, y - 20, x + w + 20, y + h + 20);
                crystalShimmerGradient.addColorStop(Math.max(0, crystalShimmer - 0.08), 'rgba(255, 255, 255, 0)');
                crystalShimmerGradient.addColorStop(Math.max(0, crystalShimmer - 0.04), 'rgba(255, 255, 255, 0.4)');
                crystalShimmerGradient.addColorStop(crystalShimmer, 'rgba(255, 255, 255, 0.9)');
                crystalShimmerGradient.addColorStop(Math.min(1, crystalShimmer + 0.04), 'rgba(255, 255, 255, 0.4)');
                crystalShimmerGradient.addColorStop(Math.min(1, crystalShimmer + 0.08), 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = crystalShimmerGradient;
                ctx.fillRect(x + 1, y + 1, w - 2, h - 2);
                
                // Add faceted crystal pattern
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Diamond facet lines
                ctx.moveTo(x + w/2, y + 2);
                ctx.lineTo(x + 2, y + h/2);
                ctx.lineTo(x + w/2, y + h - 2);
                ctx.lineTo(x + w - 2, y + h/2);
                ctx.closePath();
                ctx.stroke();
                
                // Inner facets
                ctx.beginPath();
                ctx.moveTo(x + w/4, y + h/4);
                ctx.lineTo(x + 3*w/4, y + h/4);
                ctx.lineTo(x + 3*w/4, y + 3*h/4);
                ctx.lineTo(x + w/4, y + 3*h/4);
                ctx.closePath();
                ctx.stroke();
                
                // Add prismatic rainbow border effect
                const rainbowTime = Date.now() * 0.003;
                const rainbowR = Math.floor(128 + 127 * Math.sin(rainbowTime));
                const rainbowG = Math.floor(128 + 127 * Math.sin(rainbowTime + 2));
                const rainbowB = Math.floor(128 + 127 * Math.sin(rainbowTime + 4));
                
                ctx.strokeStyle = `rgba(${rainbowR}, ${rainbowG}, ${rainbowB}, 0.8)`;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // Add crystal/diamond icon with powerful glow
                ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                ctx.shadowBlur = 12;
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.font = 'bold 10px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('‚ô¶', x + w/2, y + h/2 + 3);
                
                // Add secondary glow
                ctx.shadowColor = `rgba(${rainbowR}, ${rainbowG}, ${rainbowB}, 0.8)`;
                ctx.shadowBlur = 8;
                ctx.fillText('‚ô¶', x + w/2, y + h/2 + 3);
                
                ctx.restore();
            }
            
            // Optional: Show hits remaining for multi-hit blocks (now that we have visual damage)
            // Uncomment if you still want numbers in addition to visual damage
            /*
            if (block.maxHits > 1 && block.type !== 'metal') {
                ctx.save();
                ctx.shadowColor = '#FFFFFF';
                ctx.shadowBlur = 6;
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 11px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(block.hits.toString(), x + w/2, y + h/2 + 4);
                
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText(block.hits.toString(), x + w/2, y + h/2 + 4);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(block.hits.toString(), x + w/2, y + h/2 + 4);
                ctx.restore();
            }
            */
        }

        function drawPaddle() {
            let paddleColor = '#4ECDC4'; // Teal color like original
            
            // Change color based on power-ups
            if (paddle.laser) {
                paddleColor = '#FFD700'; // Gold for laser
            } else if (paddle.sticky) {
                paddleColor = '#90EE90'; // Light green for sticky
            }
            
            const x = paddle.x;
            const y = paddle.y;
            const w = paddle.width;
            const h = paddle.height;
            
            // Parse the paddle color for 3D effect
            const hex = paddleColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Create lighter and darker variants
            const lightR = Math.min(255, r + 60);
            const lightG = Math.min(255, g + 60);
            const lightB = Math.min(255, b + 60);
            const darkR = Math.max(0, r - 40);
            const darkG = Math.max(0, g - 40);
            const darkB = Math.max(0, b - 40);
            
            const lightColor = `rgb(${lightR}, ${lightG}, ${lightB})`;
            const darkColor = `rgb(${darkR}, ${darkG}, ${darkB})`;
            
            // Fill main paddle
            ctx.fillStyle = paddleColor;
            ctx.fillRect(x, y, w, h);
            
            // Add highlight on top and left edges
            ctx.fillStyle = lightColor;
            ctx.fillRect(x, y, w, 2); // Top highlight
            ctx.fillRect(x, y, 2, h); // Left highlight
            
            // Add shadow on bottom and right edges
            ctx.fillStyle = darkColor;
            ctx.fillRect(x, y + h - 2, w, 2); // Bottom shadow
            ctx.fillRect(x + w - 2, y, 2, h); // Right shadow
            
            // Draw power-up indicators
            if (paddle.laser) {
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x + w * 0.25 - 2, y - 5, 4, 5);
                ctx.fillRect(x + w * 0.75 - 2, y - 5, 4, 5);
            }
        }

        function drawBall(ball) {
            // Draw ball trail
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < ball.trail.length; i++) {
                const trailPoint = ball.trail[i];
                const alpha = (i / ball.trail.length) * 0.3;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(trailPoint.x, trailPoint.y, ball.radius * (0.5 + i / ball.trail.length * 0.5), 0, Math.PI * 2);
                let trailColor = '#888888';
                if (ball.mega && ball.rocket) {
                    trailColor = '#FF4500';
                } else if (ball.mega) {
                    trailColor = '#FF6B6B';
                } else if (ball.rocket) {
                    trailColor = '#FFD700';
                } else if (ball.slow) {
                    trailColor = '#00CED1';
                }
                ctx.fillStyle = trailColor;
                ctx.fill();
                ctx.closePath();
            }
            ctx.globalAlpha = 1.0;
            
            // Draw main ball
            let ballColor = '#888888';
            let ballRadius = ball.radius;
            let highlightColor = '#BBBBBB';
            
            if (ball.mega && ball.rocket) {
                // Combined rocket + explosive: orange-red gradient effect
                ballColor = '#FF4500';
                ballRadius = ball.radius * 1.2;
                highlightColor = '#FF7F50';
            } else if (ball.mega) {
                ballColor = '#FF6B6B';
                ballRadius = ball.radius * 1.2;
                highlightColor = '#FF9999';
            } else if (ball.rocket) {
                ballColor = '#FFD700';
                ballRadius = ball.radius;
                highlightColor = '#FFFF99';
            } else if (ball.slow) {
                ballColor = '#00CED1';  // Dark turquoise for slow ball
                ballRadius = ball.radius * 0.9; // Slightly smaller
                highlightColor = '#87CEEB';
            }
            
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = ballColor;
            ctx.fill();
            ctx.closePath();
            
            // Add subtle highlight for 3D effect
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, ballRadius - 3, 0, Math.PI * 2);
            ctx.fillStyle = highlightColor;
            ctx.fill();
            ctx.closePath();
            
            // Add rocket trail effect
            if (ball.rocket) {
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#FF4500';
                
                // Draw rocket exhaust
                const angle = Math.atan2(ball.dy, ball.dx);
                const exhaustLength = 15;
                const exhaustWidth = 6;
                
                ctx.translate(ball.x, ball.y);
                ctx.rotate(angle + Math.PI);
                
                ctx.beginPath();
                ctx.ellipse(exhaustLength/2, 0, exhaustLength/2, exhaustWidth/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        function drawGameUI() {
            // Draw level name and progress above blocks
            if (gameStarted && gameRunning) {
                ctx.save();
                ctx.fillStyle = '#00FFFF';
                ctx.font = 'bold 15px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 8;
                
                const levelName = levelNames[level - 1] || `Level ${level}`;
                const progressText = `Level ${level}/100: ${levelName}`;
                ctx.fillText(progressText, canvas.width / 2, 20);
                
                ctx.restore();
            }
            
            // Draw enhanced combo indicator with scoring preview
            if (gameState.combo > 1) {
                ctx.save();
                
                // Enhanced combo display with scaling and color effects
                const comboMultiplier = Math.min(gameState.combo, 500);
                // Scale only increases every 10 combo points, last increase at combo 70
                const scaleSteps = Math.min(Math.floor(gameState.combo / 10), 7); // Max 7 steps (0-7)
                const scale = 1 + (scaleSteps * 0.1); // Each step adds 0.1 to scale
                
                // Color progression: gold -> orange -> red -> purple -> white for extreme combos
                let comboColor = '#FFD700'; // Gold
                if (comboMultiplier >= 5) comboColor = '#FF8C00'; // Orange
                if (comboMultiplier >= 25) comboColor = '#FF4500'; // Red-orange
                if (comboMultiplier >= 100) comboColor = '#8B00FF'; // Purple
                if (comboMultiplier >= 250) comboColor = '#FFFFFF'; // White for extreme combos
                
                ctx.fillStyle = comboColor;
                ctx.font = `bold ${13 * scale}px "Press Start 2P", monospace`;
                ctx.textAlign = 'center';
                
                // Add glow effect for high combos
                if (comboMultiplier >= 5) {
                    ctx.shadowColor = comboColor;
                    ctx.shadowBlur = Math.min(8 + (comboMultiplier / 10), 30); // Progressive glow intensity
                }
                
                // Show combo multiplier and point preview
                const nextPoints = 10 * gameState.multiplier * comboMultiplier;
                ctx.fillText(`${gameState.combo}x COMBO! (+${nextPoints} pts)`, canvas.width / 2, 44);
                
                // Bright core for very high combos
                if (comboMultiplier >= 50) {
                    ctx.shadowBlur = Math.min(15 + (comboMultiplier / 5), 50);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `bold ${Math.min(19 * scale, 21)}px "Press Start 2P", monospace`; // Cap at 21px (13 + 8)
                    ctx.fillText(`${gameState.combo}x COMBO!`, canvas.width / 2, 44);
                }
                
                ctx.restore();
            }
            
            // Draw power-up timer with retro styling
            if (paddle.powerUpTimer > 0) {
                const timerWidth = 120;
                const timerHeight = 12;
                const timerX = canvas.width - timerWidth - 25;
                const timerY = 20;
                
                const maxTimer = paddle.sticky ? 900 : 600;
                const progress = paddle.powerUpTimer / maxTimer;
                
                // Timer background with neon border
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(timerX, timerY, timerWidth, timerHeight);
                
                // Neon border
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(timerX, timerY, timerWidth, timerHeight);
                
                // Timer progress with glow
                ctx.save();
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(timerX + 2, timerY + 2, (timerWidth - 4) * progress, timerHeight - 4);
                ctx.restore();
                
                // Timer label
                ctx.save();
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 5;
                ctx.fillStyle = '#00FFFF';
                ctx.font = 'bold 11px "Press Start 2P", monospace';
                ctx.textAlign = 'right';
                ctx.fillText('POWER-UP', timerX + timerWidth, timerY - 8);
                ctx.restore();
            }
            
            // Draw overlays (start screen, game over, level complete, etc.)
            if (!gameStarted || gameOverlay.active) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Drawing overlay or start screen
                
                if (!gameStarted && !gameOverlay.active) {
                    // Original start screen
                    // Drawing start screen
                    ctx.save();
                    ctx.shadowColor = '#FF00FF';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#FF00FF';
                    ctx.font = 'bold 25px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('BREAKOUT', canvas.width / 2, canvas.height / 2 - 188);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.shadowColor = '#00FFFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#00FFFF';
                    
                    // Center-align all instructions
                    ctx.font = 'bold 23px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('Press SPACE or CLICK to start', canvas.width / 2, canvas.height / 2 - 90);
                    ctx.fillText('Press H or click button for Hall of Fame', canvas.width / 2, canvas.height / 2 - 65);
                    ctx.fillText('Arrow Keys, WASD, Mouse, Touch to move', canvas.width / 2, canvas.height / 2 - 40);
                    ctx.fillText('Press P or ESC to pause during game', canvas.width / 2, canvas.height / 2 - 15);
                    ctx.fillText('Press S to toggle sound', canvas.width / 2, canvas.height / 2 + 10);
                    ctx.fillText('SPACE to fire laser when powered up', canvas.width / 2, canvas.height / 2 + 35);
                    ctx.restore();
                } else if (gameOverlay.active) {
                    // Handle different overlay types
                    ctx.save();
                    ctx.textAlign = 'center';
                    
                    if (gameOverlay.type === 'levelComplete') {
                        // Level completion overlay
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#00FF00';
                        ctx.font = 'bold 13px "Press Start 2P", monospace';
                        ctx.fillText(`üéâ Level ${gameOverlay.completedLevel} Complete! üéâ`, canvas.width / 2, canvas.height / 2 - 60);
                        
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 14px "Press Start 2P", monospace';
                        ctx.fillText(`Score: ${gameOverlay.score}`, canvas.width / 2, canvas.height / 2 - 20);
                        ctx.fillText(`Starting Level ${gameOverlay.nextLevel}`, canvas.width / 2, canvas.height / 2);
                        ctx.fillText('Press SPACE or CLICK to continue', canvas.width / 2, canvas.height / 2 + 40);
                        
                    } else if (gameOverlay.type === 'gameOver') {
                        // Game over overlay
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FF0000';
                        ctx.font = 'bold 15px "Press Start 2P", monospace';
                        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 80);
                        
                        if (gameOverlay.highScoreText) {
                            ctx.shadowColor = '#FFD700';
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 15px "Press Start 2P", monospace';
                            ctx.fillText(gameOverlay.highScoreText, canvas.width / 2, canvas.height / 2 - 50);
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 25px "Press Start 2P", monospace';
                        ctx.fillText(`Player: ${gameOverlay.playerName}`, canvas.width / 2, canvas.height / 2 - 50);
                        ctx.fillText(`Final Score: ${gameOverlay.finalScore}`, canvas.width / 2, canvas.height / 2 - 10);
                        
                        const levelReached = Math.max(1, gameOverlay.levelReached);
                        const levelName = levelNames[levelReached - 1] || `Level ${levelReached}`;
                        ctx.fillText(`Level Reached: ${levelReached}/100`, canvas.width / 2, canvas.height / 2 + 30);
                        
                        // Show level name in smaller font
                        ctx.font = 'bold 18px "Press Start 2P", monospace';
                        ctx.fillText(`"${levelName}"`, canvas.width / 2, canvas.height / 2 + 60);
                        ctx.fillText('Click RESET button below to restart', canvas.width / 2, canvas.height / 2 + 90);
                        
                    } else if (gameOverlay.type === 'levelReady') {
                        // Level ready overlay
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#00FF00';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 40);
                        
                        ctx.shadowColor = '#FFFFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 25px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.message, canvas.width / 2, canvas.height / 2);
                        ctx.fillText(gameOverlay.instruction, canvas.width / 2, canvas.height / 2 + 40);
                        
                    } else if (gameOverlay.type === 'paused') {
                        // Pause overlay
                        ctx.shadowColor = '#FFFF00';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFFF00';
                        ctx.font = 'bold 18px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 40);
                        
                        ctx.shadowColor = '#FFFFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.message, canvas.width / 2, canvas.height / 2);
                        ctx.fillText(gameOverlay.instruction, canvas.width / 2, canvas.height / 2 + 40);
                        
                    } else if (gameOverlay.type === 'hallOfFame') {
                        // Hall of Fame overlay
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 30px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 180);
                        
                        if (gameOverlay.error) {
                            ctx.shadowColor = '#FF0000';
                            ctx.fillStyle = '#FF0000';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('Failed to load scores', canvas.width / 2, canvas.height / 2 - 20);
                        } else if (gameOverlay.scores.length === 0) {
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('No scores yet!', canvas.width / 2, canvas.height / 2 - 20);
                            ctx.fillText('Be the first to play!', canvas.width / 2, canvas.height / 2);
                        } else {
                            // Display top scores
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            
                            gameOverlay.scores.slice(0, 10).forEach((score, index) => {
                                const rank = index + 1;
                                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                                const isCurrentPlayer = score.player_name === playerName;
                                
                                if (isCurrentPlayer) {
                                    ctx.shadowColor = '#00FFFF';
                                    ctx.fillStyle = '#00FFFF';
                                } else {
                                    ctx.shadowColor = '#FFFFFF';
                                    ctx.fillStyle = '#FFFFFF';
                                }
                                
                                const yPos = canvas.height / 2 - 100 + (index * 32);
                                const levelReached = score.level_reached || 1;
                                const levelName = levelNames[levelReached - 1] || `Level ${levelReached}`;
                                
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            });
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(gameOverlay.instruction, canvas.width / 2, canvas.height / 2 + 250);
                        
                    } else if (gameOverlay.type === 'hallOfFameInput') {
                        // Interactive Hall of Fame with name input overlay
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 30px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 180);
                        
                        if (gameOverlay.scores.length === 0) {
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('No scores yet!', canvas.width / 2, canvas.height / 2 - 20);
                            ctx.fillText('Be the first to play!', canvas.width / 2, canvas.height / 2);
                        } else {
                            // Display column headers
                            ctx.shadowColor = '#FFD700';
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 18px "Press Start 2P", monospace';
                            const headerY = canvas.height / 2 - 163;
                            ctx.textAlign = 'left';
                            ctx.fillText('PLAYER', 20, headerY);
                            ctx.textAlign = 'center';
                            ctx.fillText('LVL', canvas.width * 0.35, headerY);
                            ctx.fillText('LEVEL NAME', canvas.width * 0.55, headerY);
                            ctx.textAlign = 'right';
                            ctx.fillText('SCORE', canvas.width - 25, headerY);
                            ctx.textAlign = 'center';
                            
                            // Display top scores with player's position highlighted
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            
                            let displayIndex = 0;
                            
                            // Show existing scores up to player's position
                            for (let i = 0; i < gameOverlay.insertAtIndex && displayIndex < 10; i++, displayIndex++) {
                                const score = gameOverlay.scores[i];
                                const rank = displayIndex + 1;
                                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                                const levelReached = score.level_reached || 1;
                                const levelName = levelNames[levelReached - 1] || `Level ${levelReached}`;
                                
                                ctx.shadowColor = '#FFFFFF';
                                ctx.fillStyle = '#FFFFFF';
                                
                                const yPos = canvas.height / 2 - 100 + (displayIndex * 32);
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            }
                            
                            // Show player's input line if they made top 10
                            if (gameOverlay.playerRank <= 10 && displayIndex < 10) {
                                const rank = gameOverlay.playerRank;
                                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                                
                                ctx.shadowColor = '#00FFFF';
                                ctx.fillStyle = '#00FFFF';
                                
                                const yPos = canvas.height / 2 - 100 + (displayIndex * 32);
                                ctx.textAlign = 'left';
                                
                                // Show blinking cursor
                                const cursorChar = (gameOverlay.cursorVisible && Date.now() - gameOverlay.cursorBlinkTime > 500) ? '_' : '';
                                if (Date.now() - gameOverlay.cursorBlinkTime > 1000) {
                                    gameOverlay.cursorBlinkTime = Date.now();
                                    gameOverlay.cursorVisible = !gameOverlay.cursorVisible;
                                }
                                
                                ctx.fillText(`${rankEmoji} ${gameOverlay.inputName}${cursorChar}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${gameOverlay.playerLevel}`, canvas.width * 0.35, yPos);
                                ctx.textAlign = 'right';
                                ctx.fillText(`${gameOverlay.playerScore.toLocaleString()}`, canvas.width - 20, yPos);
                                ctx.textAlign = 'center';
                                
                                displayIndex++;
                            }
                            
                            // Show remaining scores after player's position
                            for (let i = gameOverlay.insertAtIndex; i < gameOverlay.scores.length && displayIndex < 10; i++, displayIndex++) {
                                const score = gameOverlay.scores[i];
                                const rank = displayIndex + 1;
                                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                                const levelReached = score.level_reached || 1;
                                const levelName = levelNames[levelReached - 1] || `Level ${levelReached}`;
                                
                                ctx.shadowColor = '#FFFFFF';
                                ctx.fillStyle = '#FFFFFF';
                                
                                const yPos = canvas.height / 2 - 100 + (displayIndex * 32);
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            }
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(gameOverlay.instruction, canvas.width / 2, canvas.height / 2 + 275);
                        
                    } else if (gameOverlay.type === 'hallOfFameNoQualify') {
                        // Hall of Fame for players who didn't qualify overlay
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 30px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.title, canvas.width / 2, canvas.height / 2 - 180);
                        
                        if (gameOverlay.scores.length === 0) {
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 23px "Press Start 2P", monospace';
                            ctx.fillText('No scores yet!', canvas.width / 2, canvas.height / 2 - 20);
                            ctx.fillText('Be the first to play!', canvas.width / 2, canvas.height / 2);
                        } else {
                            // Display column headers
                            ctx.shadowColor = '#FFD700';
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 18px "Press Start 2P", monospace';
                            const headerY = canvas.height / 2 - 163;
                            ctx.textAlign = 'left';
                            ctx.fillText('PLAYER', 20, headerY);
                            ctx.textAlign = 'center';
                            ctx.fillText('LVL', canvas.width * 0.35, headerY);
                            ctx.fillText('LEVEL NAME', canvas.width * 0.55, headerY);
                            ctx.textAlign = 'right';
                            ctx.fillText('SCORE', canvas.width - 25, headerY);
                            ctx.textAlign = 'center';
                            
                            // Display top scores
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            
                            gameOverlay.scores.slice(0, 10).forEach((score, index) => {
                                const rank = index + 1;
                                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                                const levelReached = score.level_reached || 1;
                                const levelName = levelNames[levelReached - 1] || `Level ${levelReached}`;
                                
                                const yPos = canvas.height / 2 - 100 + (index * 32);
                                ctx.textAlign = 'left';
                                ctx.fillText(`${rankEmoji} ${score.player_name}`, 20, yPos);
                                ctx.textAlign = 'center';
                                ctx.fillText(`L${levelReached}`, canvas.width * 0.35, yPos);
                                
                                // Show level name in smaller font
                                const originalFont = ctx.font;
                                ctx.font = 'bold 13px "Press Start 2P", monospace';
                                ctx.fillText(`"${levelName}"`, canvas.width * 0.55, yPos);
                                ctx.font = originalFont;
                                
                                ctx.textAlign = 'right';
                                ctx.fillText(`${parseInt(score.score).toLocaleString()}`, canvas.width - 25, yPos);
                                ctx.textAlign = 'center';
                            });
                            
                            // Show player's score below the hall of fame
                            ctx.shadowColor = '#FF6B6B';
                            ctx.fillStyle = '#FF6B6B';
                            ctx.font = 'bold 20px "Press Start 2P", monospace';
                            const playerDisplayName = gameOverlay.playerName || 'Anonymous';
                            const playerLevelName = levelNames[gameOverlay.playerLevel - 1] || `Level ${gameOverlay.playerLevel}`;
                            ctx.fillText(`${playerDisplayName}: ${gameOverlay.playerScore.toLocaleString()}`, canvas.width / 2, canvas.height / 2 + 30);
                            ctx.font = 'bold 15px "Press Start 2P", monospace';
                            ctx.fillText(`Level ${gameOverlay.playerLevel}/100: "${playerLevelName}"`, canvas.width / 2, canvas.height / 2 + 60);
                        }
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(gameOverlay.instruction, canvas.width / 2, canvas.height / 2 + 250);
                        
                    } else if (gameOverlay.type === 'nameError') {
                        // Name error overlay
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#FF0000';
                        ctx.font = 'bold 23px "Press Start 2P", monospace';
                        ctx.fillText('‚ùå NAME ERROR ‚ùå', canvas.width / 2, canvas.height / 2 - 40);
                        
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FFFF';
                        ctx.font = 'bold 25px "Press Start 2P", monospace';
                        ctx.fillText(gameOverlay.message, canvas.width / 2, canvas.height / 2);
                        ctx.fillText('Press SPACE or CLICK to continue', canvas.width / 2, canvas.height / 2 + 40);
                    }
                    
                    ctx.restore();
                }
            }
        }

        function gameLoop(currentTime = 0) {
            // Calculate delta time for frame-rate independent physics
            if (lastFrameTime === 0) lastFrameTime = currentTime;
            const deltaTime = currentTime - lastFrameTime;
            const deltaMultiplier = deltaTime / TARGET_FRAME_TIME; // Normalize to 60 FPS
            lastFrameTime = currentTime;
            
            // Always continue the loop to render overlays, but only update game logic if running
            if (gameRunning && !gamePaused) {
                updatePaddle(deltaMultiplier);
                updateBalls(deltaMultiplier);
                updatePowerUps(deltaMultiplier);
                updateParticles(deltaMultiplier);
                updateScorePopups(deltaMultiplier);
                updateFeedbackMessages(deltaMultiplier);
                checkBlockCollisions();
                
                // Update session every 5 seconds (300 frames at 60fps)
                if (gameSessionId && Date.now() % 5000 < 100) {
                    updateGameSession();
                }
            }
            
            // Always draw to show overlays even when game is stopped
            draw();
            
            // Continue the loop if game is started, there's an active overlay, or showing start screen
            if (gameStarted || gameOverlay.active || (!gameStarted && !gameRunning)) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }


        // Theme management functions
        function detectParentTheme() {
            // Try to detect theme from parent if in iframe
            try {
                if (window.parent && window.parent !== window) {
                    // In iframe - try to get theme from parent
                    const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
                    if (parentTheme) {
                        console.log('Detected parent theme:', parentTheme);
                        return parentTheme;
                    }
                }
            } catch (e) {
                // Cross-origin iframe, can't access parent
                console.log('Cannot access parent theme (cross-origin)');
            }
            
            // Fallback: check localStorage or system preference
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            
            // Check system preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                return 'dark';
            }
            
            return 'light';
        }
        
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            
            // Update theme icon
            const themeIcon = document.getElementById('theme-icon');
            if (themeIcon) {
                themeIcon.className = theme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            }
            
            console.log('Applied theme:', theme);
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        }
        
        function initializeTheme() {
            const theme = detectParentTheme();
            applyTheme(theme);
            
            // Show/hide navigation header based on context
            const navHeader = document.querySelector('.navigation-header');
            if (navHeader) {
                // Always hide navigation if in iframe (embedded mode)
                if (window.parent && window.parent !== window) {
                    navHeader.style.display = 'none';
                    console.log('Running in iframe - hiding navigation header');
                } else {
                    console.log('Running standalone - showing navigation header');
                }
            }
        }

        // Listen for theme changes from parent window
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'themeChange') {
                console.log('Received theme change from parent:', event.data.theme);
                applyTheme(event.data.theme);
            }
        });

        window.addEventListener('DOMContentLoaded', function() {
            initializeTheme();
            initBreakoutGame();
        });
    </script>
</body>
</html>